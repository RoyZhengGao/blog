<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com/blog').hostname,
    root: '/blog/',
    scheme: 'Pisces',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Shell脚本是计算机运行中必不可少的一种脚本语言。应用shell 能够和计算机内核进行交互，同时也能自动化运行所需要运行的程序，还可以快速的进行一些文件的查询功能。因此熟练掌握shell是作为程序员不可缺少的一部分技能。本文整理了一些普通日常中常用的shell 命令。同时也区分了一些容易混淆的shell相关的概念。">
<meta property="og:type" content="article">
<meta property="og:title" content="Shell Script 学习总结 ">
<meta property="og:url" content="http://yoursite.com/blog/2019/12/16/Shell-Script-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="高正太的自留地">
<meta property="og:description" content="Shell脚本是计算机运行中必不可少的一种脚本语言。应用shell 能够和计算机内核进行交互，同时也能自动化运行所需要运行的程序，还可以快速的进行一些文件的查询功能。因此熟练掌握shell是作为程序员不可缺少的一部分技能。本文整理了一些普通日常中常用的shell 命令。同时也区分了一些容易混淆的shell相关的概念。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/blog/2019/12/16/Shell-Script-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/math.png">
<meta property="og:image" content="http://yoursite.com/blog/2019/12/16/Shell-Script-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/relation.png">
<meta property="og:image" content="http://yoursite.com/blog/2019/12/16/Shell-Script-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/boolean.png">
<meta property="og:image" content="http://yoursite.com/blog/2019/12/16/Shell-Script-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/logic.png">
<meta property="og:image" content="http://yoursite.com/blog/2019/12/16/Shell-Script-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/string.png">
<meta property="og:image" content="http://yoursite.com/blog/2019/12/16/Shell-Script-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/file.png">
<meta property="og:image" content="http://yoursite.com/blog/2019/12/16/Shell-Script-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/redirect.png">
<meta property="og:image" content="http://yoursite.com/blog/2019/12/16/Shell-Script-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/logic_pipeline.png">
<meta property="og:image" content="http://yoursite.com/blog/2019/12/16/Shell-Script-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/grep.png">
<meta property="article:published_time" content="2019-12-17T00:04:01.000Z">
<meta property="article:modified_time" content="2025-02-21T20:07:29.125Z">
<meta property="article:author" content="Zheng Gao (高正)">
<meta property="article:tag" content="programming language">
<meta property="article:tag" content="shell">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/blog/2019/12/16/Shell-Script-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/math.png">

<link rel="canonical" href="http://yoursite.com/blog/2019/12/16/Shell-Script-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Shell Script 学习总结  | 高正太的自留地</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">高正太的自留地</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">most in Chinese, rest in English</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2019/12/16/Shell-Script-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.png">
      <meta itemprop="name" content="Zheng Gao (高正)">
      <meta itemprop="description" content="以always Day 1 的心态，工作102年">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高正太的自留地">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Shell Script 学习总结 
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-16 16:04:01" itemprop="dateCreated datePublished" datetime="2019-12-16T16:04:01-08:00">2019-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-21 12:07:29" itemprop="dateModified" datetime="2025-02-21T12:07:29-08:00">2025-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/programming-language/" itemprop="url" rel="index">
                    <span itemprop="name">programming language</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/blog/2019/12/16/Shell-Script-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/blog/2019/12/16/Shell-Script-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>31k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>51 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Shell脚本是计算机运行中必不可少的一种脚本语言。应用shell 能够和计算机内核进行交互，同时也能自动化运行所需要运行的程序，还可以快速的进行一些文件的查询功能。因此熟练掌握shell是作为程序员不可缺少的一部分技能。本文整理了一些普通日常中常用的shell 命令。同时也区分了一些容易混淆的shell相关的概念。</p>
<span id="more"></span>
<h2 id="Linux各种系统和Unix">Linux各种系统和Unix</h2>
<p>UNIX是一个功能强大、性能全面的多用户、多任务操作系统，可以应用从巨型计算机到普通PC机等多种不同的平台上，是应用面最广、影响力最大的操作系统。Linux是一种外观和性能与UNIX相同或更好的操作系统，但，Linux不源于任何版本的UNIX的源代码，并不是UNIX，而是一个类似于UNIX的产品。<br>
Unix是大型机系统，内核是保密的。而Linux是微型机系统，内核是公开的。</p>
<h2 id="Shell介绍">Shell介绍</h2>
<p>Windows、Mac OS、Android 等操作系统都由一家公司开发，所有的核心软件和基础库都由一家公司做决定，容易形成统一的标准，一般不会开发多款功能类似的软件。而 Linux不一样，它是“万国牌”，由多个组织机构开发，不同的组织机构为了发展自己的 Linux 分支可能会开发出功能类似的软件，它们各有优缺点，用户可以自由选择。Shell 就是这样的一款软件，不同的组织机构开发了不同的 Shell，它们各有所长，有的占用资源少，有的支持高级编程功能，有的兼容性好，有的重视用户体验。</p>
<p>Linux有非常多的发行版本，从性质上划分，大体分为由商业公司维护的商业版本与由开源社区维护的免费发行版本。商业版本以Redhat为代表，开源社区版本则以Debian为代表（主要包括CentOS、Ubuntu、Debian）。</p>
<h3 id="几种常见的Shell">几种常见的Shell</h3>
<p>常见的 Shell 有 sh、bash、csh、tcsh、ash 等。</p>
<ul>
<li>sh: 全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。sh 是 UNIX 上的标准 shell，很多 UNIX 版本都配有 sh。sh 是第一个流行的 Shell。</li>
<li>csh: 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。Bill Joy 是一个风云人物，他创立了 BSD 操作系统，开发了 vi 编辑器，还是 Sun 公司的创始人之一。</li>
<li>tcsh: 是 csh 的增强版，加入了命令补全功能，提供了更加强大的语法支持。</li>
<li>ash: 一个简单的轻量级的 Shell，占用资源少，适合运行于低内存环境，但是与下面讲到的 bash shell 完全兼容。</li>
<li>bash: bash 由 GNU 组织开发，保持了对 sh shell 的兼容性，是各种 Linux 发行版默认配置的 shell。</li>
</ul>
<h3 id="查看Shell">查看Shell</h3>
<p>Shell 是一个程序，一般都是放在<code>/bin</code>或者<code>/user/bin</code>目录下，当前 Linux 系统可用的 Shell 都记录在<code>/etc/shells</code>文件中。<code>/etc/shells</code>是一个纯文本文件，你可以在图形界面下打开它，也可以使用 cat 命令查看它。</p>
<p>通过 cat 命令来查看当前 Linux 系统的可用 Shell：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/shells</span><br><span class="line"># List of acceptable shells for chpass(1).</span><br><span class="line"># Ftpd will not allow users to connect who are not using</span><br><span class="line"># one of these shells.</span><br><span class="line"></span><br><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure>
<p>如果你希望查看当前 Linux 的默认 Shell，那么可以输出 SHELL 环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $SHELL</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
<p>输出结果表明默认的 Shell 是 bash。</p>
<h3 id="bashrc和-bash-profile">~/.bashrc和~/.bash_profile</h3>
<ul>
<li><code>/etc/profile</code> 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置。</li>
<li><code>/etc/bashrc</code> 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取。</li>
<li><code>~/.bash_profile</code> 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次! 默认情况下,他设置一些环境变量,执行用户的.bashrc文件。</li>
<li><code>~/.bashrc</code> 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。</li>
</ul>
<p>为了在terminal读取 <code>.bash_profile</code>文件后就会load <code>.bashrc</code>文件中的内容，可以将一下内容加到<code>.bash_profile</code>文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ -f ~/.bashrc ]; then</span><br><span class="line">   source ~/.bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h3 id="brew-rpm-yum和apt-get的关系">brew,rpm,yum和apt-get的关系</h3>
<p>apt-get属于ubuntu、Debian的包管理工具，yum则属于Redhat、Centos包管理工具。rpm是由红帽公司开发的软件包管理方式，使用rpm我们可以方便的进行软件的安装、查询、卸载、升级等工作。但是rpm软件包之间的依赖性问题往往会很繁琐,尤其是软件由多个rpm包组成时。rpm 只能安装已经下载到本地机器上的rpm 包. yum能在线下载并安装rpm包,能更新系统,且还能自动处理包与包之间的依赖问题,这个是rpm 工具所不具备的。    Homebrew简称brew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，可以说Homebrew就是mac下的apt-get、yum神器。</p>
<h2 id="Shell编程基础">Shell编程基础</h2>
<h3 id="解释器">解释器</h3>
<p>脚本的第一行有<code>#!/bin/bash</code>或者是其他的解释器，如<code>#!/bin/csh</code>，执行该脚本时系统会使用该注明的解释器来解释。运行Shell有两种方式:</p>
<ul>
<li>作为可执行程序  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x test.sh</span><br><span class="line">./test.sh</span><br></pre></td></tr></table></figure>
</li>
<li>作为解释器参数<br>
这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。如：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh test.sh</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="变量">变量</h3>
<ul>
<li>
<p>定义变量时，变量名不加美元符号（$），如：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;zheng&quot;</span><br></pre></td></tr></table></figure>
<p>注意，变量名和等号之间不能有空格。除了显式地直接赋值，还可以用语句给变量赋值，如：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for file in `ls /etc`</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用变量。使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;zheng&quot;</span><br><span class="line">echo $your_name</span><br><span class="line">echo $&#123;your_name&#125;</span><br></pre></td></tr></table></figure>
<p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for skill in Ada Coffe Action Java; do</span><br><span class="line">    echo &quot;I am good at $&#123;skill&#125;Script&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重定义变量。已定义的变量，可以被重新定义，如：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;zheng&quot;</span><br><span class="line">echo $your_name</span><br><span class="line"></span><br><span class="line">your_name=&quot;alibaba&quot;</span><br><span class="line">echo $your_name</span><br></pre></td></tr></table></figure>
<p>这样写是合法的，但注意，第二次赋值的时候不能写$your_name=“alibaba”，使用变量的时候才加美元符。以单引号’ '包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。</p>
</li>
</ul>
<h3 id="特殊变量">特殊变量</h3>
<ul>
<li>$$: 表示当前Shell进程的ID，即pid：<code>echo $$</code></li>
<li>$0: 当前脚本的文件名</li>
<li>$n: 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。</li>
<li>$#: 传递给脚本或函数的参数个数。</li>
<li>$*: 传递给脚本或函数的所有参数。</li>
<li>$@: 传递给脚本或函数的所有参数。被双引号(&quot; “)包含时，与 $* 稍有不同，$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(” “)包含时，都以”$1&quot; “$2” … “$n” 的形式输出所有参数。但是当它们被双引号(&quot; “)包含时，”$*&quot; 会将所有的参数作为一个整体，以&quot;$1 $2 … $n&quot;的形式输出所有参数；“$@” 会将各个参数分开，以&quot;$1&quot; “$2” … “$n” 的形式输出所有参数。</li>
<li>$?: 上个命令的退出状态，或函数的返回值。</li>
</ul>
<h3 id="将命令的结果赋值给变量">将命令的结果赋值给变量</h3>
<p>Shell 也支持将命令的执行结果赋值给变量，常见的有以下两种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variable=`command`</span><br><span class="line">variable=$(command)</span><br></pre></td></tr></table></figure>
<p>第一种方式把命令用反引号包围起来，反引号和单引号非常相似，容易产生混淆，所以不推荐使用这种方式；第二种方式把命令用$()包围起来，区分更加明显，所以推荐使用这种方式。</p>
<h3 id="变量替换">变量替换</h3>
<p>变量替换可以根据变量的状态（是否为空、是否定义等）来改变它的值.</p>
<ul>
<li>${var}: 变量本来的值</li>
<li>${var:-word}: 如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。</li>
<li>${var:=word}: 如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。</li>
<li>${var:?message}: 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。<br>
若此替换出现在Shell脚本中，那么脚本将停止运行。</li>
<li>${var:+word}: 如果变量 var 被定义，那么返回 word，但不改变 var 的值。</li>
</ul>
<h3 id="注释">注释</h3>
<p>以“#”开头的行就是注释，会被解释器忽略。sh里没有多行注释，只能每一行加一个#号。</p>
<h3 id="字符串">字符串</h3>
<ul>
<li>单引号
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</li>
<li>单引号字串中不能出现单引号（对单引号使用转义符后也不行）</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=&#x27;this is a string&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li>双引号
<ul>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">your_name=&#x27;zheng&#x27;</span><br><span class="line">str=&quot;Hello, I know your are \&quot;$your_name\&quot;! \n&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>字符串操作
<ul>
<li>拼接字符串</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;qinjx&quot;</span><br><span class="line">greeting=&quot;hello, &quot;$your_name&quot; .&quot;</span><br><span class="line">greeting_1=&quot;hello, $&#123;your_name&#125; .&quot;</span><br><span class="line">echo $greeting $greeting_1</span><br></pre></td></tr></table></figure>
<ul>
<li>获取字符串长度</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;abcd&quot;</span><br><span class="line">echo $&#123;#string&#125; #输出：4</span><br></pre></td></tr></table></figure>
<ul>
<li>提取子字符串</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;alibaba is a great company&quot;</span><br><span class="line">echo $&#123;string:1:4&#125; #输出：liba</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组">数组</h3>
<p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似与C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。<br>
在Shell中，用括号来表示数组，数组元素用“空格”符号分割开。定义数组的一般形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value1 ... valuen)</span><br></pre></td></tr></table></figure>
<p>读取数组元素值的一般格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;array_name[index]&#125;</span><br></pre></td></tr></table></figure>
<p>使用@ 或 * 可以获取数组中的所有元素，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;array_name[*]&#125;</span><br><span class="line">$&#123;array_name[@]&#125;</span><br></pre></td></tr></table></figure>
<p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 取得数组元素的个数</span><br><span class="line">length=$&#123;#array_name[@]&#125;</span><br><span class="line"># 或者</span><br><span class="line">length=$&#123;#array_name[*]&#125;</span><br><span class="line"># 取得数组单个元素的长度</span><br><span class="line">lengthn=$&#123;#array_name[n]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运算符">运算符</h3>
<ul>
<li><strong>算术运算符</strong>：原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。expr 是一款表达式计算工具，使用它能完成表达式的求值操作。需要注意的是，表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。此外，完整的表达式要被 `` 包含。乘号(*)前边必须加反斜杠(\)才能实现乘法运算。e.g. 我们定义两个变量<code>a=10, b=20</code>:<br>
<img src="math.png" alt="math"/></li>
<li><strong>关系运算符</strong>：关系运算符只支持数字，不支持字符串，除非字符串的值是数字。e.g. 我们定义两个变量<code>a=10, b=20</code>:<br>
<img src="relation.png" alt="relation"/></li>
<li><strong>布尔运算符</strong>：返回true/false。e.g. 我们定义两个变量<code>a=10, b=20</code>:<br>
<img src="boolean.png" alt="boolean"/></li>
<li><strong>逻辑运算符</strong>：与布尔运算符基本类似，返回true/false。e.g. 我们定义两个变量<code>a=10, b=20</code>:<br>
<img src="logic.png" alt="logic"/></li>
<li><strong>字符串运算符</strong>：判断字符串属性。假定变量 a 为 “abc”，变量 b 为 “efg”：<br>
<img src="string.png" alt="string"/></li>
<li><strong>文件测试运算符</strong>：用于检测 Unix 文件的各种属性。<br>
<img src="file.png" alt="file"/></li>
</ul>
<h2 id="linux中的各种括号">linux中的各种括号</h2>
<p>()、[]、{}、(())、[[]]<br>
（<br>
各种括号的比较<br>
条件表达式要放在方括号之间，并且要有空格，例如 <code>[$a==$b]</code> 是错误的，必须写成 <code>[ $a == $b ]</code></p>
<h3 id="单小括号">单小括号()</h3>
<ol>
<li>在 bash shell 中，$( ) 与`` (反引号) 都可用做命令替换用。e.g. <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">version=$(uname -r)</span><br><span class="line">version=`uname -r`</span><br></pre></td></tr></table></figure>
都可以是version得到内核的版本号.</li>
<li>命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。e.g. <code>(cmd1;cmd2;cmd3)</code> 新开一个子shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后可以没有分号。</li>
<li>用于初始化数组。如：<code>array=(a b c d)</code></li>
</ol>
<h3 id="双小括号">双小括号 (( ))</h3>
<ol>
<li>整数扩展。这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是&quot;假&quot;，而一个非零值的表达式所返回的退出状态码将为0，或者是&quot;true&quot;。若是逻辑判断，表达式exp为真则为1,假则为0。</li>
<li>只要括号中的运算符、表达式符合C语言运算规则，都可用在$((exp))中，甚至是三目运算符。此时作用$(())和$[]作用几乎相同。$(())的独特之处在于，作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo $((16#5f)) 结果为95 (16进位转十进制)</li>
<li>单纯用 (( )) 也可重定义变量值，比如 a=5; ((a++)) 可将 $a 重定义为6</li>
<li>双括号中的变量可以不使用$符号前缀。括号内支持多个表达式用逗号分开。</li>
</ol>
<h3 id="单中括号">单中括号 []</h3>
<ol>
<li>bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。</li>
<li>test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较 “ab&quot;和&quot;bc”：[ ab &lt; bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。</li>
<li>字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。</li>
<li>在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。</li>
</ol>
<h3 id="双中括号">双中括号 [[]]</h3>
<ol>
<li>[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。</li>
<li>支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如<code>[[ hello == hell? ]]</code>，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。</li>
<li>使用[[ … ]]条件判断结构，而不是[ … ]，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用<code>if [[ $a !=1 &amp;&amp; $a != 2 ]]</code>, 如果不适用双括号, 则为<code>if [ $a -ne 1] &amp;&amp; [ $a != 2 ]</code>或者<code>if [ $a -ne 1 -a $a != 2 ]</code>。</li>
<li>bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。</li>
</ol>
<h3 id="大括号">大括号 {}</h3>
<ol>
<li>花括号拓展。(通配(globbing))将对花括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。
<ul>
<li>对大括号中的以逗号分割的文件列表进行拓展。e.g.<code>touch &#123;a,b&#125;.txt</code> 结果为a.txt b.txt。</li>
<li>对大括号中以点点（…）分割的顺序文件列表起拓展作用，如：<code>touch &#123;a…d&#125;.txt</code> 结果为a.txt b.txt c.txt d.txt。</li>
</ul>
</li>
<li>代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，花括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。</li>
</ol>
<h2 id="条件测试命令">条件测试命令</h2>
<p>test命令，测试特定的表达式是否成立，当条件成立时，命令执行后的返回值为0，否则为其他数值。<br>
格式1：test 条件表达式<br>
格式2：[ 条件表达式 ] //常用格式，使用方括号时，要注意在条件两边加上空格。</p>
<p>常见测试类型: 测试文件状态，字符串的比较，整数值的比较，逻辑测试。<br>
[]完全等价于test，只是写法不同。e.g.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=&quot;ru1noob&quot;</span><br><span class="line">num2=&quot;runoob&quot;</span><br><span class="line">if test $num1 = $num2</span><br><span class="line">then</span><br><span class="line">    echo &#x27;两个字符串相等!&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;两个字符串不相等!&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h2 id="函数">函数</h2>
<ol>
<li>可以带function fun() 定义，也可以直接fun() 定义,不带任何返回参数。e.g. <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">demoFun()&#123;</span><br><span class="line">    echo &quot;这是我的第一个 shell 函数!&quot;</span><br><span class="line">&#125;demoFun</span><br></pre></td></tr></table></figure>
</li>
<li>参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function demoFun2()&#123;</span><br><span class="line"> echo &quot;这是我的第二个 shell 函数!&quot;</span><br><span class="line"> expr 1 + 1 # or return `expr 1 + 1`</span><br><span class="line">&#125;</span><br><span class="line">a=`demoFun2` </span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure>
</li>
<li>带输入参数的函数： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">funWithParam()&#123;</span><br><span class="line">    echo &quot;The value of the first parameter is $1 !&quot;</span><br><span class="line">    echo &quot;The value of the second parameter is $2 !&quot;</span><br><span class="line">    echo &quot;The value of the tenth parameter is $10 !&quot;</span><br><span class="line">    echo &quot;The value of the tenth parameter is $&#123;10&#125; !&quot;</span><br><span class="line">    echo &quot;The value of the eleventh parameter is $&#123;11&#125; !&quot;</span><br><span class="line">    echo &quot;The amount of the parameters is $# !&quot;  # 参数个数</span><br><span class="line">    echo &quot;The string of the parameters is $* !&quot;  # 传递给函数的所有参数</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="输入输出重定向">输入输出重定向</h2>
<p>大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回​​到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p>
<p>重定向命令列表如下：<br>
<img src="redirect.png" alt="redirect"/></p>
<h3 id="输出重定向">输出重定向</h3>
<p>重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &gt; file1</span><br></pre></td></tr></table></figure>
<h3 id="输入重定向">输入重定向</h3>
<p>和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &lt; file1</span><br></pre></td></tr></table></figure>
<h3 id="重定向深入讲解">重定向深入讲解</h3>
<p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p>
<ul>
<li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li>
<li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li>
<li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li>
</ul>
<p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p>
<ol>
<li>如果希望 stderr 重定向到 file，可以这样写： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$command 2 &gt; file</span><br></pre></td></tr></table></figure>
</li>
<li>如果希望 stderr 追加到 file 文件末尾，可以这样写： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$command 2 &gt;&gt; file</span><br></pre></td></tr></table></figure>
</li>
<li>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$command &gt; file 2&gt;&amp;1</span><br><span class="line">$command &gt;&gt; file 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
</li>
<li>如果希望对 stdin 和 stdout 都重定向，可以这样写： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$command &lt; file1 &gt;file2</span><br></pre></td></tr></table></figure>
command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。</li>
</ol>
<h2 id="流程控制">流程控制</h2>
<h3 id="后台执行">后台执行</h3>
<p>当我们在终端或控制台工作时，可能不希望由于运行一个作业而占住了屏幕，因为可能还有更重要的事情要做，比如阅读电子邮件。对于密集访问磁盘的进程，我们更希望它能够在每天的非负荷高峰时间段运行(例如凌晨)。为了使这些进程能够在后台运行，也就是说不在终端屏幕上运行，有几种选择方法可供使用。</p>
<ol>
<li><code>&amp;</code>:<br>
当在前台运行某个作业时，终端被该作业占据；可以在命令后面加上&amp; 实现后台运行。例如：sh <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a> &amp;<br>
适合在后台运行的命令有f i n d、费时的排序及一些s h e l l脚本。在后台运行作业时要当心：需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。不过，作业在后台运行一样会将结果输出到屏幕上，干扰你的工作。如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command  &gt;  out.file  2&gt;&amp;1  &amp; </span><br></pre></td></tr></table></figure>
这样，所有的标准输出和错误输出都将被重定向到一个叫做out.file 的文件中。</li>
<li>nohup: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup command &amp;</span><br></pre></td></tr></table></figure>
如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup command &gt; myout.file 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台运行命令之后，需要使用<code>exit</code>正常退出当前账户，这样才能保证命令一直在后台运行。</li>
</ol>
<p>输出部分解析：</p>
<ul>
<li><code>command&gt;out.file</code>是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。</li>
<li><code>2&gt;&amp;1</code> 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&amp;， 是让该命令在后台执行。</li>
<li>试想<code>2&gt;1</code>代表什么，2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成<code>2&gt;&amp;1</code>，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出.</li>
</ul>
<h3 id="多命令按顺序执行">多命令按顺序执行</h3>
<ol>
<li>
<p>使用获取命令行输出的方法。即用 ` 号将需要获取输出的操作括起来，并赋值给一个变量，则 Shell 会在等待命令执行完成后把输出内容用于赋值，所以，这就是实现了我们需要的等待效果，并且时间精准性很高。e.g.</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">command 1</span><br><span class="line">output=`command 2`</span><br><span class="line">command 3</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用逻辑运算符。具体见下：<br>
<img src="logic_pipeline.png" alt="logic_pipeline"  width="500"/><br>
此外，<code>|</code>称为管道符，当用此连接符连接多个命令时，前面命令执行的正确输出，会交给后面的命令继续处理。若前面的命令执行失败，则会报错，若后面的命令无法处理前面命令的输出，也会报错。举例说明 e.g.</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls ; date; cd /user; pwd</span><br><span class="line">cp /root/test /tmp/test &amp;&amp; rm -rf/ root/test &amp;&amp; echo yes</span><br><span class="line">ls | date | pwd</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>wait</code>命令。wait是用来阻塞当前进程的执行，直至指定的子进程执行结束后，才继续执行。使用wait可以在bash脚本“多进程”执行模式下，起到一些特殊控制的作用。</p>
<ul>
<li>等待作业号或者进程号制定的进程退出，返回最后一个作业或进程的退出状态状态。如果没有制定参数，则等待所有子进程的退出，其退出状态为0.</li>
<li>如果是shell中等待使用wait，则不会等待调用函数中子任务。在函数中使用wait，则只等待函数中启动的后台子任务。</li>
<li>在shell中使用wait命令，相当于高级语言里的多线程同步。<br>
实例：<br>
　　1. 使用wait等待所有子任务结束。</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sleep 10 &amp; </span><br><span class="line">sleep 5&amp; </span><br><span class="line">wait #等待10秒后，退出</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sleep 10 &amp;</span><br><span class="line">sleep 5&amp;</span><br><span class="line">wait $! #$!表示上个子进程的进程号，wait等待一个子进程，等待5秒后，退出</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2. 在函数中使用wait<br>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun()&#123;</span><br><span class="line">echo &quot;fun is begin.timeNum:$timeNum&quot;</span><br><span class="line">local timeNum=$1</span><br><span class="line">sleep $timeNum &amp;</span><br><span class="line">wait #这个只等待wait前面sleep</span><br><span class="line">echo &quot;fun is end.timeNum:$timeNum&quot;</span><br><span class="line">&#125;</span><br><span class="line">fun 10 &amp;</span><br><span class="line">fun 20 &amp;</span><br><span class="line">wait #如果fun里面没有wait，则整个脚本立刻退出，不会等待fun里面的sleep</span><br><span class="line">echo &quot;all is ending&quot;</span><br></pre></td></tr></table></figure><br>
　　输出结果为：<br>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun is begin.timeNum:10</span><br><span class="line">fun is begin.timeNum:20</span><br><span class="line">fun is end.timeNum:10</span><br><span class="line">fun is end.timeNum:20</span><br><span class="line">all is ending</span><br></pre></td></tr></table></figure><br>
　　从输出结果，可以看到，整个脚本，等待了所有子任务的退出。</p>
<h3 id="if-else">if else</h3>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2 </span><br><span class="line">then </span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>具体例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">elif [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 大于 b&quot;</span><br><span class="line">elif [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;没有符合的条件&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h3 id="for循环">for循环</h3>
<p>一般格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>in列表是可选的，如果不用它，for循环使用命令行的位置参数。例如，顺序输出当前列表中的数字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for loop in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">    echo &quot;The value is: $loop&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="while循环">while循环</h3>
<p>while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真。int从0开始，每次循环处理时，int加1。运行上述脚本，返回数字1到5，然后终止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int=1</span><br><span class="line">while(( $int&lt;=5 ))</span><br><span class="line">do</span><br><span class="line">    echo $int</span><br><span class="line">    let &quot;int++&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="until-循环">until 循环</h3>
<p>until 循环执行一系列命令直至条件为 true 时停止。<br>
until 循环与 while 循环在处理方式上刚好相反。<br>
一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。<br>
until 语法格式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>举例说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=0</span><br><span class="line">until [ ! $a -lt 10 ]</span><br><span class="line">do</span><br><span class="line">   echo $a</span><br><span class="line">   a=`expr $a + 1`</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="case语句">case语句</h3>
<p>case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p>case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。<br>
取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。<br>
下面的脚本提示输入1到4，与每一种模式进行匹配：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;输入 1 到 4 之间的数字:&#x27;</span><br><span class="line">echo &#x27;你输入的数字为:&#x27;</span><br><span class="line">read aNum</span><br><span class="line">case $aNum in</span><br><span class="line">    1)  echo &#x27;你选择了 1&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo &#x27;你选择了 2&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo &#x27;你选择了 3&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo &#x27;你选择了 4&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo &#x27;你没有输入 1 到 4 之间的数字&#x27;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<h3 id="跳出循环">跳出循环</h3>
<p>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。</p>
<ol>
<li>break：break命令允许跳出所有循环（终止执行后面的所有循环）。<br>
下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n &quot;输入 1 到 5 之间的数字:&quot;</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;</span><br><span class="line">        ;;</span><br><span class="line">        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;</span><br><span class="line">            break</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>continue：continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。<br>
对上面的例子进行修改：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n &quot;输入 1 到 5 之间的数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;</span><br><span class="line">        ;;</span><br><span class="line">        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;</span><br><span class="line">            continue</span><br><span class="line">            echo &quot;游戏结束&quot;</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 echo “游戏结束” 永远不会被执行。</p>
<h2 id="文本处理">文本处理</h2>
<p>grep、sed和awk都是文本处理工具，虽然都是文本处理工具单却都有各自的优缺点，一种文本处理命令是不能被另一个完全替换的，否则也不会出现三个文本处理命令了。不过，相比较而言，sed和awk功能更强大而已，且已独立成一种语言来介绍。</p>
<p>grep：grep (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。文本过滤器，如果仅仅是过滤文本，可使用grep，其效率比其他的高很多。（过滤文本）</p>
<p>sed：Stream EDitor，流编辑器。默认只处理模式空间，不处理原数据，如果你处理的数据是针对行进行处理的，可以使用sed。（处理行）</p>
<p>awk：报告生成器，格式化以后显示。如果对处理的数据需要生成报告之类的信息，或者你处理的数据是按列进行处理的，最好使用awk。（处理列）</p>
<p>总结：</p>
<ul>
<li>如果文件是格式化的，即由分隔符分为多个域的，优先使用awk</li>
<li>awk适合按列（域）操作，sed适合按行操作</li>
<li>awk适合对文件的抽取整理，sed适合对文件的编辑。</li>
<li>grep 主要用于搜索某些字符串，sed，awk 用于处理文本</li>
</ul>
<h3 id="grep">grep</h3>
<p>grep是一个最初用于Unix操作系统的命令行工具。在给出文件列表或标准输入后，grep会对匹配一个或多个正则表达式的文本进行搜索，并只输出匹配（或者不匹配）的行或文本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">使用格式：（Pattern：文本字符和正则表达式的元字符组合而成匹配条件）</span><br><span class="line"></span><br><span class="line">grep [options] PATTERN [FILE...]</span><br><span class="line">    -i：忽略大小写    </span><br><span class="line">    --color：匹配到字符用其他颜色显示出来，默认是红色</span><br><span class="line">    -v：显示没有被模式匹配到的行</span><br><span class="line">    -o：只显示被模式匹配到的字符串，不显示行</span><br><span class="line">    -E：使用扩展正则表达式</span><br><span class="line">    -A n：表示显示该行及其后n行</span><br><span class="line">    -B n：表示显示该行及其前n行</span><br><span class="line">    -C n：表示显示该行及其前后各n行</span><br><span class="line">    </span><br><span class="line">正则表达式：REGular EXPression，REGEXP</span><br><span class="line"></span><br><span class="line">元字符：</span><br><span class="line"></span><br><span class="line">.：匹配任意单个字符</span><br><span class="line">[]：匹配指定范围内的任意单个字符</span><br><span class="line">[^]：匹配指定范围外的任意单个字符</span><br><span class="line">   字符集和：[:digit:]，[:lower:]，[:upper:]，[:punct:]，[:space:]，[:alpha:]，[:alnum:]</span><br><span class="line">    对应上边：数字  ，小写字母，大写字母，标点符号，空白字符，所有字母，所有数字和字母</span><br><span class="line"></span><br><span class="line">匹配次数（贪婪模式，即尽可能长的匹配）：</span><br><span class="line">*：匹配其前面的字符任意次</span><br></pre></td></tr></table></figure>
<p>匹配.b和.*b，看二者有什么区别，命令和显示效果如下：<br>
<img src="grep.png" alt="grep"  width="500"/></p>
<p><strong>grep练习：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">1. 显示/proc/meminfo文件中以不区分大小的s开头的行；</span><br><span class="line">     grep -i &#x27;^s&#x27; /proc/meminfo    或者</span><br><span class="line">     grep &#x27;^[sS]&#x27; /proc/meminfo   #[]表示匹配指定范围内的单个字符，因此也可实现不区分大小写</span><br><span class="line">     </span><br><span class="line">2. 显示/etc/passwd中以nologin结尾的行;</span><br><span class="line">     grep &#x27;nologin$&#x27; /etc/passwd</span><br><span class="line">     扩展一：取出默认shell为/sbin/nologin的用户列表</span><br><span class="line">           grep &#x27;/sbin/nologin&#x27; /etc/passwd | cut -d: -f1    或者</span><br><span class="line">           grep &#x27;/sbin/nologin&#x27; /etc/passwd | awk -F: &#x27;&#123;print $1&#125;&#x27;     或者直接使用awk</span><br><span class="line">           awk -F: &#x27;$7 ~ /nologin/&#123;print $1&#125;&#x27; /etc/passwd</span><br><span class="line">     扩展二：取出默认shell为bash，且其用户ID号最小的用户的用户名</span><br><span class="line">           grep &#x27;bash$&#x27; /etc/passwd | sort -n -t: -k3 | head -1 | cut -d: -f1   或者</span><br><span class="line">           awk -F: &#x27;$7 ~ /bash/&#123;print $3,$1&#125;&#x27; /etc/passwd | sort -n | head -1 | awk &#x27;&#123;print $2&#125;&#x27;</span><br><span class="line">3. 显示/etc/inittab中以#开头，且后面跟一个或多个空白字符，而后又跟了任意非空白字符的行；</span><br><span class="line">      grep &#x27;^#[[:space:]]\&#123;1,\&#125;[^[:space:]]&#x27; /etc/inittab</span><br><span class="line">4. 显示/etc/inittab中包含了:一个数字:(即两个冒号中间一个数字)的行；</span><br><span class="line">      grep &#x27;:[0-9]:&#x27; /etc/inittab</span><br><span class="line">5. 显示/boot/grub/grub.conf文件中以一个或多个空白字符开 头的行；</span><br><span class="line">      grep &#x27;^[[:space:]]\&#123;1,\&#125;&#x27; /boot/grub/grub.conf</span><br><span class="line">6. 显示/etc/inittab文件中以一个数字开头并以一个与开头数字相同的数字结尾的行；</span><br><span class="line">      grep &#x27;\(^[0-9]\).*\1$&#x27; /etc/inittab     #在RHEL5.8以前的版本中可查看到效果</span><br><span class="line">7. 找出某文件中的，1位数，或2位数；</span><br><span class="line">      grep &#x27;\&lt;[[:digit:]][[:digit:]]\?\&gt;&#x27; /etc/inittab  或者</span><br><span class="line">      grep &#x27;\&lt;[0-9]\&#123;1,2\&#125;\&gt;&#x27; /etc/inittab</span><br><span class="line">8. 查找当前系统上名字为student(必须出现在行首)的用户的帐号的相关信息, 文件为/etc/passwd</span><br><span class="line">      grep &#x27;^student:&#x27; /etc/passwd</span><br><span class="line">      扩展：若存在该用户，找出该用户的ID号：</span><br><span class="line">    grep &#x27;^student:&#x27; /etc/passwd | cut -d: -f3  或者# id -u student</span><br><span class="line">            </span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">思考题：用多种方法找出本地的IP地址，这里给出三种方法，如果你还有其他方法可以一起分享下：</span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line">ifconfig eth0|grep -oE &#x27;([0-9]&#123;1,3&#125;\.?)&#123;4&#125;&#x27;|head -n 1</span><br><span class="line">ifconfig eth0|awk -F: &#x27;/inet addr/&#123;split($2,a,&quot; &quot;);print a[1];exit&#125;&#x27;     #这里使用了awk的内置函数，如果不懂可在看完awk的介绍后再来做此题</span><br><span class="line">ifconfig |grep &quot;inet addr&quot;|grep -v &quot;127.0.0.1&quot; |awk -F: &#x27;&#123;print $2&#125;&#x27; |awk &#x27;&#123;print $1&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="sed">sed</h3>
<ul>
<li>sed（意为流编辑器，源自英语“stream editor”的缩写）是Unix常见的命令行程序。</li>
<li>sed 用来把文档或字符串里面的文字经过一系列编辑命令转换为另一种格式输出。</li>
<li>sed 通常用来匹配一个或多个正则表达式的文本进行处理。sed是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</li>
<li>sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等</li>
<li>sed是一个精简的、非交互式的编辑器。它能执行与编辑vi和emacs相同的编辑任务，但sed编辑器不提供交互使用方式，只能在命令行下输入编辑命令。</li>
</ul>
<p><strong>使用格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;AddressCommand&#x27; file ...</span><br><span class="line">    -n：静默模式，不再显示模式空间中的内容</span><br><span class="line">    -i：直接修改原文件</span><br><span class="line">    -e SCRIPT -e SCRIPT：添加脚本到将要执行的命令中，可以同时执行多个脚本</span><br><span class="line">    -f /PATH/TO/SED_SCORIPT：添加脚本文件中的内容到将要执行的命令中</span><br><span class="line">         #sed -f /path/to/script file</span><br><span class="line">    -r：表示使用扩展正则表达式</span><br><span class="line"></span><br><span class="line">Address:</span><br><span class="line">    1、StartLine,EndLine：开始行，结束行</span><br><span class="line">       如：1,100:表示从第1行到第100行</span><br><span class="line">        $；最后一行</span><br><span class="line">    2、/RegExp/：扩展正则表达式</span><br><span class="line">       如：/^root/</span><br><span class="line">    3、/pattern1/,/pattern2/：表示第一次被pattern1匹配到的行开始，至第一次被pattern2匹配到的行结束，这中间的所有行</span><br><span class="line">    4、LIneNumber：指定的行</span><br><span class="line">    5、StartLIne，+N：从StartLine开始，向后的N行</span><br><span class="line"></span><br><span class="line">Command:</span><br><span class="line">    d：删除符合条件的行；</span><br><span class="line">    p：显示符合条件的行，在不使用-n选项时被匹配到的行会显示两遍，因为sed处理时会把处理的信息输出</span><br><span class="line">    a \string：在指定的行后面追加新行，内容为“string”,</span><br><span class="line">        显示两行或多行，在每行后加\n进行换行</span><br><span class="line">    i \string：在指定的行前面添加新行，内容为string</span><br><span class="line">    r file：将指定的文件的内容添加至符合条件的文件中</span><br><span class="line">    w file：将地址指定范围内的行另存至指定的文件中</span><br><span class="line">    s/pattern/string/修饰符：查找并替换，默认只替换每行中第一次被模式匹配到的字符串</span><br><span class="line">        加修饰符</span><br><span class="line">         g：全局替换，如：s/pattern/string/g</span><br><span class="line">         i：忽略字符大小写，如：s/pattern/string/i</span><br><span class="line">    s///,s###,s@@@都可以，当所使用的分割符号与内容中显示的相同时，需使用转义字符转义    </span><br><span class="line">        \(\),\1,\2：成组匹配，\1表示匹配第一个‘(’，\2表示匹配第二个‘(’</span><br><span class="line">    &amp;：引用模式匹配到的整个串</span><br></pre></td></tr></table></figure>
<p><strong>sed 练习:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、删除/etc/grub.conf文件中行首的空白符；</span><br><span class="line">      sed  -r &#x27;s/^[[:space:]]+//&#x27; /etc/grub.conf</span><br><span class="line">2、替换/etc/inittab文件中“id:3:initdefault:”一行中的数字为5；</span><br><span class="line">     sed &#x27;s/\(id:\)[0-9]\(:initdefault:\)/\15\2/g&#x27; /etc/inittab</span><br><span class="line">3、删除/etc/inittab文件中的空白行；</span><br><span class="line">     sed &#x27;/^$/d&#x27; /etc/inittab</span><br><span class="line">4、删除/etc/inittab文件中开头的#号；</span><br><span class="line">     sed &#x27;s/^#//g&#x27; /etc/inittab</span><br><span class="line">5、删除某文件中开头的#号及其后面的空白字符，但要求#号后面必须有空白符；</span><br><span class="line">     sed &#x27;s/^#[[:space:]]\&#123;1,\&#125;//g&#x27; /etc/inittab     或者</span><br><span class="line">     sed  -r &#x27;s/^#[[:space:]]+//g&#x27; /etc/inittab</span><br><span class="line">6、删除某文件中以空白字符后面跟#类的行中的开头的空白字符及#</span><br><span class="line">     sed -r &#x27;s/^[[:space:]]+#//g&#x27; /etc/inittab</span><br><span class="line">7、取出一个文件路径的目录名称;</span><br><span class="line">     echo &quot;/etc/rc.d/abc/edu/&quot; | sed -r &#x27;s@^(/.*/)[^/]+/?@\1@g&#x27;        #因sed支持扩展正则表达式，在扩展正则表达式中，+表示匹配其前面的字符至少1次</span><br><span class="line">8、取出一个文件路径的最后一个文件名；</span><br><span class="line">     echo &quot;/etc/rc.d/abc/edu/&quot; | sed -r &#x27;s@^/.*/([^/]+)/?@\1@g&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="awk">awk</h3>
<p>与sed和grep很相似，awk是一种样式扫描与处理工具。但其功能却大大强于sed和grep。<br>
awk提供了极其强大的功能：它几乎可以完成grep和sed所能完成的全部工作，同时，它还可以可以进行样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。它具备了一个完整的语言所应具有的几乎所有精美特性。</p>
<ol>
<li>使用格式： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk [options] &#x27;script&#x27; file1, file2, ...</span><br><span class="line">或者</span><br><span class="line">awk [options] &#x27;PATTERN &#123; action &#125;&#x27; file1, file2, ...</span><br></pre></td></tr></table></figure>
options 有<code>-F</code>，<code>-v</code>等等一系列。以下介绍几个比较常用的awk用法：
<ul>
<li>用法1：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F  #-F相当于内置变量FS, 指定分割字符</span><br></pre></td></tr></table></figure>
举例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 每行按空格或TAB分割，输出文本中的1、4项</span><br><span class="line">awk &#x27;&#123;print $1,$4&#125;&#x27; log.txt</span><br></pre></td></tr></table></figure>
</li>
<li>用法2：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F  #-F相当于内置变量FS, 指定分割字符</span><br></pre></td></tr></table></figure>
举例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用&quot;,&quot;分割</span><br><span class="line">awk -F, &#x27;&#123;print $1,$2&#125;&#x27;   log.txt</span><br><span class="line"># 使用多个分隔符.先使用空格分割，然后对分割结果再使用&quot;,&quot;分割</span><br><span class="line">awk -F &#x27;[ ,]&#x27;  &#x27;&#123;print $1,$2,$5&#125;&#x27;   log.txt</span><br></pre></td></tr></table></figure>
</li>
<li>用法3：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -v  # 设置变量</span><br></pre></td></tr></table></figure>
举例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -va=1 &#x27;&#123;print $1,$1+a&#125;&#x27; log.txt</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>awk内置变量之记录变量：
<ul>
<li>FS: field separator，字段分隔符，默认是空白字符；</li>
<li>RS: Record separator，记录分隔符，默认是换行符；</li>
<li>OFS: Output Filed Separator，输出字段分隔符</li>
<li>ORS：Output Row Separator，输出行分隔符</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;OFS=&quot;#&quot;&#125; &#123;print $1,$2&#125;&#x27; test.txt    #指定输出时的分隔符</span><br><span class="line">awk &#x27;BEGIN&#123;OFS=&quot;#&quot;&#125; &#123;print $1,&quot;hello&quot;,$2&#125;&#x27; test.txt #指定输出时的分隔符，并添加显示的内容</span><br></pre></td></tr></table></figure>
</li>
<li>awk内置变量之数据变量：
<ul>
<li>NR: The number of input records，awk命令所处理的记录数；如果有多个文件，这个数目会把处理的多个文件中行统一计数；</li>
<li>NF：Number of Field，当前记录的字段个数，有时可用来表示最后一个字段</li>
<li>FNR: 与NR不同的是，FNR用于记录正处理的行是当前这一文件中被总共处理的行数；</li>
<li>ARGV: 数组，保存命令行本身这个字符串，如awk ‘{print $0}’ a.txt b.txt这个命令中，ARGV[0]保存awk，ARGV[1]保存a.txt；</li>
<li>ARGC: awk命令的参数的个数；</li>
<li>FILENAME: awk命令所处理的文件的名称；</li>
<li>ENVIRON：当前shell环境变量及其值的关联数组；</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;print ENVIRON[&quot;PATH&quot;]&#125;&#x27;</span><br><span class="line">awk &#x27;&#123;print $NF&#125;&#x27; test.txt</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="其他常用命令">其他常用命令</h2>
<ul>
<li><code>echo</code>: echo是Shell的一个内部指令，用于在屏幕上打印出指定的字符串。 e.g. <code>echo &quot;It is a test&quot;</code></li>
<li><code>printf</code>: printf 命令用于格式化输出， 是echo命令的增强版。它是C语言printf()库函数的一个有限的变形，并且在语法上有些不同。e.g. <code>printf &quot;%d %s\n&quot; 1 &quot;abc&quot;</code>，输出为“1 abc&quot;.</li>
<li><code>source</code>：<code>source filename</code>这个命令其实只是简单地读取脚本里面的语句依次在当前shell里面执行，没有建立新的子shell。那么脚本里面所有新建、改变变量的语句都会保存在当前shell里面。相比之下， <code>sh filename</code>会重新建立一个子shell，在子shell中执行脚本里面的语句，该子shell继承父shell的环境变量，但子shell新建的、改变的变量不会被带回父shell。</li>
<li><code>ls</code>和<code>ll</code>: List, 会列举出当前工作目录的内容（文件或文件夹）。-a 列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来。<code>ll</code>并不是linux下一个基本的命令，它实际上是<code>ls -l</code>的一个别名。Ubuntu默认不支持命令ll，必须用 <code>ls -l</code>，这样使用起来不是很方便。</li>
<li><code>dir</code>:列出路径下里的内容。<code>dir -l .</code></li>
<li><code>mkdir</code>: Make Directory, 用于新建一个新目录. e.g. <code>mkdir folder_name</code></li>
<li><code>pwd</code>：Print Working Directory。显示当前工作目录。</li>
<li><code>cd</code>: Change Directory。切换文件路径，cd 将给定的文件夹（或目录）设置成当前工作目录。e.g. <code>cd ~/Desktop</code></li>
<li><code>rmdir</code>: Remove Directory。删除给定的目录。e.g. <code>rmdir folder_name</code></li>
<li><code>rm</code>: Remove.  会删除给定的文件。e.g. <code>rm file_name</code></li>
<li><code>cp</code>:copy, 对文件进行复制。如果是文件夹的话，加上<code>-r</code>。为 <code>cp -r folder/ folder_new/</code></li>
<li><code>scp</code>:和<code>cp</code>类似，专门用来实现本地和服务器的双向传输。<code>scp a.txt gao27@iris.ils.indiana.edu:/a.txt</code></li>
<li><code>mv</code>: Move。对文件或文件夹进行移动，如果文件或文件夹存在于当前工作目录，还可以对文件或文件夹进行重命名。e.g. <code>mv a.txt ../a.txt</code></li>
<li><code>touch</code>:用来修改文件时间戳，或者新建一个不存在的文件。e.g. <code>touch a.txt b.txt</code></li>
<li><code>cat</code>: concatenate and print files。
<ul>
<li>用于在标准输出（监控器或屏幕）上查看文件内容: <code>cat a.txt</code>.</li>
<li>从键盘创建一个文件:<code>cat &gt; filename</code> 只能创建新文件,不能编辑已有文件.</li>
<li>将几个文件合并为一个文件:<code>cat file1 file2 &gt; file</code></li>
</ul>
</li>
<li><code>head/tail</code>: print head/ tail。 默认在标准输出上显示给定文件的最前/后10行内容，可以使用<code>head/tail -n N</code> 指定在标准输出上显示文件的最前/后N行内容。</li>
<li><code>less</code>: print LESS. 按页或按窗口打印文件内容。在查看包含大量文本数据的大文件时是非常有用和高效的。你可以使用Ctrl+F向前翻页，Ctrl+B向后翻页。e.g. <code>less a.txt</code></li>
<li><code>more</code>: 一下子load整个文件，并且支持向前翻页的功能有限。e.g. <code>more a.txt</code></li>
<li><code>grep</code>: 在给定的文件中搜寻指定的字符串。<code>grep -i “”</code> 在搜寻时会忽略字符串的大小写，而<code>grep -r “”</code> 则会在当前工作目录的文件中递归搜寻指定的字符串。e.g. <code>grep -rn &quot;a b c&quot;  folder/</code> 指的是递归查找目录下含有该字符串的所有文件。</li>
<li><code>find</code>:这个命令会在给定位置搜寻与条件匹配的文件。你可以使用<code>find -name</code>的-name选项来进行区分大小写的搜寻，<code>find -iname</code> 来进行不区分大小写的搜寻。e.g. <code>find . -name &quot;*.log&quot;</code>指的是在当前目录及子目录中查找所有的‘ *.log‘文件。</li>
<li><code>tar</code>:创建、查看和提取tar压缩文件。<code>tar -cvf</code> 是创建对应压缩文件，<code>tar -tvf</code> 来查看对应压缩文件，<code>tar -xvf</code> 来提取对应压缩文件。e.g. <code>tar -czvf a.tar.gz file_name</code></li>
<li><code>gzip</code>:创建和提取gzip压缩文件，还可以用<code>gzip -d </code>来提取压缩文件。e.g. <code>gzip a.txt</code></li>
<li><code>uzip</code>:对gzip文档进行解压。在解压之前，可以使用<code>unzip -l</code> 命令查看文件内容。e.g.<code>uzip a.zip</code></li>
<li><code>which</code>: 在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 e.g. <code>which python</code></li>
<li><code>whatis</code>:What is this command. 会用单行来描述给定的命令，就是解释当前命令。e.g. <code>whatis cd</code></li>
<li><code>whereis</code>: 当你不知道某个命令的位置时可以使用whereis命令，下面使用whereis查找ls的位置。e.g. <code>whereis ls</code>.当你想查找某个可执行程序的位置，但这个程序又不在whereis的默认目录下，你可以使用-B选项，并指定目录作为这个选项的参数。下面的命令在/tmp目录下查找lsmk命令: <code>whereis -u -B /tmp -f lsmk</code></li>
<li><code>locate</code>:让使用者可以很快速的搜寻档案系统内是否有指定的档案。<br>
其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。locate的速度比find快，因为它并不是真的查找文件，而是查数据库. locate的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护.e.g.<code>locate /etc/sh</code></li>
<li><code>man</code>: 显示某个命令的man页面.e.g.<code>man ls</code></li>
<li><code>exit</code>: 用于结束当前的终端会话。</li>
<li><code>ping</code>:通过发送数据包ping远程主机(服务器)，常用与检测网络连接和服务器状态。e.g. <code>ping zhenggao.io</code></li>
<li><code>df</code>: Disk space Free。用于查看磁盘分区的使用情况，了解磁盘总量及用量，默认单位为KB。使用-h选项，可以自动切换至合适的单位。e.g. <code>df -h</code></li>
<li><code>du</code>: 用于查看文件、目录在磁盘中占用的空间的大小。<code>du -ah --max-depth=1</code> 可以查看根目录下各个文件占用情况。</li>
<li><code>free</code>：这个命令用于显示系统当前内存的使用情况，包括已用内存、可用内存和交换内存的情况。e.g. <code>free -gt</code></li>
<li><code>chmod</code>:用于改变文件和目录的权限。给指定文件的属主(user u)和属组(group g)和其他(others o)所有权限(包括读、写、执行) <code>chmod ug+rwx file.txt</code>.由于赋值r:4;w:2;x:1，所以更改读（r）,写（w）和执行（x）的语句可以写成<code>chmod 777 file.txt</code></li>
<li><code>chown</code>:chown用于改变文件属主和属组。e.g. <code>chown oracle:db file_name</code>。把属主改成Oracle,属组改成db。</li>
<li><code>top</code>: 能够实时显示系统中各个进程的资源占用状况。e.g. <code>top -u gao27</code></li>
<li><code>ps</code>:Process Status. 列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。<code>ps -u gao27</code></li>
<li><code>kill</code>:用于终止一个进程。一般我们会先用<code>ps -ef</code>查找某个进程得到它的进程号，然后再使用<code>kill -9 pid</code> 进程号终止该进程。</li>
<li><code>xargs</code>: 将标准输入转为命令行参数。xargs的作用在于，大多数命令（比如rm、mkdir、ls）与管道一起使用时，都需要xargs将标准输入转为命令行参数。e.g. <code>echo &quot;one two three&quot; | xargs mkdir</code></li>
<li><code>sort</code>: 将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。e.g. <code>sort a.txt</code></li>
<li><code>uniq</code>: 用于检查及删除文本文件中重复出现的行列。e.g. <code>uniq a.txt</code></li>
<li><code>wc</code>: Word Count。命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。-c 统计字节数。-l统计行数。-m 统计字符数。这个标志不能与 -c 标志一起使用。-w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。e.g. <code>wc -l a.txt</code></li>
<li><code>nl</code>:number lines。可以将输出的文件内容自动的加上行号！其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。e.g. <code>nl a.txt</code></li>
<li><code>cut</code>: cut是一个选取命令，就是将一段数据经过分析，取出我们想要的。一般来说，选取信息通常是针对“行”来进行分析的，并不是整篇信息分析的。其语法格式为：<br>
<code>cut  [-bn] [file]</code> 或 <code>cut [-c] [file]</code> 或  <code>cut [-df] [file]</code></li>
<li><code>ssh</code>: 登录远程服务器。e.g. <code>ssh user@host</code></li>
<li><code>sed</code>: sed 是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。e.g.删除文件第二行： <code>nl a.txt | sed '2d'</code></li>
<li><code>vim</code>: 用Linux内嵌的文本编辑器打开文件。e.g. <code>vim a.txt</code></li>
<li><code>diff</code>: 比较两个file的差别. e.g. <code>diff name_list.txt name_list_new.txt</code></li>
<li><code>export</code>：用于设置或显示环境变量。在 shell 中执行程序时，shell 会提供一组环境变量。export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。e.g.<code>export $PATH=&quot;$PATH:路径1:路径2:...:路径n”</code></li>
<li><code>alias</code>: 在linux系统中如果命令太长又不符合用户的习惯，那么我们可以为它指定一个别名。e.g. <code>alias ls='ls --color=auto'</code></li>
<li><code>ln</code>: links。为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。e.g. <code>ln log2013.log ln2013</code></li>
<li><code>mount</code>：将一个设备（通常是存储设备）挂接到一个已存在的目录上。访问这个目录就是访问该存储设备。e.g. 将 <code>/dev/hda1</code> 挂在 <code>/mnt</code> 之下: <code>mount /dev/hda1 /mnt</code></li>
<li><code>wget</code>: 使用wget从网上下载软件、音乐、视频. e.g. <code>wget -O a.zip http://www.vim.org/scripts/download_script.php?src_id=7701</code></li>
<li><code>file</code>: 该命令用于判断接在file命令后的文件的基本数据，因为在Linux下文件的类型并不是以后缀为分的，所以这个命令对我们来说就很有用。e.g. <code>file file_name</code></li>
<li><code>lsof</code>:列出当前系统打开文件(list open files)，不过通过-i参数也能查看端口的连接情况，-i后跟冒号端口可以查看指定端口信息，直接-i是系统当前所有打开的端口. e.g. <code>lsof -i:22</code></li>
<li><code>read</code>: 从terminal 读入输入。实现交互式shell。e.g.  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read website</span><br><span class="line">echo &quot;你输入的网站名是 $website&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><code>let</code>: 用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。e.g. <code>let a=5+4</code></li>
<li><code>history</code>: 查看命令行中的历史命令。 <code>history -100</code>表明显示最近一百条命令行</li>
<li><code>mpstat</code>: mpstat 是 Multiprocessor Statistics的缩写，是实时监控工具，报告与cpu的一些统计信息这些信息都存在/proc/stat文件中，在多CPU系统里，其不但能查看所有的CPU的平均状况的信息，而且能够有查看特定的cpu信息，mpstat最大的特点是:可以查看多核心的cpu中每个计算核心的统计数据；而且类似工具vmstat只能查看系统的整体cpu情况。</li>
</ul>
<h2 id="待加入的部分">待加入的部分</h2>
<p>log in time for all users:<br>
lastlog</p>
<p>log in time for me:<br>
lastlog | grep gao</p>
<p>检查CPU使用率 从大到小排序<br>
ps auxw --sort=%cpu</p>
<p>list all files:<br>
ls -l</p>
<p>看file system 的大小和使用情况<br>
df -h</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/peida/archive/2012/10/30/2746968.html">http://www.cnblogs.com/peida/archive/2012/10/30/2746968.html</a><br>
<a target="_blank" rel="noopener" href="http://mark-ztw.iteye.com/blog/1544367">http://mark-ztw.iteye.com/blog/1544367</a></p>
<p>查看文件大小，文件夹大小：du -sm *,du -h, du *, du -sm, du -h *,<br>
查看文件多少行：wc -l 2018092121.tsv</p>
<p>[root@linux ~]# tar -cvf /tmp/etc.tar /etc  &lt;==仅打包，不压缩！</p>
<p>[root@linux ~]# tar -czvf /tmp/etc.tar.gz /etc  &lt;==打包后，以 gzip 压缩</p>
<p>[root@linux ~]# tar -cjvf /tmp/etc.tar.bz2 /etc  &lt;==打包后，以 bzip2 压缩</p>
<p>把tar包分成多个小文件：split -b 40M home1.tar.bz2 “home.tar.bz2.part”<br>
把多个小文件合并：cat home.tar.bz2.parta* &gt; home2.tar.bz2</p>
<p>linux 并行执行。用&amp; 和 wait 综合操作。<br>
&amp; 表示并行<br>
wait可以再等前面执行完，串行回来<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/gua___gua/article/details/48682665">https://blog.csdn.net/gua___gua/article/details/48682665</a></p>
<p>如果remove 一个folder ,然后不出现一个一个文件删除的确认的话，需要用<br>
rm -rf folder/<br>
一个一个文件删除的话 用：<br>
rm -r folder/</p>
<p>Shell cheat sheet:<br>
<a target="_blank" rel="noopener" href="https://devhints.io/bash">https://devhints.io/bash</a></p>
<p>对于shell 来说，如果想下一个命令要在上一个命令完成之后才开始的话，需要在每行命令后面加上 &amp;&amp; 符号 <a target="_blank" rel="noopener" href="https://blog.csdn.net/ysdaniel/article/details/6127860">https://blog.csdn.net/ysdaniel/article/details/6127860</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tiwoo/article/details/51094913">https://blog.csdn.net/tiwoo/article/details/51094913</a></p>
<p>有zsh 也有bash. 对应的配置文件为zshrc 和 bashrc. 为了查看到底机器用的是哪个shell, 用<br>
echo $SHELL 来查看。</p>
<p>bashrc 和 bash_profile 的区别： <a target="_blank" rel="noopener" href="https://justcoding.iteye.com/blog/2120331">https://justcoding.iteye.com/blog/2120331</a></p>
<h2 id="quickly-log-in-remote-sever">quickly log in remote sever</h2>
<p>reference:<br>
<a target="_blank" rel="noopener" href="http://blog.csdn.net/leexide/article/details/17252369">http://blog.csdn.net/leexide/article/details/17252369</a><br>
<a target="_blank" rel="noopener" href="https://my.oschina.net/aiguozhe/blog/33994">https://my.oschina.net/aiguozhe/blog/33994</a></p>
<p>process:<br>
local server:</p>
<ol>
<li>ssh-keygen -t rsa (连续三次回车,即在本地生成了公钥和私钥,不设置密码)</li>
<li>ssh <a href="mailto:root@172.24.253.2">root@172.24.253.2</a> “mkdir .ssh;chmod 0700 .ssh” (需要输入密码， 注:必须将.ssh的权限设为700) (if remote server doesn’t have ssh file)</li>
<li>scp ~/.ssh/id_rsa.pub <a href="mailto:root@172.24.253.2">root@172.24.253.2</a>:.ssh/id_rsa.pub (需要输入密码)</li>
</ol>
<p>remote server:<br>
1.<br>
cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys<br>
2.<br>
chmod 600 authorized_keys<br>
3.<br>
chmod 700 -R ~/.ssh<br>
注意都要在对应.ssh 文件目录下进行</p>
<h2 id="Use-anaconda-in-the-server">Use anaconda in the server</h2>
<p>every time to use anaconda pip, you need to execute the command first to find the path:</p>
<p>##虚拟环境<br>
play with IU server<br>
which virtualenv</p>
<p>virtualenv venv<br>
module load python/2.7</p>
<p>pip install gensim<br>
156  virtualenv venv<br>
157  pip install gensim virtualenv venv<br>
158  virtualenv venv<br>
159  virtualenv<br>
160  pwd<br>
161  pip install virtualenv<br>
162  free -g<br>
163  history</p>
<p>164  virtualenv</p>
<p>export PATH=/home/gao27/anaconda/bin:$PATH<br>
或者把这行代码写入~/.bashrc 中，然后 source ~/.bashrc</p>
<p>install Anaconda in server<br>
<a target="_blank" rel="noopener" href="https://docs.anaconda.com/anaconda/install/linux">https://docs.anaconda.com/anaconda/install/linux</a></p>
<p>install pip directly:<br>
<a target="_blank" rel="noopener" href="https://pip.pypa.io/en/stable/installing/#id7">https://pip.pypa.io/en/stable/installing/#id7</a></p>
<h2 id="python-2-7-and-3-5">python 2.7 and 3.5</h2>
<p><a target="_blank" rel="noopener" href="http://conda.pydata.org/docs/py2or3.html">http://conda.pydata.org/docs/py2or3.html</a></p>
<p>$ conda create -n py35 python=3.5 anaconda</p>
<h1></h1>
<h1>To activate this environment, use:</h1>
<h1>$ source activate py35 (source activate py3)</h1>
<h1></h1>
<h1>To deactivate this environment, use:</h1>
<h1>$ source deactivate</h1>
<p>##Linux command<br>
sync local files to remote server:</p>
<p>rsync -avz ./health_care <a href="mailto:gao27@burrow.soic.indiana.edu">gao27@burrow.soic.indiana.edu</a>😕/nfs/nfs4/home/gao27/health_care</p>
<p>sync remote server files to local:<br>
rsync -avz <a href="mailto:gao27@burrow.soic.indiana.edu">gao27@burrow.soic.indiana.edu</a>😕/nfs/nfs4/home/gao27/health_care ./</p>
<p>/usr/libexec/java_home -verbose can return all javas in your computer</p>
<p>把一个文件的前十行 存到另外一个文件中</p>
<p>sed -n -e ‘1,10p’ test.csv &gt; sample.csv</p>
<p>ps aux 指令详解<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/hanner_cheung/article/details/6081440">https://blog.csdn.net/hanner_cheung/article/details/6081440</a></p>
<p>df -h 查看分区剩余容量</p>
<p>d -i 查看index的剩余容量</p>
<p>du -h -d 1 查看当前文件夹大小</p>
<p>vim 的教程：<br>
<a target="_blank" rel="noopener" href="https://harttle.land/2015/11/07/vim-cursor.html">https://harttle.land/2015/11/07/vim-cursor.html</a></p>
<p>使用&amp;和wait改造<br>
在每个进程中使用&amp;符号进行让脚本在后台运行，无需等待当前进程结束。<br>
为了确保每个进程都执行完成，最后务必使用wait关键字，用来确保每一个子进程都执行完成。<br>
[root@artisan test]# cat call_parallel.sh<br>
#!/bin/bash<br>
#当前目录下执行如下脚本  相对路径<br>
./1.sh &amp;<br>
./2.sh &amp;<br>
wait<br>
echo “继续执行剩下的逻辑…”<br>
[root@artisan test]#</p>
<p>文件重命名：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/longdouhzt/archive/2012/04/30/2477282.html">https://www.cnblogs.com/longdouhzt/archive/2012/04/30/2477282.html</a><br>
推荐书籍：</p>
<ul>
<li>Linux命令行与shell脚本编程大全</li>
<li>Linux+Shell脚本攻略</li>
<li>Bash Notes For Professionals</li>
</ul>
<p>参考文献：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/whatday/article/details/78929247">几种常见的Shell</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012150179/article/details/16877323">Linux和Unix的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32274264">CentOS、Ubuntu、Debian三个linux比较异同</a></li>
<li><a target="_blank" rel="noopener" href="https://devhints.io/bash">Bash Scripting Cheatsheet</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.51cto.com/lq2419/1238880">Linux文本处理工具</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/view/2740.html">Shell教程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/peida/archive/2012/12/24/2831353.html">top命令详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/peida/archive/2012/12/25/2831814.html">free命令详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html">xargs命令详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_18312025/article/details/78313414">条件测试命令</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41551450/article/details/92803686?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">各种括号详解</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/view/2736.html">运算符详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-awk.html">awk命令详解</a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/programming-language/" rel="tag"># programming language</a>
              <a href="/blog/tags/shell/" rel="tag"># shell</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2019/12/16/tmux-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" rel="prev" title="tmux 使用指南">
      <i class="fa fa-chevron-left"></i> tmux 使用指南
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2019/12/25/%E6%91%84%E5%BD%B1%E6%8A%80%E5%B7%A7/" rel="next" title="摄影技巧">
      摄影技巧 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E5%90%84%E7%A7%8D%E7%B3%BB%E7%BB%9F%E5%92%8CUnix"><span class="nav-number">1.</span> <span class="nav-text">Linux各种系统和Unix</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shell%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.</span> <span class="nav-text">Shell介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84Shell"><span class="nav-number">2.1.</span> <span class="nav-text">几种常见的Shell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8BShell"><span class="nav-number">2.2.</span> <span class="nav-text">查看Shell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bashrc%E5%92%8C-bash-profile"><span class="nav-number">2.3.</span> <span class="nav-text">~&#x2F;.bashrc和~&#x2F;.bash_profile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#brew-rpm-yum%E5%92%8Capt-get%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.4.</span> <span class="nav-text">brew,rpm,yum和apt-get的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">3.</span> <span class="nav-text">Shell编程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="nav-number">3.1.</span> <span class="nav-text">解释器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">3.2.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F"><span class="nav-number">3.3.</span> <span class="nav-text">特殊变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E5%91%BD%E4%BB%A4%E7%9A%84%E7%BB%93%E6%9E%9C%E8%B5%8B%E5%80%BC%E7%BB%99%E5%8F%98%E9%87%8F"><span class="nav-number">3.4.</span> <span class="nav-text">将命令的结果赋值给变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="nav-number">3.5.</span> <span class="nav-text">变量替换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">3.6.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.7.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">3.8.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.9.</span> <span class="nav-text">运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%8B%AC%E5%8F%B7"><span class="nav-number">4.</span> <span class="nav-text">linux中的各种括号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%B0%8F%E6%8B%AC%E5%8F%B7"><span class="nav-number">4.1.</span> <span class="nav-text">单小括号()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%B0%8F%E6%8B%AC%E5%8F%B7"><span class="nav-number">4.2.</span> <span class="nav-text">双小括号 (( ))</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%B8%AD%E6%8B%AC%E5%8F%B7"><span class="nav-number">4.3.</span> <span class="nav-text">单中括号 []</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%B8%AD%E6%8B%AC%E5%8F%B7"><span class="nav-number">4.4.</span> <span class="nav-text">双中括号 [[]]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E6%8B%AC%E5%8F%B7"><span class="nav-number">4.5.</span> <span class="nav-text">大括号 {}</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="nav-number">5.</span> <span class="nav-text">条件测试命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">6.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">7.</span> <span class="nav-text">输入输出重定向</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">7.1.</span> <span class="nav-text">输出重定向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">7.2.</span> <span class="nav-text">输入重定向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3"><span class="nav-number">7.3.</span> <span class="nav-text">重定向深入讲解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">8.</span> <span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C"><span class="nav-number">8.1.</span> <span class="nav-text">后台执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%91%BD%E4%BB%A4%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="nav-number">8.2.</span> <span class="nav-text">多命令按顺序执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#if-else"><span class="nav-number">8.3.</span> <span class="nav-text">if else</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="nav-number">8.4.</span> <span class="nav-text">for循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="nav-number">8.5.</span> <span class="nav-text">while循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#until-%E5%BE%AA%E7%8E%AF"><span class="nav-number">8.6.</span> <span class="nav-text">until 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#case%E8%AF%AD%E5%8F%A5"><span class="nav-number">8.7.</span> <span class="nav-text">case语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AF"><span class="nav-number">8.8.</span> <span class="nav-text">跳出循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">文本处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#grep"><span class="nav-number">9.1.</span> <span class="nav-text">grep</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sed"><span class="nav-number">9.2.</span> <span class="nav-text">sed</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#awk"><span class="nav-number">9.3.</span> <span class="nav-text">awk</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">10.</span> <span class="nav-text">其他常用命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%85%E5%8A%A0%E5%85%A5%E7%9A%84%E9%83%A8%E5%88%86"><span class="nav-number">11.</span> <span class="nav-text">待加入的部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#quickly-log-in-remote-sever"><span class="nav-number">12.</span> <span class="nav-text">quickly log in remote sever</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Use-anaconda-in-the-server"><span class="nav-number">13.</span> <span class="nav-text">Use anaconda in the server</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python-2-7-and-3-5"><span class="nav-number">14.</span> <span class="nav-text">python 2.7 and 3.5</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">To activate this environment, use:</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">$ source activate py35 (source activate py3)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">To deactivate this environment, use:</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">$ source deactivate</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zheng Gao (高正)"
      src="/blog/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zheng Gao (高正)</p>
  <div class="site-description" itemprop="description">以always Day 1 的心态，工作102年</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RoyZhengGao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RoyZhengGao" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:gao27@indiana.edu" title="Email → mailto:gao27@indiana.edu" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>Email</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.linkedin.com/in/zheng-gao-351b738a/" title="LinkedIn → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;zheng-gao-351b738a&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-linkedin"></i>LinkedIn</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://scholar.google.com/citations?user=C8M7-1YAAAAJ&hl=en" title="Google → https:&#x2F;&#x2F;scholar.google.com&#x2F;citations?user&#x3D;C8M7-1YAAAAJ&amp;hl&#x3D;en" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>Google</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://zhenggao.io/" title="https:&#x2F;&#x2F;zhenggao.io" rel="noopener" target="_blank">个人主页</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zheng Gao (高正)</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">122k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:23</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v7.3.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: '3445JBYAQGXfF0gSJqMyxy5y-gzGzoHsz',
    appKey: 'xSorailV8YU1obYqYz9Yqhyv',
    placeholder: "Comment",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
