<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Apple系统tips</title>
    <url>/blog/2020/06/03/Apple%E7%B3%BB%E7%BB%9Ftips/</url>
    <content><![CDATA[<p>本文记录一些自己在使用Mac，iphone时的一些小技巧，以及怎么样管理和同步自己的设备。</p>
<span id="more"></span>
<h2 id="icloud">icloud</h2>
<p>icloud是个很烦人的东西，为了省事，可以turn off 掉电脑端和iphone端的自动同步功能。尤其是对于photos来说。可以仅保留calender等app的同步。</p>
<h2 id="备份和同步">备份和同步</h2>
<p>最新的Catalina系统已经没有乐itunes,而是用几个具体的app替代了（tv,podcast,music）。而且手机连接电脑之后所有的同步时可以在finder底下看到的。而不是之前的要打开单独的itunes。这种改进方便了许多</p>
<h3 id="backup的位置">backup的位置</h3>
<p>Mac OS X，打开<code>Library\Application Support\MobileSync\Backup</code>里面就是sync的备份。</p>
<h3 id="照片同步">照片同步</h3>
<ul>
<li>直接打开photos这个app，然后就会发现手机会出现在左边栏中。点击自己的手机，进行import，会自动存在photo library 中。</li>
<li>photo library 的路径一般是在<code>/Users/gaozheng/Pictures/</code> 这个文件夹下的后缀名为.photoslibrary的文件夹中。可以建立多个library。</li>
<li>最方便的转移照片库其实是直接将photo library 整个文件夹复制到外接硬盘中。这样其实还可以之后用photos这个app打开，更方便进行访问。</li>
</ul>
<p>参考文献：</p>
<ul>
<li><a href="https://zhidao.baidu.com/question/328701894.html">iphone backup备份地址</a></li>
<li><a href="https://www.iphonelife.com/tip/how-to-get-photos-off-iphone">iphone照片同步到mac中</a></li>
<li><a href="https://osxdaily.com/2017/02/23/where-photos-files-located-mac/">photo library的位置</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>401K 和IRA基础知识</title>
    <url>/blog/2021/02/06/401K-%E5%92%8CIRA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>在美国生活，退休金计划必不可少。主要需要关注401K和IRA（Individual Retirement Account）。其可以细分出几个不同的退休金计划。另外，HSA（Health Saving Accout）也可以作为一个投资的账户。</p>
<span id="more"></span>
<p>税收优惠投资账户主要有以下几种，我们将分别简介一下，最后的部分会给出一个推荐的存放顺序。<br>
<img src="overview.png" alt="overview" width="800" /></p>
<h2 id="企业退休金401K">企业退休金401K</h2>
<p>401K具体内容如下图所示<br>
<img src="401k.png" alt="broker"/></p>
<p>我们按照图1表明的观察顺序来依次解释:</p>
<ul>
<li>图1中间部分表示你的401K账户
<ul>
<li>401K账户由三部分组成包括pre-tax401KRoth401K和after-tax contribution</li>
<li>pre-tax401K：每次投入的钱来自税前等到退休之后取出本金和收益都要缴税（收入税）
<ul>
<li>也叫traditional 401K</li>
<li>存钱来自税前</li>
<li>在账户内的投资收益免税</li>
<li>59.5岁前取出，取出金额需要缴纳10%的罚金，同时这些金额也要缴纳收入税。因此总的税率是10%+你的收入税率。</li>
<li>59.5岁之后取出，方可免罚金，取出金额当做收入缴税。</li>
<li>70.5岁之后，必须取出。这叫做RMD(required minumum distributiion) rule.</li>
</ul>
</li>
<li>Roth401K:每次投入的钱来自税后等到退休之后取出本金和收益都免税
<ul>
<li>存钱来自税后</li>
<li>账户内的投资收益免税</li>
<li>在59.5岁之前死亡或者残疾，可以提前取出免罚金。</li>
<li>59.5岁前取出，取出金额需要缴纳10%的罚金，同时这些金额也要缴纳收入税。因此总的税率是10%+你的收入税率。</li>
<li>59.5岁之后取出，方可免罚金，取出金额当做收入缴税。</li>
<li>70.5岁之后，必须取出。这叫做RMD(required minumum distributiion) rule.</li>
</ul>
</li>
<li>after-tax contribution:每次投入的钱来自税后等退休之后取出本金部分免税收益缴税(收入税)
<ul>
<li>存钱来自税后</li>
<li>59.5岁之后取出，方可免罚金，取出金额当做收入缴税。</li>
<li>after-tax contribution是可以合法地通过megabackdoor conversion转换成Roth401K</li>
</ul>
</li>
</ul>
</li>
<li>图1右边部分表示401K账户的年度限制
<ul>
<li>401K投入的总额度每年均不同比如2020年的上限是$57000（如果你小于50岁）</li>
<li>每年对于employee-contribution pre-tax 401K与roth 401K的总和上限是不同的例如2020年是$19500</li>
<li>不是所有公司都提供Roth401K虽然大部分公司都能提供但是你还是要跟公司确认一下</li>
<li>不是所有公司都提供after tax contribution</li>
</ul>
</li>
<li>图1左边部分表示如何投钱进入401K账户
<ul>
<li>有的公司会match员工401K公司match的钱永远都是pre-tax的也就是说即使你只存Roth 401K公司给你match的钱还是pre-tax公司match的这一部分401K就是employer contribution pre-tax401K</li>
<li>如果你选择了投入pre-tax 401K你通常会设定一个比例每次发的税前工资会按照你这个比例划一部分税前工资到你的pre-tax 401K账户中称作employee contribution pre-tax401K</li>
<li>如果你选择了投入roth 401K你也会设定一个比例你的税后工资会按照这个比例把钱存进roth 401K中</li>
<li>如果你的公司提供after-tax contribution那么你也可以用你的税后工资的某一个比例投入after-tax contribution中</li>
</ul>
</li>
</ul>
<p>401K的这三部分你可以选择投入其中的任意一个/两个/全部，或者一个都不投入。选择的依据完全是按照你个人的理财计划和对未来的预期判断，比如身份问题，是否回国，是否长寿等等。<br>
<strong>一些投入401K的小建议：</strong></p>
<ol>
<li>pre-tax至少要放满公司match的钱。比如，公司match你的投入pre tax的前5000，那你就至少要投5000。有的公司说要match你投入的全部pre-tax的50%，那你还等什么，妥妥pre-tax 401K拉满就行了。</li>
<li>如果你放满了pre-tax 401K，又想存入Roth 401K，那么请用mega backdoor conversion
<ul>
<li>首先你放满了pre-tax 401K，那么由于总和限制，你不能继续放Roth 401K了。</li>
<li>那么你可以继续投放after-tax contribution，然后用mega backdoor转换成Roth 401K。这么做是合法的。</li>
<li>为什么叫”mega backdoor“？因为比起“backdoor”，这个能”后门“更多的钱。“backdoor”实际上是在IRA上操作，接下来会涉及到</li>
</ul>
</li>
</ol>
<h2 id="个人退休金计划-（IRA）">个人退休金计划 （IRA）</h2>
<p>IRA的全称是individual retirement account。</p>
<h3 id="投入IRA的一个最主要的限制就是你是否有earned-income">投入IRA的一个最主要的限制就是你是否有earned income.</h3>
<ul>
<li>earned income：主动收入，但不一定是全职工作，可以打短期工，兼职等。
<ul>
<li>如果夫妻双方，有一个上班，一个不上班。那么上班的可以为不上班的配偶投放配偶的IRA。理论上可以有两个IRA，每人一个，每个人都可以达到IRA投放的年上限。</li>
</ul>
</li>
<li>unearned income：包括投资收入（股息，房租收入，定期存款利息等等）
<ul>
<li>只有unearned income就不能够投入IRA。</li>
</ul>
</li>
</ul>
<h3 id="IRA每年都有一个最大的上限">IRA每年都有一个最大的上限</h3>
<ul>
<li>意味着traditional IRA与Roth IRA的和不能超过这个上限。</li>
<li>例如2019年最多能存$6000。你也可以有多个traditional/Roth IRA账户，但所有账户的钱必须小于等于$6000。</li>
</ul>
<h3 id="IRA总共分两种">IRA总共分两种</h3>
<ul>
<li>
<p><strong>traditional IRA</strong></p>
<ul>
<li>功能:
<ul>
<li>可以调整当年应税收入(AGI), 但其调整能力随着税前收入的增加而减小，直至不能调整。</li>
<li>投资是无赋税增长(grow tax free)</li>
</ul>
</li>
<li>限制：
<ul>
<li>要等到59.5岁之后才能取出。取出的钱当作税前收入，所以要交收入税。</li>
<li>70.5岁之后必须取出。至少要取出一部分钱，这部分钱通过一个方式计算出来。至少取出来的这部分钱交RMD(required minimum distribution)。</li>
<li>如果不取出来，罚金是50%</li>
<li>可以在59.5岁之前取出来，不但要交收入税，还要交10%的罚金。</li>
</ul>
</li>
<li>图解：
<ul>
<li>图2展示了traditional IRA的你需要知道的特点和限制</li>
<li>横坐标轴代表这你的年应税收入，根据你收入的不同，可以分为三个区间，请对照图2来了解每个区间投放IRA可以抵税的程度。</li>
<li>请阅读说明部分了解$a和$b在不同报税状态下的不同<br>
<img src="traditional_ira.png" alt="traditional_ira" /></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Roth IRA</strong></p>
<ul>
<li>功能：
<ul>
<li>投资收益无赋税增长(grow tax free)</li>
<li>取出时完全不收税：可以不必关心退休时的收入税率。</li>
<li>取出不需要等到59.5岁, 且没有RMD</li>
<li>投入本金可以随时取出，不交税，不交罚款</li>
<li>本金存够五年之后，连本带利可以一起取出，不交税，不交罚款。</li>
<li>由于投入本金可以随时取出，所以Roth IRA可以当作紧急备用金使用。</li>
</ul>
</li>
<li>限制：
<ul>
<li>投放Roth IRA有收入限制：收入高过一定程度就不能投入。</li>
<li>不能调整应税收入，所存部分必须全部为税后收入。</li>
</ul>
</li>
<li>图解：
<ul>
<li>图3展示了Roth IRA你需要知道的亮点和限制</li>
<li>横坐标轴代表这你的年应税收入，根据你收入的不同，可以分为三个区间，请对照图3来了解每个区间投放IRA可以抵税的程度。</li>
<li>请阅读说明部分了解$c和$d在不同报税状态下的不同。<br>
<img src="roth_ira.png" alt="roth_ira" /></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Rollover IRA</strong><br>
相当于一个traditional IRA. 如果美国民众想要另开设一个新的IRA，并自之前的IRA内取出部分金额滚存到这个新的IRA，例如自traditional IRA内的取出金额，转到新开的Roth IRA，或者因转换工作，想要将先前雇主赞助的401K退休账户的金额，滚存到新开的IRA。此时要特别注意，如果在60天内没有完成滚存的动作，国税局就会将这笔金额当成是当年的收入，粗心大意的美国民众，不仅失去滚存的机会，还要多付所得税了。</p>
</li>
<li>
<p><strong>backdoor Roth IRA</strong><br>
    - 并不是一种“官方的Roth IRA”类型，它是一个工具，可以把traditional IRA 或者 traditional 401K转换成Roth IRA的一种工具<br>
    - 没有存入上限，存多少钱都行。</p>
</li>
</ul>
<h2 id="401K与IRA的转换-rollover">401K与IRA的转换 (rollover)</h2>
<ul>
<li>图4示例了401K转换成IRA的方法，这里就涉及到了大家经常听到的两个backdoor工具</li>
<li>pre-tax/traditional 401K -&gt; traditional IRA: 直接转就完事了，没有税务影响</li>
<li>pre-tax/traditional 401K -&gt; roth IRA: 先转到traditional IRA上，然后通过backdoor roth IRA工具转移到Roth IRA。</li>
<li>注意，从traditional IRA到Roth IRA的转移会有pro-rata rules。意思就是你转移的部分算作税前收入，要缴收入税。如果你traditional IRA有好几十万刀，那么一次转移就是增加了税前收入。一个避免方式就是，你可以每年转一些，或者挑个你没有收入的年份转一些。核心的思想就是少交税。</li>
<li>roth 401k -&gt; roth IRA: 直接转就完事了，没有税务影响</li>
<li>traiditional IRA convert to Roth IRA: backdoor conversion
<ul>
<li>the deadline of vonversion is 12/31 of each year</li>
<li>the IRA contribution deadline is 4/15 of next tax year</li>
<li>note that “conversion” and “contribution” are different</li>
<li>basically for people who want to do the conversion, they have to do it in the same year. If it’s now 2021, and you opened and funded a 2020 traditional IRA, then did a conversion, it will be counted as a 2021 traditional conversion. So you missed the 2020 contribution forever.</li>
<li>ref: <a href="https://www.fidelity.com/learning-center/personal-finance/retirement/answers-to-roth-conversion-questions#:~:text=A%20conversion%20must%20be%20completed,is%20always%20a%20good%20idea.">Roth Conversion Q&amp;A - Fidelity</a>.</li>
</ul>
</li>
</ul>
<p><strong>投资建议：</strong></p>
<ol>
<li>401K match放满</li>
<li>HSA放满</li>
<li>traditional IRA放满然后转到Roth IRA中</li>
<li>401K max out 然后convert到Roth IRA (需要打电话问公司，有些公司只有离职时才能帮你roll over)</li>
<li>after-tax401K放满然后convert到Roth IRA（如果公司支持的话）<br>
401K的这三部分你可以选择投入其中的任意一个/两个/全部或者一个都不投入选择的依据完全是按照你个人的理财计划和对未来的预期判断比如身份问题是否回国是否长寿等等</li>
</ol>
<h2 id="HSA-plan">HSA plan</h2>
<p>HSA(Health Saving Accout)，健康储蓄账户，首先，这是一个储蓄账户。其次，这是一个医疗相关的储蓄账户。只有当你的医疗保险属于 HDHP (High Deductible Health Insurance Plan),  你才能办一个 HSA 账户。个人可以往 HSA 账户存钱，享受三重免税待遇，该账户的钱可以用于医疗相关的花费。HDHP + HSA 是美国最近几年开始非常流行的一种新的医疗保险形式。<br>
HSA里的钱只能用于合乎要求的健康医疗支出。预先存进HSA的钱是免税的，任何时候你都可以用这些钱来支付自付额（Deductibles）、共付额（Copayments）、共同保险（Coinsurance）等医保不覆盖的费用，但通常不能用于支付保费（Premiums）。<br>
需要一直是High Deductible的医疗保险，高自付的医疗保险每个月的保费低，但是自付额高，这适合年轻人。因为年轻人身体比较健康，看病少。如果你是年龄大，需要常常看医生，各种慢性病，那么还是那种保费高的其他类型保险比较合适。<br>
HSA存的钱也不用交税，而且一般公司也会contribute一部分钱到HSA作为福利，公司contribute的钱从几百到上千不等。存在HSA里面的钱还可以买各种投资产品，所以这里面的钱也不会过期！投资增长后的earning在用的时候也不用交税只要用的地方都是付各种医疗费用就可以。65岁之后开始从HSA账户中提取任何金钱(不一定用于医疗）而不会受到处罚。<br>
参考文献：</p>
<ul>
<li><a href="https://docs.google.com/document/d/1dQZaBBpnwG4p9fzpK8ijYlNX7nfgKNYr2SCSxby5lq8/edit">非常详细的401K和IRA说明</a></li>
<li><a href="https://www.youtube.com/watch?v=1Y4SOlgyqkc">Youtube上很好的一系列讲解</a></li>
<li><a href="https://www.dealmoon.com/guide/934445">好的分析贴</a></li>
<li><a href="https://inside.amazon.com/en/libraries/docs/public/Roth_In_Plan_Conversion_FAQs_2020.pdf">Amazon inside instructions for IRA</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI3NTU0Mzc2Nw==&amp;mid=2247505919&amp;idx=1&amp;sn=c901b6671112dc2b64a9cce9f4200be0&amp;chksm=eb01b447dc763d5121b4b61fbffa578034b9376d2680e43037678d60f8230f14bc31ef21c7ca&amp;mpshare=1&amp;scene=1&amp;srcid=0107aszNromXMRR5gzMnS5RO&amp;sharer_sharetime=1612741188364&amp;sharer_shareid=175c4433f0976edd40ec0348d663a31b&amp;exportkey=AUBxa%2BgRCqVOrvr5QqTufpc%3D&amp;pass_ticket=yd0aHkeI%2FSx7NmycGKfDfg98qwkbf1BofcpFIoJLKSx0qnOZtbvfDdT9NEIodjCn&amp;wx_header=0#rd">401(k), Roth 401(k), Traditional IRA, Roth IRA, HSA：税收优惠投资帐户入门篇</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI3NTU0Mzc2Nw==&amp;mid=2247506655&amp;idx=1&amp;sn=f34daef41e793e200998f7c2eea87240&amp;chksm=eb01b967dc763071a0a2c99b8412285135948e145533e04ab5656b304bcc3011cc1fdadb4878&amp;mpshare=1&amp;scene=1&amp;srcid=0126Wf42YfYuAIND8NAKSjpq&amp;sharer_sharetime=1612740983670&amp;sharer_shareid=175c4433f0976edd40ec0348d663a31b&amp;exportkey=AU0LeemzMNLLJJbvMKNs8wc%3D&amp;pass_ticket=yd0aHkeI%2FSx7NmycGKfDfg98qwkbf1BofcpFIoJLKSx0qnOZtbvfDdT9NEIodjCn&amp;wx_header=0#rd">Rollover/conversion 以及 backdoor Roth 详解</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI3NTU0Mzc2Nw==&amp;mid=2247505884&amp;idx=1&amp;sn=734ff4e2d196371798d1680c52d01352&amp;chksm=eb01b464dc763d72562a01027640ec7e630a3fad568ec76b46b518c2fcea9cb556294b294faf&amp;mpshare=1&amp;scene=1&amp;srcid=0208JQvUTvVorjluqeGdzGlN&amp;sharer_sharetime=1612741432403&amp;sharer_shareid=175c4433f0976edd40ec0348d663a31b&amp;exportkey=AZugtItbusAuFtKOTwieaPk%3D&amp;pass_ticket=yd0aHkeI%2FSx7NmycGKfDfg98qwkbf1BofcpFIoJLKSx0qnOZtbvfDdT9NEIodjCn&amp;wx_header=0#rd">Roth IRA：税后收入免税投资账户介绍</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/80739768">HSA医疗储蓄账户使用大法</a></li>
<li><a href="https://mp.weixin.qq.com/s/Wbc4a194F9SC5g3mO4lO8w">退休金计划详细讲解</a></li>
</ul>
]]></content>
      <categories>
        <category>finance</category>
      </categories>
      <tags>
        <tag>401K</tag>
        <tag>HSA</tag>
        <tag>IRA</tag>
      </tags>
  </entry>
  <entry>
    <title>Java开发者必备知识</title>
    <url>/blog/2020/01/16/Java%E5%BC%80%E5%8F%91%E8%80%85%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>在此列出一些java software engineer 需要掌握的一些知识点：</p>
<span id="more"></span>
<ol>
<li>Database: Redis, MongoDB, Neo4J</li>
<li>Big data: Spark, Kafka、RabbitMQ、RocketMQ</li>
<li>Dependency Management: Ant, Maven, Gradle</li>
<li>Design Pattern: MVC</li>
<li>Dependency Injection: Spring, Guice, Dagger</li>
<li>Container: Docker, Kubernetes</li>
</ol>
<h2 id="好用的packge">好用的packge</h2>
<h3 id="Guava">Guava</h3>
<h3 id="librec">librec</h3>
<p>mellet<br>
weka<br>
lemur<br>
gephi</p>
<p>learning to rank<br>
The default property files are in the jar package. All property files are under the folder rec.  You can’t change the files but you can change the detailed properties in the Java code</p>
<h2 id="刷题">刷题</h2>
<ol>
<li>singleton syncryize and voletile 的东西 线程部分的</li>
</ol>
<h2 id="部署">部署</h2>
<p>Maven tips</p>
<p>build a new maven project:<br>
mvn archetype:generate -DgroupId=com.mycompany.helloworld -DartifactId=helloworld -Dpackage=com.mycompany.helloworld -Dversion=1.0-SNAPSHOT</p>
<p>cd helloworld<br>
mvn package</p>
<p>java -cp target/helloworld-1.0-SNAPSHOT.jar com.mycompany.helloworl</p>
<p>help to get more information<br>
mvn help:effective-pom</p>
<p>clean the target folder<br>
mvn clean</p>
<p>mvn compile<br>
mvn test<br>
mvn install</p>
<h2 id="Elipse-change-shortcut">Elipse change shortcut</h2>
<ol>
<li>preference -&gt; general -&gt;keys to change the shortcut.</li>
<li>open declaration (函数定位到源文件) command + 1 牢记！！</li>
</ol>
<h2 id="java-tips">java tips</h2>
<ol>
<li>enumeration:<br>
public enum SimilarityEnum {<br>
BM25, VSM, LMD, LMJ;<br>
}</li>
</ol>
<p>Eclipse中设置JVM内存<br>
<a href="http://blog.csdn.net/wgw335363240/article/details/6397803">http://blog.csdn.net/wgw335363240/article/details/6397803</a></p>
<h2 id="pack-an-eclipse-project-to-jar-file">pack an eclipse project to jar file</h2>
<p><a href="https://woshigaozheng.blogspot.com/2015/11/pack-eclipse-project-to-jar-file.html">https://woshigaozheng.blogspot.com/2015/11/pack-eclipse-project-to-jar-file.html</a><br>
<a href="https://www.cnblogs.com/youxin/archive/2012/06/03/2532914.html">https://www.cnblogs.com/youxin/archive/2012/06/03/2532914.html</a><br>
一.工程没有引用外部jar包时(J2SE)<br>
选中工程----&gt;右键，Export…—&gt;Java—&gt;选择JAR file—&gt;next–&gt;选择jar file的路径及名称–&gt;next–&gt;next— 选择Main class—&gt;finish.</p>
<p>二.工程有引用外部jar包时(J2SE)<br>
第一种方案<br>
当工程引用了其他的外部jar时，由于eclipse不支持同时导出外部jar包的功能，所以比较麻烦一点；具体步骤如下：<br>
1.生成manifest file:<br>
选中工程----&gt;右键，Export…—&gt;Java—&gt;选择JAR file—&gt;next–&gt;选择jar file的路径及名称–&gt;next–&gt;next— 选择Main class—&gt;finish。此时来到了要选择Main class的窗口，但这里先不选择Main class，选择最上方的Generate the manifest file（生成清单文件）, 勾上Save the manifest in the workspace（将清单保存在工作空间中）,在Manifest file（清单文件）：中输入file的名称，如/testProject/main,（其中testProject为工程名,main为manifest file的名称）点击finish。<br>
生成的jar文件一运行就会产生错误：couldn’t find main class<br>
2.回到工程，打开刚刚生成的main，在这里要输入如下信息：<br>
Manifest-Version: 1.0<br>
Main-Class: com.pacong.convert.auto.propertes.ConvertAutoProperties<br>
Class-Path: jxl.jar<br>
其中，Manifest-Version: 1.0为刚刚自动生成的manifest版本号；<br>
Main-Class: com.pacong.convert.auto.propertes.ConvertAutoProperties为Main class所在类；<br>
Class-Path: jxl.jar为外部jar包名称，这里是告诉导出的jar包，所要用到的外部的jar包的路径及名称。<br>
上面都做完了就可以导出带外部jar包的jar包了<br>
3.选中工程—&gt;右键，Export—&gt;Java—&gt;JAR file—&gt;选择jar file的路径及名称—&gt;next—&gt;next—&gt;next，这时又来到了选择main class的窗口，但这里也不选择main class，选择Use existing manifest from workspace，在Manifest file:里选择刚刚生成的main,如：/testProject/main，点击finish，到此就大功告成啦；假设生成的jar包的名称为test.jar，那么Class-Path中引入的jxl.jar要和test.jar位于同一个目录下。</p>
<p>不要选main.mf和manifest文件，在后面的选择existing manifest文件，变写manifest时：<br>
Manifest-Version: 1.0<br>
Main-Class:com.test.GameFrame  ； class：后面一定要有且只有1个空格<br>
Class-Path: nimrodlf-1.2.jar liquidlnf.jar        ;path 后面一定要有且只有1个空格<br>
另外，一定要注意Main-Class,Class-Path等后面会有一个直接的空格，不然会提示格式错误<br>
最后必须有换行，不能有空格. 这个也是要注意的. 否则依然提示没有mainclass<br>
jar creation failed<br>
detail：invalid header field<br>
用export runnable jar file时，不需要 么Class-Path中引入的jxl.jar要和test.jar位于同一个目录下。比较简单。<br>
4.注意点：<br>
如果想在命令行中运行刚刚生成的jar，命令如下：<br>
C:\Documents and Settings\Administrator\桌面&gt;java -jar test.jar<br>
如果在jar中有一些System.out.prinln语句，运行后想看看打印出的内容，可以用一下命令：<br>
C:\Documents and Settings\Administrator\桌面&gt;java -jar test.jar &gt;log.txt<br>
输出信息会被打印到log.txt中，当然log.txt自动生成，并位于和test.jar一个目录中。<br>
这里也可以新建一个start.bat文件，创建后；右键—编辑，输入:java -jar test.jar &gt;log.txt；以后直接双击start.bat即可运行test.jar啦。<br>
E盘，则你需要导入得包也要放在这个目录里。<br>
第二种方案<br>
将第三方包直接拷贝到jdk得安装目录中的jre/lib/ext/中，这时候我们需要重启一下Eclipse，这样才能将刚才的那个包加载进自动生成的系统库中，这时候按照上面的做法打包出来的jar包</p>
<p>第三种方案.用Fat jar插件来打包有引用外部jar包的项目（J2SE)<br>
1 如果你在程序开发的时候用到了第三方提供的API或者其它附属资源，在你导出生成jar文件时你必须将第三方的文件一并导出，不然你的程序运行将达不到你想要的结果.<br>
你可以利用Fat jar插件生成jar,Fat jar 的下载地址：<a href="http://sourceforge.net/projects/fjep/">http://sourceforge.net/projects/fjep/</a> 下载的文件是net.sf.fjep.fatjar_0.0.31.zip，解压缩后你会看到plugins文件夹中的net.sf.fjep.fatjar_0.0.31.jar文件(简称Fat jar).<br>
插件安装：把Fat jar文件拷贝到你的eclipse目录下的plugins中…重新启动你的eclipse平台，然后查看Window—preferences, 弹出的窗口中有Fat jar preferences这一项则说明你已经安装成功了,没有这一项则未安装成功,需要多做如下几步操作：到你的eclipse目录下的 configuration—org.eclipse.update，并删除platform.xml文件，然后重新启动eclipse.查看 Window—preferences,你会发现Fat jar preferences这一项.恭喜你安装成功了2.右击你的项目，选项列表中有Build Fat jar这一项,选择它,点击Browser(Main-Class选择你的主类)—next— finish(勾选你需要一起打包的资源,默认为全部勾选).瞧,jar文件就生成在你的工程项目中了.运行它,一切顺利.<br>
2.用Fat jar打包：右击你的项目，选项列表中有Build Fat jar这一项,选择它,弹出的窗口你会觉得特别亲切,一目了然使用很方便,点击Browser(Main-Class选择你的主类)—next— finish(勾选你需要一起打包的资源,默认为全部勾选).瞧,jar文件就生成在你的工程项目中了.运行它,一切顺利.<br>
我的eclipse，把插件复制到plugin下，删除了Platform.xml文件，且启动用eclipse.exe -clean 还是不行，插件安装不了，不知道怎么回事。</p>
<p>通过eclipse的Export 导出项，导出jar包时，有几点需要注意的事项。</p>
<p>假如我们导出的jar包名称为 demo.jar，右键解压demo.jar，META-INF 目录下面有 MANIFEST.MF文件，打开看到<br>
[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>
Manifest-Version: 1.0<br>
Main-Class: com.zhangqi.you.main.JdbcTest</p>
<p>1  Main-Class事项：<br>
main-class，顾名思义，主函数类，即demo.jar 默认运行时，执行的主方法类。<br>
在eclipse 导出jar的过程中，可以指定main-class属性，也可以不指定main-class，根据实际情况而定。</p>
<pre><code>如果导出的jar包中就只包含了一个main方法，其他的class类都是为这个类服务的，参与计算的，或引用的，那么就可以在导出时，直接指定main-class。
如果导出的jar包中包含多个main方法，在运行时，需要根据情况而定执行哪一个主函数类，那么导出的过程中就不要指定main-class属性。在运行的时候，指定需要指定的main方法类即可。
</code></pre>
<p>例如 java -jar demo.jar com.test.Demo1  运行 Demo1 类<br>
java -jar demo.jar com.test.Demo2  运行 Demo2 类</p>
<p>2  Class-Path事项：<br>
class-path，顾名思义，classpath，引用类路径。<br>
如果导出的jar包中引用了外部的jar包，那么直接运行java -jar demo.jar时，会报classnotfound异常的，这时候，需要为导出jar指定classpath<br>
打开MANIFEST.MF文件，在下面添加上 Class-Path: mysql-connector-java-5.0.8-bin.jar 便为demo.jar添加了mysql-connector-java-5.0.8-bin.jar的引用<br>
[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>
Manifest-Version: 1.0<br>
Main-Class: com.zhangqi.you.main.JdbcTest<br>
Class-Path: mysql-connector-java-5.0.8-bin.jar</p>
<pre><code> 同时将mysql-connector-java-5.0.8-bin.jar  驱动jar包放到跟demo.jar同目录下即可引用到。
 如果有多个jar包引用的话，每个jar包间空格隔开即可。
</code></pre>
<p>参考文献：</p>
<ul>
<li><a href="https://www.cnblogs.com/peida/p/Guava.html">Guava学习笔记目录</a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
</ul>
]]></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>programming language</tag>
      </tags>
  </entry>
  <entry>
    <title>Jekyll 搭建个人网站 - al-folio模板</title>
    <url>/blog/2022/08/27/Jekyll-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99-al-folio%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>Github Pages al-folio 其<a href="https://github.com/alshedivat/al-folio">源代码</a>和生成的<a href="https://maruan.alshedivat.com/">网页效果</a>比较适用于偏学术风格的个人网站。</p>
<span id="more"></span>
<h2 id="安装Ruby-和-Bundler">安装Ruby 和 Bundler</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install ruby // ruby其实应该默认已经安装在Mac系统上了，以防万一可以再用brew 安装下</span><br><span class="line">gem install bundler // gem 是ruby的打包系统</span><br><span class="line">brew install rbenv ruby-build //更好的管理ruby gems</span><br></pre></td></tr></table></figure>
<p>第一次安装Ruby之后，需要把以下加入路径中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &#x27;export PATH=&quot;/usr/local/opt/ruby/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>
<h2 id="页面内容更改">页面内容更改</h2>
<h3 id="banner-顺序">banner 顺序</h3>
<p>在每个pages folder里面的md 文档，可以通过nav_order 来更改顺序, blog页面除外。</p>
<h3 id="about-md"><a href="http://about.md">about.md</a></h3>
<ul>
<li>Modify the major content in this page.</li>
<li>The news is in under news folder.</li>
<li>You can modify Social integration section in config.yml, which allows to provide you a list of social media icons.</li>
<li>contact_note “Free feel to reach out to me via email.” in the bottom can be modified in config.yml as well.</li>
<li>profile image should be stored at <code>assets/img</code> folder.</li>
</ul>
<h3 id="blog-md"><a href="http://blog.md">blog.md</a></h3>
<p>blog的页面默认是在第二栏的，可以在config.yml里面进行修改或者删除。因为本人的blog页面是托管在另外一个网站，并且想把blog页面放在最后，所以笔者新建了一个blog.md文件，然后把nav_order的值放在最后。</p>
<h3 id="publication-md"><a href="http://publication.md">publication.md</a></h3>
<ul>
<li>config.yml 文件中定义好对应的papers.bib。这样可以自动读取bib文档生成文章信息。具体一些参数（比如filtered_bibtex_keywords）也可以在这里改。</li>
<li>在pages/publications.md中写好对应的内容。比如years这种变量。</li>
<li>/bibliography/papers.bib里面填写paper的bib信息.</li>
<li>如果想改publications里面的button的话，可以首先在config.yml里filtered_bibtex_keywords中填上对应名称，i.e. <code>video</code>，然后再layouts/bib.html里面参考其他button添加对应代码，比如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%- if entry.video %&#125;</span><br><span class="line">&lt;a href=&quot;&#123;&#123; entry.video &#125;&#125;&quot; class=&quot;btn btn-sm z-depth-0&quot; role=&quot;button&quot;&gt;Video&lt;/a&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<p>button在此文件中的顺序将会影响其在publication页面中的顺序。</p>
<h3 id="cv-md"><a href="http://cv.md">cv.md</a></h3>
<p>cv的内容主要存放在data/cv.yml文件中。可以直接在里面进行修改。</p>
<h2 id="Git-commit">Git commit</h2>
<p>如果用<code>git clone https://github.com/RoyZhengGao/RoyZhengGao.github.io.git</code> 的方式来下载项目的话，最后git push的时候需要用户名和密码。用户名为<code>RoyZhengGao</code>,而密码是之前设置的一个personal access token。<a href="https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories">参考链接</a></p>
<h2 id="Deployment">Deployment</h2>
<p>自动deployment（目前不清楚怎么弄）:</p>
<ol>
<li>Click on <code>Actions</code> tab and <code>Enable GitHub Actions</code>; do not worry about creating any workflows as everything has already been set for you.</li>
<li>Make any other changes to your webpage, commit, and push. This will automatically trigger the Deploy action.</li>
<li>Wait for a few minutes and let the action complete. You can see the progress in the Actions tab. If completed successfully, in addition to the master branch, your repository should now have a newly built gh-pages branch.</li>
<li>Finally, in the <code>Settings</code> of your repository, in the Pages section, set the branch to <code>gh-pages</code> (NOT to <code>master</code>). For more details, see <a href="https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site#choosing-a-publishing-source">Configuring a publishing source for your GitHub Pages site</a>.</li>
</ol>
<p>手动deployment，在master branch运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./bin/deploy</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2>
<ul>
<li><a href="https://github.com/alshedivat/al-folio">al-folio Github Repository</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>jekyll</tag>
        <tag>front end</tag>
        <tag>tech tool</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex使用指南</title>
    <url>/blog/2020/03/25/Latex%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>Latex使用指南</p>
<span id="more"></span>
<h2 id="Latex-安装">Latex 安装</h2>
<p>在本地电脑上面安装Latex非常方便。因为本人用的是苹果电脑，推荐采用MacTeX + TeXstudio 的组合。</p>
<ol>
<li>首先，需要安装<a href="https://tug.org/mactex/mactex-download.html">MacTex</a>。它是Mac系统上应用最好的Latex编译软件，提供了强大的功能。唯一的缺点就是容量较大，需要2-4个G的安装空间。网上有人说可以下载BasicTeX也可以，但是本人感觉用起来经常报错，所以最终还是选择稳妥的MacTex.下载安装完之后，会在Application的文件夹下面产生一个Tex的文件夹。里面有一些软件可以进行页面化的操作，包括TexShop和LaTeXiT.</li>
<li>下载<a href="https://www.texstudio.org/">TeXstudio</a>。它是一个非常好用的Latex GUI，提供非常方便的页面进行操作。</li>
</ol>
<p>下载安装完这两个软件之后，就可以畅通无阻的在本地使用Latex了！</p>
<p>如何用texstudio:</p>
<ol>
<li>直接打开主文件，会自动识别所有相关的文件的。</li>
<li>overleaf上面是bib 文件，本地的是bbl文件，overleaf 的生成bbl 文件需要点击log 按钮，拉到最下面，会有一个下载bbl 文件的地方。</li>
<li>citation undefined warning 解决方法： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">latex</span><br><span class="line">bibtex</span><br><span class="line">latex</span><br><span class="line">latex</span><br></pre></td></tr></table></figure>
</li>
<li>向左移动图片 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\advance\leftskip-1cm</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="font格式问题">font格式问题</h2>
<p>PDF中的图片有时候会出现type 3 font的问题，然而在论文提交的过程中，由于一些平台可能不能正确加载type 3 font的文字，所以我们需要更改成type 1 font.</p>
<h3 id="检查type-3-font">检查type 3 font</h3>
<ul>
<li>检查方式是用acrobat reader打开pdf，然后看<code>file-&gt;property</code>里面的fonts，有没有type 3。</li>
<li>想要检查是否 PDF 中包含 “type 3 fonts” 可以使用：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pdffonts MY_PDF.pdf</span><br></pre></td></tr></table></figure>
MacOS 上可以通过安装 poppler 来安装 pdffonts 。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install poppler</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="PDF文件">PDF文件</h3>
<p>在latex中，如果我们导入draw.io画的PDF格式的流程图，如果涉及到图内有文字的话，有时会出现type 3 font，但有时候不会。所以平时的时候还需要注意点。如果直接在PDF中修改type 3 font的话，感觉目前没有什么好的办法。一个据说可行的方法是，先把PDF转成eps:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pdftops -eps -r 400 fig.pdf fig.eps</span><br></pre></td></tr></table></figure>
<p>然后利用eps2eps命令将一个eps图片中字体全部曲线化，转换后的eps再转成pdf时，不带任何字体信息。但是本人这里是出现图片会被缩放到eps一角的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eps2eps your.eps output.eps</span><br></pre></td></tr></table></figure>
<p>最后再转成PDF:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">epstopdf fig.eps fig.pdf</span><br></pre></td></tr></table></figure>
<p>###Python画的图片<br>
在Python画图存成PDF的过程中，同样存在type 3 font的问题。在程序中添加如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matplotlib</span><br><span class="line">matplotlib.rcParams[&#x27;pdf.fonttype&#x27;] = 42</span><br><span class="line">matplotlib.rcParams[&#x27;ps.fonttype&#x27;] = 42</span><br></pre></td></tr></table></figure>
<p>这使得matplotlib使用Type 42字体来生成PostScript 和PDF 文件.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">matplotlib.rcParams[&#x27;text.usetex&#x27;] = True</span><br></pre></td></tr></table></figure>
<p>也可以这样强制生成Type 1 fonts, 不过可能会改变图形。</p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>tech tool</tag>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac上Terminal的快捷键</title>
    <url>/blog/2020/03/23/Mac%E4%B8%8ATerminal%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>在使用Mac系统的terminal时，有很多快捷键能够帮助我们减轻很多工作量，比如快速定位到想要的位置或者查找历史记录等等。苹果公司本身提供了详细的快捷键list，此处作者只是列举出自己平时常用的一些快捷键，方便自己快速查找。</p>
<span id="more"></span>
<h2 id="使用“终端”窗口和标签页">使用“终端”窗口和标签页</h2>
<ul>
<li>新建窗口：<code>Command-N</code></li>
<li>关闭窗口: <code>Shift-Command-W</code></li>
<li>新建标签页: <code>Command-T</code></li>
<li>关闭标签页: <code>Command-W</code></li>
<li>放大字体: <code>Command-加号键 (+)</code></li>
<li>缩小字体: <code>Command-减号键 (–)</code></li>
<li>将窗口拆分为两个面板: <code>Command-D</code></li>
<li>关闭拆分面板: <code>Shift-Command-D</code></li>
<li>上一页: <code>Command-Page Up</code>(<code>fn+control+up</code>)</li>
<li>下一页: <code>Command-Page Down</code>(<code>fn+control+down</code>)</li>
</ul>
<h2 id="编辑命令行">编辑命令行</h2>
<ul>
<li>重新定位插入点: 在按住 Option 键的同时将指针移到新的插入点。</li>
<li>将插入点移到行的开头: <code>Control-A</code></li>
<li>将插入点移到行的结尾: <code>Control-E</code></li>
<li>将插入点前移一个字符: 右箭头键</li>
<li>将插入点后移一个字符: 左箭头键</li>
<li>将插入点前移一个字词: Option-右箭头键</li>
<li>将插入点后移一个字词: Option-左箭头键</li>
<li>删除到行的开头: <code>Control-U</code></li>
<li>删除到行的结尾: <code>Control-K</code></li>
<li>向前删除到字词的结尾: <code>Option-D</code>（选中将 Option 键用作 Meta 键后可用）</li>
<li>向后删除到字词的开头: <code>Control-W</code>或者<code>Option-Delete</code></li>
<li>删除一个字符: <code>Delete</code></li>
<li>向前删除一个字符: <code>Fn-Delete</code></li>
</ul>
<h2 id="Linux下光标移动快捷键">Linux下光标移动快捷键</h2>
<p>Linux下光标移动的命令在Mac系统下仍然可用，所以顺便总结如些：</p>
<ul>
<li>
<p><code>Ctrl+a</code>: 跳到本行的行首，</p>
</li>
<li>
<p><code>Ctrl+e</code>: 则跳到页尾。</p>
</li>
<li>
<p><code>Ctrl+u</code>: 删除当前光标前面的文字</p>
</li>
<li>
<p><code>ctrl+k</code>: 删除当前光标后面的文字</p>
</li>
<li>
<p><code>Ctrl+w</code>和<code>Alt+d</code>: 对于当前的单词进行删除操作，w删除光标前面的单词的字符，d则删除后面的字符</p>
</li>
<li>
<p><code>Alt+Backsapce</code>: 删除当前光标后面的单词，</p>
</li>
<li>
<p>如果删除错误，使用<code>Ctrl+y</code>进行恢复, <code>Ctrl+L</code>进行清屏操作</p>
</li>
<li>
<p><code>Ctrl+a</code>: 光标移到行首。</p>
</li>
<li>
<p><code>Ctrl+b</code>: 光标左移一个字母</p>
</li>
<li>
<p><code>Ctrl+c</code>: 杀死当前进程。</p>
</li>
<li>
<p><code>Ctrl+d</code>: 退出当前 Shell。</p>
</li>
<li>
<p><code>Ctrl+e</code>: 光标移到行尾。</p>
</li>
<li>
<p><code>Ctrl+h</code>: 删除光标前一个字符，同 backspace 键相同。</p>
</li>
<li>
<p><code>Ctrl+k</code>: 清除光标后至行尾的内容。</p>
</li>
<li>
<p><code>Ctrl+l</code>: 清屏，相当于clear。</p>
</li>
<li>
<p><code>Ctrl+r</code>: 搜索之前打过的命令。会有一个提示，根据你输入的关键字进行搜索bash的history</p>
</li>
<li>
<p><code>Ctrl+w</code>: 移除光标前的一个单词</p>
</li>
<li>
<p><code>Ctrl+t</code>: 交换光标位置前的两个字符</p>
</li>
<li>
<p><code>Ctrl+y</code>: 粘贴或者恢复上次的删除</p>
</li>
<li>
<p><code>Ctrl+d</code>: 删除光标所在字母;注意和backspace以及ctrl+h的区别，这2个是删除光标前的字符</p>
</li>
<li>
<p><code>Ctrl+f</code>: 光标右移</p>
</li>
<li>
<p><code>Ctrl+z</code>: 把当前进程转到后台运行，使用’ fg ‘命令恢复。比如top -d1 然后ctrl+z ，到后台，然后fg,重新恢复</p>
</li>
</ul>
<p>esc组合</p>
<ul>
<li><code>esc+d</code>: 删除光标后的一个词</li>
<li><code>esc+f</code>: 往右跳一个词</li>
<li><code>esc+b</code>: 往左跳一个词</li>
<li><code>esc+t</code>: 交换光标位置前的两个单词。</li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>tech tool</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用指南</title>
    <url>/blog/2019/12/13/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>Git 是一种版本控制系统，能够统一管理代码，并且track修改记录。同时，它可以支持多个开发者协同工作在同一个project上面，每个人可以克隆一个备份到自己本地并且work on在自己的部分，最后merge 所有的代码，从而实现版本的分布式集中管理。每个本地copy 都会带有所有的历史记录，可以快速回滚到之前的版本。Github 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名Github。本文我们主要通过探索Git的使用方法，提供一些对于Git 和Github 的insight。</p>
<span id="more"></span>
<h2 id="Git基本原理">Git基本原理</h2>
<p>执行git init命令，就会创建并初始化git仓库，这个时候在该目录下会产生一个.git的隐藏文件夹，而该目录就是你的工作目录，你的一切行为都是在这个目录里，而这个.git文件夹就是你的本地仓库，当你进行了一些文件操作之后，认为可以提交了那么首先你就是提交到本地仓库也就是这个.git中，然后再推送到中心服务器。或者直接克隆一个仓库到本地作为git仓库，也是一样的。当你进入到这个.git目录中，会发现里面还有很多的子目录和文件，有的是很重要的，这里说几个：</p>
<ul>
<li>config文件，这是你项目的配置文件，里面有中心服务器的信息和分支信息</li>
<li>HEAD文件，指向当前的分支</li>
<li>index文件，是暂存区的相关信息</li>
<li>logs目录，中都是相关操作产生的日志，这个很重要，因为日志是我们操作的唯一证据，我们本地的版本控制也靠它</li>
<li>objects目录，里面存储的就是所有 的数据，也就是快照</li>
<li>refs目录，里是存储指向数据提交对象的指针。<br>
<img src="repo_folder.png" alt="repo_folder"/></li>
</ul>
<h3 id="Git的分层结构">Git的分层结构</h3>
<p>Git 有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。 已提交表示数据已经安全的保存在本地数据库中。已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。由此引入 Git 本地项目的三个工作区域的概念：Git 仓库 （repository）、工作目录 (working directory)以及暂存区域 (stage/index)。与之对应的，远程仓库在远端服务器保管同步的工作代码。</p>
<ul>
<li>工作目录就是我们执行命令git init时所在的地方，也就是我们执行一切文件操作的地方。</li>
<li>暂存区和本地仓库都是在.git目录，因为它们只是用来存数据的。</li>
<li>远程仓库在中心服务器，也就是我们做好工作之后推送到远程仓库，或者从远程仓库更新下来最新代码到我们的git仓库。</li>
</ul>
<img src="pipeline.png" alt="pipeline"/> 
git所存储的都是一系列的文件快照，然后git来跟踪这些文件快照，发现哪个文件快照有变化它就会提示你需要添加到暂存区或是提交到本地仓库来保证你的工作目录是干净的。
基本的 Git 工作流程如下：
<ol>
<li>在工作目录中修改文件。</li>
<li>暂存文件，将文件的快照放入暂存区域。</li>
<li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li>
<li>再将本地仓库的最新版本文件快照推送到远程仓库。</li>
</ol>
<h3 id="Git-的对象">Git 的对象</h3>
<p>从根本上讲，git是一套内容寻址的文件系统，它存储的也是key-value键值对，然后根据key值来查找value的，Git也是根据指针来寻址的，这些指针就存储在Git的对象中。Git一共有3种对象：commit对象，tree对象和blob对象。下面便是这3个对象：<br>
<img src="object.png" alt="object"/></p>
<p>这个blob对象对应的就是文件快照中那些发生变化的文件内容，而tree对象则记录了文件快照中各个目录和文件的结构关系，它指向了被跟踪的快照，commit对象则记录了每次提交到本地仓库的文件快照，从上图看出其中有两个指针，一个指向tree对象，一个则指向上一个commit对象。这个怎么理解呢，怎么还有上一个commit对象，在开发过程中，我们会提交很多次文件快照，那么第一次提交的内容会用一个commit来记录，这个commit没有指针指向上一个commit对象，因为没有上一个commit，它是第一个，当第二次提交时，又会有另外一个commit对象来记录，那么这次commit对象中就会有一个指针指向上一次提交后的commit对象，经过很多次提交后就会有很多的commit对象，它们组成了一个链表，当我们要恢复哪个版本的时候，只要找到这个commit对象就能恢复那个版本的文件。而我们所谓的HEAD对象其实就指向最近一个提交的commit对象，也就是最后一个commit对象。</p>
<h3 id="Git-Github-和Gitlab-的区别">Git, Github 和Gitlab 的区别</h3>
<ul>
<li>Git 是一种版本控制系统，是一个命令，是一种工具。Github，Gitlab等产品都是第三方基于git这项技术开发的</li>
<li>Github 是一个基于git实现的在线代码仓库，包含一个网站界面，向互联网开放</li>
<li>Gitlab 是一个基于git实现的在线代码仓库软件，你可以用Gitlab 自己搭建一个类似于Github 一样的系统，一般用于在企业、学校等内部网络搭建git私服。</li>
</ul>
<p>总结一下Github和Gitlab的区别：Github和Gitlab都为开发团队提供了存储、分享、发布和合作开发项目的中心化云存储的场所。GitHub和Gitlab都是基于Web的版本控制界面，服务于互联网，Github可以直接注册使用，Gitlab需要部署到服务器。Gitlab创建的项目的默认属性是Private（私人的），可以选择Public（公开的）或Internal（内部的）。Github主要是代码管理，Gitlab主要是仓库管理.可以这样理解：Github就是一个团体，这个团体里的所有人都是可见的。Gitlab是有无数个团体组成，每个团体之间是不可见的，团体内部才是可见的。所以，每个公司都是可以自由搭建Gitlab私有托管服务，搭建完成后为公司内部人员开通权限，这样公司的代码就不会公开出去；如果公司觉得自己搭建管理Git麻烦，可以购买GitHub的私有托管服务，这样也能实现代码公司内部对代码的可见和操作。当企业使用Gitlab的版本控制时，托管服务器是企业自己的。使用Github的私有托管服务时，托管服务器是GitHub的。当使用企业自己服务器时，服务器费用、电费、人工维护费、硬盘网络等等费用就需要企业自理。若使用GitHub的私有服务器时，就方便许多。</p>
<h2 id="Git-的安装与配置">Git 的安装与配置</h2>
<h3 id="安装Git">安装Git</h3>
<p>可以选择到<a href="https://git-scm.com/">官网</a>下载对应的安装软件进行安装。也可以在命令行执行安装。<br>
(1) 对于Linux系统，执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>
<p>(2) 对于Mac系统，首先安装Homebrew：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line">brew doctor</span><br></pre></td></tr></table></figure>
<p>之后执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure>
<h3 id="绑定Github">绑定Github</h3>
<p><strong>(1) 注册Github 账号</strong><br>
<strong>(2) 环境配置</strong><br>
当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置用户名</span><br><span class="line">git config --global user.name &quot;username&quot; //（ &quot;username&quot;是自己的账户名，）</span><br><span class="line"># 配置邮箱</span><br><span class="line">git config --global user.email &quot;username@email.com&quot; //(&quot;username@email.com&quot;注册账号时用的邮箱) </span><br></pre></td></tr></table></figure>
<p>再次强调，如果使用了 --global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 --global 选项的命令来配置。可用 <code>git config --global --list</code> 命令查看配置是否OK。<br>
<strong>(3) 生成SSH Key</strong><br>
在terminal 输入<code>ssh-keygen -t rsa</code>命令，表示我们指定 RSA 算法生成密钥，然后敲三次回车键，期间不需要输入密码，之后就就会生成两个文件，分别为<code>id_rsa</code>和<code>id_rsa.pub</code>，即密钥id_rsa和公钥id_rsa.pub。对于这两个文件，其都为隐藏文件，默认生成在<code>~/.ssh</code>目录。<br>
<strong>(4) 添加SSH Key</strong><br>
<a href="http://xn--Github-2l2j636v.com">登入Github.com</a> 中的个人账号。点击右上角头像，选择<code>Settings</code>。<br>
<img src="settings.png" alt="settings" width="200"/><br>
点击<code>SSH and GPG keys</code> -&gt; <code>New SSH key</code>，把公钥id_rsa.pub 的内容粘贴到Key处的位置（Titles的内容不填写也没事），然后点击Add SSH key 即可。<br>
<img src="keys.png" alt="keys"/><br>
<strong>(5) 验证绑定</strong><br>
在我们添加完SSH key之后，可以通过在 Git Bash 中输入<code>ssh -T git@github.com</code>进行测试，出现下图所示，表示绑定成功：<br>
<img src="test-bundle.png" alt="test-bundle" width="500"/></p>
<h3 id="电脑绑定多个Github账号">电脑绑定多个Github账号</h3>
<p>有些时候，我们可能有多个Github的账号，为了在同一台电脑上能向不同Github的账号push 代码，我们需要做以下设定：<br>
(1) 新生成一对密钥。打开terminal 输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>提示<code>Enter file in which to save the key (/Users/nchkdxlq/.ssh/id_rsa):</code>，如果直接按回车，会生成以<code>id_rsa</code>开头命名的密钥对，会覆盖原来在<code>.ssh</code>目录下面已有的<code>id_rsa</code>密钥。所以需要输入生成密钥的名称<code>zheng_rsa</code>，按回车之后就会在<code>.ssh</code>目录下生成<code>zheng_rsa</code>私钥和<code>zheng_rsa.pub</code>公钥。<br>
(2) 把<code>zheng_rsa.pub</code>公钥添加到github账号中，如果没有提示密钥已使用，说明密钥添加成功了。<br>
(3) 此时如果执行<code>git push</code>的话，会出现以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR: Permission to zheng/test.git denied to nchkdxlq.</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure>
<p>原因是因为每次push的时候，本地的私钥都会和服务端（Github）的公钥去匹配，如果匹配成功就可以push了；而在默认情况下，本地的私钥都会读取<code>id_rsa</code>文件，而账号中对应的公钥<code>zheng_rsa.pub</code>，所以当然会报没有权限的错误。为此需要做以下两个设置：</p>
<ol>
<li>新建config文件。<br>
在<code>~/.ssh</code>目录下新建<code>config</code>文件并添加如下内容，该文件用于设置私钥对应的服务器: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Default Account</span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line">#zheng zheng_github.com为服务器的别名</span><br><span class="line">Host zheng_github.com</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/zheng_rsa</span><br></pre></td></tr></table></figure>
第一个对应的account 是原有的account,私钥在<code>id_rsa</code>中。第二个是新加的account，私钥在<code>zheng_rsa</code> 中。</li>
<li>修改具体项目的config文件。<br>
在具体项目的<code>.git/config</code>文件中，有一行设置url的配置。<br>
默认配置： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url = git@github.com:zhenggao/test.git</span><br></pre></td></tr></table></figure>
修改后配置： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url = zheng_github.com:zhenggao/test.git</span><br></pre></td></tr></table></figure>
可以看出 Host发生改动。修改url配置还有更简单的方式，在对应的项目中执行命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote set-url origin zheng_github.com:zhenggao/test.git</span><br></pre></td></tr></table></figure>
之后可以通过以下代码验证是否绑定成功： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T zheng_github.com</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="基本操作">基本操作</h2>
<p>下图是一些在四个工作区域中的基本的操作。一套最常用的command 组合如下面代码所示：<br>
<img src="function.png" alt="function"/></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init # 初始化</span><br><span class="line">git add . # 从工作区域加入缓存区</span><br><span class="line">git add README.md #加入readme 文件</span><br><span class="line">git commit -m &quot;first commit&quot; # push 到local repository</span><br><span class="line">git remote add origin https://github.iu.edu/gao27/aaa.git # 链接上remote repository，只需要第一次使用的时候添加</span><br><span class="line">git push -u origin master # push 到remote repository</span><br></pre></td></tr></table></figure>
<p>接下来我们具体讲每个功能对应的一些Git command。</p>
<h3 id="创建仓库">创建仓库</h3>
<p>创建新文件夹，打开，然后执行下面代码以创建新的 Git 仓库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h3 id="检出仓库">检出仓库</h3>
<p>执行如下命令以创建一个本地仓库的克隆版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone /path/to/repository</span><br><span class="line">git clone https://github.com/git/git.git     // 通过 https 协议，克隆 Github 上 git 仓库的源码</span><br></pre></td></tr></table></figure>
<p>如果是远端服务器上的仓库，你的命令会是这个样子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone username@host:/path/to/repository</span><br><span class="line">git clone linfuyan@github.com/git/git.git    // 通过 ssh 协议，克隆 Github 上 git 仓库的源码</span><br></pre></td></tr></table></figure>
<h3 id="添加与提交">添加与提交</h3>
<p>你可以计划改动（把它们添加到缓存区），使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p>这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;代码提交信息&quot;</span><br></pre></td></tr></table></figure>
<p>现在，你的改动已经提交到了 HEAD(指向最后一次提交结果的指针)，但是还没到你的远端仓库。</p>
<h3 id="推送改动">推送改动</h3>
<p>你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u origin master // 第一次推送时使用，可以简化后面的推送或者拉取命令使用</span><br><span class="line">git push origin master    // 将本地 master 分支推送到 origin 远程分支</span><br><span class="line">git push origin local_branch:remote_branch // push branch to another remote branch</span><br></pre></td></tr></table></figure>
<p>其中master 是对应的repository的主brunch的名字，可以替换成其他brunch。注意： <code>git push -u origin master</code>，第一次使用时，带上 <code>-u</code>参数，在将本地的 master 分支推送到远程新的 master 分支的同时，还会把本地的 master 分支和远程的 master 分支关联起来。<br>
如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin your_remote_git_repo </span><br></pre></td></tr></table></figure>
<h3 id="替换本地改动">替换本地改动</h3>
<p>假如你做错事（自然，这是不可能的），你可以使用如下命令替换掉本地改动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响。<br>
假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure>
<h3 id="README-和-gitignore">README 和 .gitignore</h3>
<ol>
<li>
<p>README 文件是开发的时候非常重要的一个文档说明，是以Markdown 格式书写。提交到Github中默认会放到首页展示。</p>
</li>
<li>
<p>.gitignore 文件用来过滤不必要提交的文件，但是ignore的规则对那些已经被track的文件无效。因此推荐初始化git项目时就创建.gitignore文件。<br>
对于已经track且有改动的文件添加ignore规则, 如下:</p>
<ol>
<li><code>git rm -r --cached</code> 要忽略的文件 (如: <code>git rm -r --cahced build/*</code>, 如修改列表中的内容全部是不需要的, 那么你可以使用最最简单的命令搞定<code>git rm -r --cached .</code>)</li>
<li><code>git add .</code></li>
<li><code>git commit -m &quot; commet for commit .....&quot;</code></li>
<li><code>git push</code></li>
</ol>
<blockquote>
<p>通配符匹配被忽略文件或者目录时，一个星表示任意字符；两个星表示任意路径。以/开头忽略目录，表示当前。例如/mytmp表示忽略根目录下的mytmp。以**/开头，忽略所有目录。例如**/mytmp表示忽略所有层级下的mytmp目录。用!开头表示例外。例如!/child1/child2/mytmp表示单独强调“不忽略”/child1/child2/mytmp的 mytmp 目录。</p>
</blockquote>
</li>
</ol>
<h2 id="分支操作">分支操作</h2>
<p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”。在其他分支上进行开发，完成后再将它们合并到主分支上。<br>
查看分支使用 git branch：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch        // 查看本地分支信息</span><br><span class="line">git branch -v     // 查看相对详细的本地分支信息</span><br><span class="line">git branch -av     // 查看包括远程仓库在内的分支信息</span><br></pre></td></tr></table></figure>
<p>注意：在 git branch 的输出内容中，有一个分支，前面带有 * 号，这标识我们当前所在的分支。<br>
创建分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch dev // 新建一个名称为 dev 的分支</span><br></pre></td></tr></table></figure>
<p>创建一个叫做“feature_x”的分支，并切换过去：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b feature_x</span><br></pre></td></tr></table></figure>
<p>切换回主分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>
<p>再把新建的分支删掉：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d feature_x</span><br></pre></td></tr></table></figure>
<p>除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<h3 id="更新与合并">更新与合并</h3>
<p>要更新你的本地仓库至最新改动，执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
<p>以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。<br>
要合并其他分支（branch）到你的当前分支（例如 master），执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<p>两种情况下，git 都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致 冲突（conflicts）。 这时候就需要你修改这些文件来人肉合并这些 冲突（conflicts） 了。改完之后，你需要执行如下命令以将它们标记为合并成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>在合并改动之前，也可以使用如下命令查看两个branch的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff &lt;source_branch&gt; &lt;target_branch&gt;</span><br></pre></td></tr></table></figure>
<h2 id="标签操作">标签操作</h2>
<h3 id="创建标签">创建标签</h3>
<p>在软件发布时创建标签，是被推荐的。这是个旧有概念，在 SVN 中也有。可以执行如下命令以创建一个叫做 1.0.0 的标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag 1.0.0 1b2e1d63ff</span><br></pre></td></tr></table></figure>
<p>1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。你也可以用该提交 ID 的少一些的前几位，只要它是唯一的。使用如下命令获取提交 ID：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<p>或者另外一种方式创建标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -a &#x27;tagname&#x27; -m &#x27;comment&#x27; &#x27;commit_id&#x27;</span><br></pre></td></tr></table></figure>
<p>-a 参数指定标签名， -m 添加备注信息， ‘commit_id’ 指定打标签的提交。</p>
<h3 id="查看所有标签">查看所有标签</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag // 查看本地仓库中的所有标签</span><br></pre></td></tr></table></figure>
<h3 id="删除本地标签">删除本地标签</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -d tagname</span><br></pre></td></tr></table></figure>
<h2 id="Git-命令详解">Git 命令详解</h2>
<p>一些基本命令如图所示：<br>
<img src="summary.png" alt="summary"/></p>
<ul>
<li>查看仓库的状态<br>
不论我们是新建了文件，将文件加入暂存区，或者其他的修改等等，我们都可以通过：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
来随时查看仓库中文件的状态。这个应该是使用 Git 做版本控制过程中，使用最多的一个命令。</li>
<li>查看仓库中的具体修改<br>
很经常的，我们对某个文件做了修改，但过不久就忘记了。这时候就可以通过 <code>git diff</code>来查看具体的修改内容。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff    // 查看版本库中所有的改动</span><br><span class="line">git diff Readme.md        // 查看具体文件的改动</span><br></pre></td></tr></table></figure>
</li>
<li>查看提交历史记录<br>
有的时候，你会需要查看自己做过哪些提交，来回顾自己完成的部分。或者需要寻找某个具体的提交来查看当时的代码。这里需要用到：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log     // 显示所有提交的历史记录</span><br><span class="line">git log --pretty=oneline    // 单行显示提交历史记录的内容</span><br></pre></td></tr></table></figure>
在 git log 的输出内容中，可以看到每次提交的 ID，是一个 40 位的字符串。</li>
<li>版本回退<br>
有了 git log 来查看提交的历史记录，我们就可以通过 <code>git reset --hard</code> 来回退到我们需要的特定版本，然后使用当时的代码进行各种操作。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^        // 回退到上一个提交版本</span><br><span class="line">git reset --hard HEAD^^        // 回退到上上一个提交版本</span><br><span class="line">git reset --hard &#x27;commit_id&#x27;    // 会退到 commit_id 指定的提交版本</span><br></pre></td></tr></table></figure>
</li>
<li><code>git reset --hard</code> 和 <code>git reset --soft</code>的区别：soft仅撤销commit,写的代码依然保留。 hard连本地改动的源码也会撤销。</li>
<li><code>git clean</code>:可以清除repository 下面没有track的文件。经常和<code>git reset --hard</code>一起结合使用. 记住reset只影响被track过的文件, 所以需要clean来删除没有track过的文件. 结合使用这两个命令能让你的工作目录完全回到一个指定的<commit>的状态。常用命令<code>git clean -dfx</code></li>
<li>回到未来的某个提交<br>
当退回到某个提交的版本以后，再通过 <code>git log</code> 是无法显示在这之后的提交信息的。但是，通过 <code>git reflog</code> 可以获取到操作命令的历史。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git reset --hard &#x27;commit_id&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li>撤销修改<br>
撤销修改同样包括两方面的内容，由于仓库中的文件在提交之前，可能在工作区中，尚未在版本控制范围内，也可能在暂存区中。
<ol>
<li>丢弃工作区中文件的修改</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- Readme.md    // 如果 Readme.md 文件在工作区，则丢弃其修改</span><br><span class="line">git checkout -- .            // 丢弃当前目录下所有工作区中文件的修改</span><br></pre></td></tr></table></figure>
注意： <code>git checkout --</code> 中的 <code>--</code> 是必须的。<br>
2. 丢弃已经进入暂存区的修改  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD Readme.md // 将 Readme.md 恢复到 HEAD 提交版本的状态</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>提交完之后发现有漏掉的文件没有添加，或者提交信息写错了，可以用 <code>--amend</code>来重新提交：</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
</li>
<li>取消之前<code>git add .</code>的操作<br>
可以看下 <code>git status</code>, 然后  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -f ./.git/index.lock</span><br></pre></td></tr></table></figure>
</li>
<li>删除文件<br>
在文件未添加到暂存区之前，对想删除文件可以直接物理删除。或者通过 <code>git checkout -- file</code> 来丢弃。如果文件已经被提交，则需要 <code>git rm</code> 来删除：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm Readme.md // 删除已经被提交过的 Readme.md</span><br><span class="line">rm -rf .git</span><br></pre></td></tr></table></figure>
注意： <code>git rm</code> 只能删除已经提交到版本库中的文件。其他状态的文件直接用这个命令操作是出错的。<br>
同时，Linux的命令：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf .git</span><br></pre></td></tr></table></figure>
可以直接unlink 整个project 和repository。</li>
<li>删除branch:<br>
如果你还在一个分支上，那么 Git 是不允许你删除这个分支的。所以，请记得退出分支.
<ul>
<li>当一个分支被推送并合并到远程分支后，<code>git branch -d &lt;branch&gt;</code>才会本地删除该分支</li>
<li>如果一个分支还没有被推送或者合并，那么可以使用<code>git branch -D &lt;branch&gt;</code>强制删除它。</li>
<li>使用这个命令可以远程删除分支：<code>git push &lt;remote&gt; --delete &lt;branch&gt;</code></li>
</ul>
</li>
<li>删除某一commit:
<ul>
<li>首先找到commit_B提交之前的一次提交的commit_A</li>
<li>执行如下命令:<code>git rebase -i  commit_A</code></li>
<li>将commit_B这一行前面的pick改为drop，然后按照提示保存退出</li>
<li>至此已经删除了指定的commit，可以使用<code>git log</code>查看下</li>
</ul>
</li>
<li><code>git fetch</code> 和 <code>git pull</code>的区别<br>
想要向远程仓库推送前，需要先获取到远程仓库的最新内容。可以通过 <code>git fetch</code> 和 <code>git pull</code> 来获取远程仓库的内容。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin master    </span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>
<ol>
<li><code>git fetch</code> 是仅仅获取远程仓库的更新内容，并不会自动做合并。</li>
<li><code>git pull</code> 在获取远程仓库的内容后，会自动做合并，可以看成 <code>git fetch</code> 之后 <code>git merge</code>。</li>
<li>建议多使用 <code>git fetch</code>。</li>
</ol>
</li>
<li><code>git rebase</code> 变基和<code>git merge</code>的区别<br>
<code>git rebase</code> 和 <code>git merge</code> 都是用来合并，各有优缺点，所以有些团队会约定合并时只能用 <code>git merge</code> 或只能用 <code>git rebase</code>，如果约定只能用 <code>git rebase</code> 来合并，这种工作方式就被称为 ‘<code>git rebase</code> 工作流’。在用 <code>git rebase</code> 合并分支时，合并后的日志并非按各分支的提交时间排列，而是把一个分支的日志全部排列在另一个分支的日志之上，即使它们是并行开发的，在开发过程中交错提交，但看起来也好像是按先后顺序开发的一样。</li>
<li><code>git add .</code> 和<code>git add -u</code> 和 <code>git add -A</code>区别<img src="git_add.png" alt="repo_folder" width="500"/></li>
<li><code>git pull --rebase</code>：去除多余的merge commit记录。使得整体log commit记录变得更加顺畅。<code>git pull</code> = <code>git fetch</code> + <code>git merge</code><br>
<code>git pull --rebase</code> = <code>git fetch</code> + <code>git rebase</code>。</li>
<li><code>git blame [filename]</code>：溯一个指定文件的历史修改记录。[filename]就是我们想要了解的某一个具体文件的完整修改记录。</li>
<li>如果需要two factor authorization，需要personal access token的话，需要做以下两步：
<ul>
<li><code>git config --global credential.helper cache</code>避免一直输入user name和password (personal access token), 用<code>git config --global --unset credential.help</code>可以取消。</li>
<li><code>git remote set-url origin https://&lt;token&gt;@github.com/RoyZhengGao/RoyZhengGao.github.io.git</code> 把personal access token加上去</li>
</ul>
</li>
</ul>
<p>Reference:</p>
<ul>
<li><a href="https://www.jianshu.com/p/4e9451b5dc11">单台电脑关联多个Github账号</a></li>
<li><a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-Git-%E5%9F%BA%E7%A1%80">非常详细的Git讲解</a></li>
<li><a href="https://backlog.com/git-tutorial/cn/intro/intro1_1.html">Git入门讲解</a></li>
<li><a href="https://blog.csdn.net/xiaoputao0903/article/details/23912561">Git原理介绍</a></li>
<li><a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解Git命令</a></li>
<li><a href="https://www.bootcss.com/p/git-guide/">Git简易指南</a></li>
<li><a href="https://www.jianshu.com/p/bc43c7823352">Git, Github, Gitlab区别</a></li>
<li><a href="https://blog.csdn.net/qq_35246620/article/details/66973794">Github教程</a></li>
<li><a href="https://segmentfault.com/a/1190000011673663">Git常用命令手册</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git 教程</a></li>
<li><a href="https://www.jianshu.com/p/a3e6b5b2ab59">gitignore的写法说明</a></li>
<li><a href="https://www.jianshu.com/p/e5b13480479b">如何gitignore 掉那些已经track的文件</a></li>
<li><a href="https://www.cnblogs.com/kevingrace/p/5896706.html">git pull --rebase 的解释</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Medibang Paint Pro 笔记</title>
    <url>/blog/2021/12/30/Medibang-Paint-Pro-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本文记录自己学习Medibang Paint Pro画图时的一些笔记。</p>
<span id="more"></span>
<h2 id="Tips">Tips</h2>
<ul>
<li>用text tool在图上写文字时，会单独放在一层中，我们需要在那个层中复制，然后再粘贴，就会把文字工具转化成一个单独的颜色图层。这样就可以和其他的图层merge了。</li>
<li>选定部分图形，拉拽并使其<a href="https://medibangpaint.com/zh_CN/tutorial/pc/use-transform/">变形</a>的方法</li>
<li>如何出现标尺：页面上方有各种标尺可以用来对应。</li>
<li>如何使画的线变得圆润或画直线：
<ul>
<li><a href="https://medibangpaint.com/zh_CN/use/2020/11/how-to-draw-smooth-lines/">如何画出简洁的线条和线稿</a></li>
<li><a href="https://medibangpaint.com/zh_CN/use/2019/08/use-correction-to-draw-beautiful-lines/">运用校正</a></li>
</ul>
</li>
<li>改变线条颜色：画好线稿之后，开启图层的“保护透明度”功能然后再用大画笔任意涂抹即可。protect alpha 使得你只能在当前图层画好的区域进行更改。所以只能改变已有的线条颜色。</li>
<li>clipping 使得上方clipped图层的作用效果只能存在在其下方普通图层有颜色的位置上。</li>
<li>图层混合的种类：<a href="https://medibangpaint.com/zh_CN/use/2016/07/layer-blend/">链接</a></li>
<li><a href="https://medibangpaint.com/zh_CN/use/2021/08/how-to-paint-skin-three-step/">如何画皮肤</a></li>
<li><a href="https://medibangpaint.com/zh_CN/use/2021/10/how-to-draw-charming-mini-characters/">Q版人物的画法</a></li>
<li><a href="https://medibangpaint.com/zh_CN/use/2021/12/lecture-to-complete-one-picture/">完成一幅插画</a></li>
<li>如何放大缩小旋转图层中部分内容。
<ul>
<li>用select tool 选中内容</li>
<li>点击select -&gt; transform或者mesh transform</li>
<li>鼠标放在选中区域角落可以进行放大缩小旋转变形。</li>
</ul>
</li>
<li>如何移动旋转图层中的部分内容。
<ul>
<li>用select tool 选中内容</li>
<li>用move tool移动区域内内容</li>
</ul>
</li>
<li>如何复制粘贴图层中部分内容。
<ul>
<li>方法1：ctrl + C 复制，ctrl + V 粘贴。这样复制内容会放到一个新的图层里。在新的图层移动复制的内容后，merge两个图层。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>paint</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法说明</title>
    <url>/blog/2020/01/25/Markdown%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。简单的来说，Markdown就是用“标记符号”表示“格式”。Markdown语法标签与HTML语法标签是一一对应的。在这里，本文介绍一些Markdown的基本语法以及自己运行Markdown脚本的编译器。</p>
<span id="more"></span>
<h2 id="Sublime-Text-编辑器">Sublime Text 编辑器</h2>
<p>由于Markdown非常好的好用，有很多在线和离线的编辑器。</p>
<ul>
<li>在线编译器：dillinger，StackEdit，MaHua，简书，马克飞象。</li>
<li>Windows 编译器：MarkdownPad，MarkPad，Smark，Miu</li>
<li>OSX 编译器：Mou，MacDown，Ulysses，iA Writer，MWeb</li>
<li>跨平台编译器：Cmd Markdown，小书匠编辑器，FarBox，Sublime Text，Atom，ReText</li>
</ul>
<p>因为作者本身写代码都在Sublime Text 3里面写，所以虽然要装一些额外的插件，自己还是不想再下载额外的工具了。因此，以下介绍如何在Sublime Text 3 里面编译Markdown:</p>
<h3 id="安装插件-Package-Control">安装插件 Package Control</h3>
<p>Sublime Text 3 中默认已经安装好了此插件。在preferences 里面可以查看是否已经安装好。如果没有，可以参考<a href="https://packagecontrol.io/installation">官方文档</a>进行安装。</p>
<h3 id="安装插件-Markdown-Editing">安装插件 Markdown Editing</h3>
<p>通过按组合键<code>Ctrl+Shift+P</code>或是点击<code>Preference-&gt;Package Control</code>调出命令面板，然后再输入 <code>install</code>，选择 <code>Package Control: install package</code>。 稍等，在弹出的对话框中搜索 Markdown Editing，找到之后按 enter 键确认安装。如果安装成功，之后会自动弹出纯文本形式显示的插件说明。点击 Preferences，在 Package Settings 里面会显示有 Markdown Editing 的插件设置选项，在里面可以更改该插件的设置。</p>
<h3 id="安装插件-Markdown-Preview">安装插件 Markdown Preview</h3>
<p>通过按组合键<code>Ctrl+Shift+P</code>或是点击<code>Preference-&gt;Package Control</code>调出命令面板，然后再输入 <code>install</code>，选择 <code>Package Control: install package</code>。 稍等，在弹出的对话框中搜索 Markdown Preview，找到之后按 enter 键确认安装。如果安装成功，之后会自动弹出纯文本形式显示的插件说明。点击 Preferences，在 Package Settings 里面会显示有 Markdown Preview 的插件设置选项，在里面可以更改该插件的设置。</p>
<h3 id="更改-Markdown-Editing-插件设置">更改 Markdown Editing 插件设置</h3>
<p>Markdown Editing 的默认设置在<code>Preferences -&gt; Package Settings -&gt; Markdown Editing -&gt; Markdown GFM Settings - Default</code> 里面，背景主题和layout 分别设定为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;color_scheme&quot;: &quot;Packages/MarkdownEditing/MarkdownEditor.tmTheme&quot;,</span><br><span class="line">// Layout</span><br><span class="line">&quot;draw_centered&quot;: true,</span><br></pre></td></tr></table></figure>
<p>这样会导致背景颜色和其他类型文件在Sublime Text 中的背景颜色不一致。同时layout的设定会导致Markdown 页面左侧会有大量留白。由于Default的设定是不能改的，我们只能从其对应的<code>Markdown GFM Settings - User</code> 里面改。加入以下内容来替换掉default的设定：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">// Default color scheme</span><br><span class="line">&quot;color_scheme&quot;: &quot;Monokai.sublime-color-scheme&quot;,</span><br><span class="line">// Layout</span><br><span class="line">&quot;draw_centered&quot;: false,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更改-Markdown-Preview-插件设置">更改 Markdown Preview 插件设置</h3>
<p>进入<code>Preferences</code>，点击<code>Key Bindings</code>，在弹出的界面右侧用户设置中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ &#123; &quot;keys&quot;: [&quot;alt+m&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: &#123;&quot;target&quot;: &quot;browser&quot;, &quot;parser&quot;:&quot;markdown&quot;&#125; &#125;, ]</span><br></pre></td></tr></table></figure>
<p>则可以设置 <code>alt + m</code> 组合为预览排版好的 HTML 样式的热键，预览工具是本机上设置的默认浏览器。在对应的Markdown文件中按下快捷键即可在浏览器上预览。此快捷键还可以把鼠标勾选的部分区域内容渲染到浏览器网页上。</p>
<h3 id="开启-Mathjax-数学环境支持">开启 Mathjax 数学环境支持</h3>
<p>如果想要在 Markdown 中插入数学公式，可以使用 LaTeX 的语法来书写，但是直接使用 LaTeX 语法来书写一段数学公式，使用 Markdown Preview 插件预览时的效果是不成功的，我们需要开启 Mathjax 数学环境支持。进入到<code>Preferences -&gt; Package Settings -&gt; Markdown Preview -&gt; Settings</code>里面加入以下内容。 与上面的插件不同，这个插件是 pymdownx 提供的，因此添加到字典中, 同时还需要需要提供 js 文件的 URL ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;js&quot;: [</span><br><span class="line">        &quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js&quot;,</span><br><span class="line">        &quot;res://MarkdownPreview/js/math_config.js&quot;</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        Markdown extension configuration.</span><br><span class="line"></span><br><span class="line">        To specify a function in this JSON configuration, create an object with the key &quot;!!python/name&quot;</span><br><span class="line">        and set it to the import path to the function &quot;module.submodule.etc.function&quot;.</span><br><span class="line">    */</span><br><span class="line">    &quot;markdown_extensions&quot;: [</span><br><span class="line">        // Python Markdown Extra with SuperFences.</span><br><span class="line">        // You can&#x27;t include &quot;extra&quot; and &quot;superfences&quot;</span><br><span class="line">        // as &quot;fenced_code&quot; can not be included with &quot;superfences&quot;,</span><br><span class="line">        // so we include the pieces separately.</span><br><span class="line">        &quot;markdown.extensions.smart_strong&quot;,</span><br><span class="line">        &quot;markdown.extensions.footnotes&quot;,</span><br><span class="line">        &quot;markdown.extensions.attr_list&quot;,</span><br><span class="line">        &quot;markdown.extensions.def_list&quot;,</span><br><span class="line">        &quot;markdown.extensions.tables&quot;,</span><br><span class="line">        &quot;markdown.extensions.abbr&quot;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;markdown.extensions.codehilite&quot;: &#123;</span><br><span class="line">                &quot;guess_lang&quot;: false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // Extra&#x27;s Markdown parsing in raw HTML cannot be</span><br><span class="line">        // included by itself, but &quot;pymdownx&quot; exposes it so we can.</span><br><span class="line">        &quot;pymdownx.extrarawhtml&quot;,</span><br><span class="line"></span><br><span class="line">        // More default Python Markdown extensions</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;markdown.extensions.toc&quot;:</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;permalink&quot;: &quot;\ue157&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;markdown.extensions.meta&quot;,</span><br><span class="line">        &quot;markdown.extensions.sane_lists&quot;,</span><br><span class="line">        &quot;markdown.extensions.smarty&quot;,</span><br><span class="line">        &quot;markdown.extensions.wikilinks&quot;,</span><br><span class="line">        &quot;markdown.extensions.admonition&quot;,</span><br><span class="line"></span><br><span class="line">        // PyMdown extensions that help give a GitHub-ish feel</span><br><span class="line">        &quot;pymdownx.superfences&quot;,  // Nested fences and UML support</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;pymdownx.magiclink&quot;: &#123;   // Auto linkify URLs and email addresses</span><br><span class="line">                &quot;repo_url_shortener&quot;: true,</span><br><span class="line">                &quot;repo_url_shorthand&quot;: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;pymdownx.tasklist&quot;,     // Task lists</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;pymdownx.tilde&quot;: &#123;  // Provide ~~delete~~</span><br><span class="line">                &quot;subscript&quot;: false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;pymdownx.emoji&quot;: &#123;  // Provide GitHub&#x27;s emojis</span><br><span class="line">                &quot;emoji_index&quot;: &#123;&quot;!!python/name&quot;: &quot;pymdownx.emoji.gemoji&quot;&#125;,</span><br><span class="line">                &quot;emoji_generator&quot;: &#123;&quot;!!python/name&quot;: &quot;pymdownx.emoji.to_png&quot;&#125;,</span><br><span class="line">                &quot;alt&quot;: &quot;short&quot;,</span><br><span class="line">                &quot;options&quot;: &#123;</span><br><span class="line">                    &quot;attributes&quot;: &#123;</span><br><span class="line">                        &quot;align&quot;: &quot;absmiddle&quot;,</span><br><span class="line">                        &quot;height&quot;: &quot;20px&quot;,</span><br><span class="line">                        &quot;width&quot;: &quot;20px&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;image_path&quot;: &quot;https://assets-cdn.github.com/images/icons/emoji/unicode/&quot;,</span><br><span class="line">                    &quot;non_standard_image_path&quot;: &quot;https://assets-cdn.github.com/images/icons/emoji/&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;pymdownx.arithmatex&quot;:</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;generic&quot;: true,</span><br><span class="line">                &quot;smart_dollar&quot;: false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于上面用到了math_config.js文件，而Sublime 本身是没有这个文件的，所以需要在对应的 js 目录下新建该文件。<br>
首先，在Sublime工具栏<code>Preferences &gt; Browser Packages…</code> 打开Packages目录，该目录所在的路径就是Sublime中包的保存路径。<br>
然后，由于上面配置文件中设置的 js 路径是<code>res://MarkdownPreview/js/math_config.js</code>，该路径是相对于sublime包的保存路径而言的，因此我们需要在该目录下新建路径“MarkdownPreview/js/math_config.js”，同时添加math_config.js文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MathJax.Hub.Config(&#123;</span><br><span class="line">  config: [&quot;MMLorHTML.js&quot;],</span><br><span class="line">  extensions: [&quot;tex2jax.js&quot;],</span><br><span class="line">  jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;, &quot;output/NativeMML&quot;],</span><br><span class="line">  tex2jax: &#123;</span><br><span class="line">    inlineMath: [ [&#x27;$&#x27;,&#x27;$&#x27;], [&quot;\\(&quot;,&quot;\\)&quot;] ],</span><br><span class="line">    displayMath: [ [&#x27;$$&#x27;,&#x27;$$&#x27;], [&quot;\\[&quot;,&quot;\\]&quot;] ],</span><br><span class="line">    processEscapes: true</span><br><span class="line">  &#125;,</span><br><span class="line">  TeX: &#123;</span><br><span class="line">    extensions: [&quot;AMSmath.js&quot;, &quot;AMSsymbols.js&quot;],</span><br><span class="line">    TagSide: &quot;right&quot;,</span><br><span class="line">    TagIndent: &quot;.8em&quot;,</span><br><span class="line">    MultLineWidth: &quot;85%&quot;,</span><br><span class="line">    equationNumbers: &#123;</span><br><span class="line">      autoNumber: &quot;AMS&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    unicode: &#123;</span><br><span class="line">      fonts: &quot;STIXGeneral,&#x27;Arial Unicode MS&#x27;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  displayAlign: &quot;center&quot;,</span><br><span class="line">  showProcessingMessages: false,</span><br><span class="line">  messageStyle: &#x27;none&#x27;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>配置完成后，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;equation&#125;</span><br><span class="line">    \sum\limits_&#123;0&#125;^&#123;+\infty&#125; \dfrac&#123;n^2&#125;&#123;2&#125;</span><br><span class="line">\end&#123;equation&#125;</span><br></pre></td></tr></table></figure>
<img src="formula.png" alt="formula" width="500"/> 
<h2 id="基本语法">基本语法</h2>
<h3 id="段落">段落</h3>
<p>非常自然，一行文字就是一个段落。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是一个段落。</span><br></pre></td></tr></table></figure>
<p>会被解释成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;这是一个段落。&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>如果你需要另起一段，请在两个段落之间隔一个空行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是一个段落。</span><br><span class="line"></span><br><span class="line">这是另一个段落。</span><br></pre></td></tr></table></figure>
<p>会解释成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;这是一个段落&lt;p&gt;</span><br><span class="line">&lt;p&gt;这是另一个段落&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h3 id="粗体斜体："><strong>粗体</strong><em>斜体</em>：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*这是斜体*</span><br><span class="line">_这也是斜体_</span><br><span class="line">**这是粗体**</span><br><span class="line">***这是粗体+斜体***</span><br></pre></td></tr></table></figure>
<p>会被解释成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;em&gt;这是斜体&lt;/em&gt;</span><br><span class="line">&lt;em&gt;这也是斜体&lt;/em&gt;</span><br><span class="line">&lt;strong&gt;这是粗体&lt;/strong&gt;</span><br><span class="line">&lt;strong&gt;&lt;em&gt;这是粗体+斜体&lt;/strong&gt;&lt;/em&gt;</span><br></pre></td></tr></table></figure>
<h3 id="删除线"><s>删除线</s></h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>
<p>会被解释成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;strike&gt;删除线&lt;/strike&gt;</span><br></pre></td></tr></table></figure>
<h3 id="标题">标题</h3>
<p>markdown总支持1~6六级标题，通过在一行之前加上不同数量的井号来表示。行尾可以加上任意数量的井号字符，这些字符不会算作标题内容。通常会加上相等数量的字符以保持对称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 这是 H1 #</span><br><span class="line">## 这是 H2 ##</span><br><span class="line">### 这是 H3 ###</span><br><span class="line">...</span><br><span class="line">###### 这是 H6 ######</span><br></pre></td></tr></table></figure>
<h3 id="H1和H2">H1和H2</h3>
<p>在文本下方添加底线来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是 H1</span><br><span class="line">=======</span><br><span class="line"></span><br><span class="line">这是 H2</span><br><span class="line">-------</span><br></pre></td></tr></table></figure>
<h3 id="引用">引用</h3>
<blockquote>
<p>通过在行首加上大于号&gt;来添加引用格式。引用可以嵌套，也可以嵌套其他格式。(此行是一个引用的格式)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class="line">consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class="line">Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line"></span><br><span class="line">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class="line">id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure>
<h3 id="列表">列表</h3>
<p>无序列表使用星号、加号或是减号作为列表标记(都是等价的)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Red</span><br><span class="line">- Green</span><br><span class="line">+ Blue</span><br></pre></td></tr></table></figure>
<p>有序列表则使用数字接着一个英文句点，数字并不会影响输出的 HTML 结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Red</span><br><span class="line">1. Green</span><br><span class="line">2. Blue</span><br></pre></td></tr></table></figure>
<h3 id="内联代码">内联代码</h3>
<p>用反引号来标记内联代码，它们会解释成<code>&lt;code&gt;</code>标签。如果代码的内容中有反引号，请用两个反引号包裹。代码中的&amp;、&lt;、&gt;符号都会自动转义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`a=2`</span><br></pre></td></tr></table></figure>
<h3 id="代码区域">代码区域</h3>
<p>可以首行首缩进4个空格。也可以用三个反引号独占一行来标记。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    这是一个代码区块。</span><br><span class="line">`` ` </span><br><span class="line">这是一个代码区块。 </span><br><span class="line">`` `</span><br></pre></td></tr></table></figure>
<p>会被解释成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;pre&gt;&lt;code&gt;这是一个代码区块。</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<h3 id="换行">换行</h3>
<ul>
<li>换行单倍行距：按键 space, space, enter</li>
<li>换行双倍行距：按键 enter, enter</li>
</ul>
<h3 id="分隔线">分隔线</h3>
<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* * *</span><br><span class="line">***</span><br><span class="line">*****</span><br><span class="line">- - -</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure>
<h3 id="链接">链接</h3>
<p>链接的书写格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[an example](http://example.com/)</span><br><span class="line">[an example](http://example.com/ &quot;Optional Title&quot;)</span><br></pre></td></tr></table></figure>
<p>会被解释为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&#x27;http://example.com/&#x27;&gt;an example&lt;/a&gt;</span><br><span class="line">&lt;a href=&#x27;http://example.com/&#x27; title=&quot;Optional Title&quot;&gt;an example&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>如果链接的地址和名字重复，可以用尖括号语法将其简化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;http://example.com/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="表格">表格</h3>
<p>表格是github风格独有的语法，但近年来渐渐被大多数编辑器支持。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| Item     | Value | Qty   |</span><br><span class="line">| :------- | ----: | :---: |</span><br><span class="line">| Computer | $1600 |  5    |</span><br><span class="line">| Phone    | $12   |  12   |</span><br><span class="line">| Pipe     | $1    |  234  |</span><br></pre></td></tr></table></figure>
<p>会被解释成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;thead&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;th align=&quot;left&quot;&gt;Item&lt;/th&gt;</span><br><span class="line">  &lt;th align=&quot;right&quot;&gt;Value&lt;/th&gt;</span><br><span class="line">  &lt;th align=&quot;center&quot;&gt;Qty&lt;/th&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/thead&gt;</span><br><span class="line">&lt;tbody&gt;&lt;tr&gt;</span><br><span class="line">  &lt;td align=&quot;left&quot;&gt;Computer&lt;/td&gt;</span><br><span class="line">  &lt;td align=&quot;right&quot;&gt;$1600&lt;/td&gt;</span><br><span class="line">  &lt;td align=&quot;center&quot;&gt;5&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td align=&quot;left&quot;&gt;Phone&lt;/td&gt;</span><br><span class="line">  &lt;td align=&quot;right&quot;&gt;$12&lt;/td&gt;</span><br><span class="line">  &lt;td align=&quot;center&quot;&gt;12&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td align=&quot;left&quot;&gt;Pipe&lt;/td&gt;</span><br><span class="line">  &lt;td align=&quot;right&quot;&gt;$1&lt;/td&gt;</span><br><span class="line">  &lt;td align=&quot;center&quot;&gt;234&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/tbody&gt;&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<p>对于一些复杂表格来说，尤其是需要合并单元格的表格，还是推荐用html 的格式来进行书写。</p>
<h3 id="图片">图片</h3>
<p>Markdown有自己表示图片的方法如下。然而有些时候我们需要修改图片大小之类的一些参数，而此自带的方法不如html 中&lt;img&gt;标签灵活：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![Alt text](/path/to/img.jpg)</span><br><span class="line">![Alt text](/path/to/img.jpg &quot;Optional Title&quot;)</span><br></pre></td></tr></table></figure>
<p>会被解释为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&#x27;/path/to/img.jpg&#x27; alt=&#x27;Alt text&#x27; /&gt;</span><br><span class="line">&lt;img src=&#x27;/path/to/img.jpg&#x27; alt=&#x27;Alt text&#x27; title=&#x27;Optional Title&#x27; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="转义">转义</h3>
<p>markdown支持在以下字符前面插入反斜杠：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   底线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  括弧</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   惊叹号</span><br></pre></td></tr></table></figure>
<p>插入之后，将不再解析这些字符，而是原样输出。</p>
<h2 id="高级语法">高级语法</h2>
<p>只有少数编辑器支持，使用前请先确认。</p>
<h3 id="数学公式">数学公式</h3>
<p>内联的TeX公式使用一个美元符号标记：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$</span><br></pre></td></tr></table></figure>
<p>TeX公式块用独占一行的两个美元符号来标记：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">a^2 = 2</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>也可以用equation的标签表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;equation&#125;</span><br><span class="line">\begin&#123;eqnarray&#125;</span><br><span class="line">f(x) = a_nx^n \\</span><br><span class="line">g(x) = x^2</span><br><span class="line">\end&#123;eqnarray&#125;</span><br><span class="line">\end&#123;equation&#125;</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">\begin&#123;gather&#125;</span><br><span class="line">(a+b) \times c = a\times c + b \times c \notag \\</span><br><span class="line">ac= a\times c \\</span><br><span class="line">\end&#123;gather&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>比较推荐用第二种写法，但是需要确认自己的编辑器是否支持第二种写法。因为其生成的公式会有序号。而且如果在里面嵌套标签的话，看起来更加和谐。</p>
<p>参考文献:</p>
<ul>
<li><a href="https://wizardforcel.gitbooks.io/markdown-simple-world/content/">非常好的Markdown教程</a></li>
<li><a href="http://iliutong.cn/2018/02/21/build-md-environ-with-sublime/">Sublime Text搭建Markdown编译环境</a></li>
<li><a href="https://blog.csdn.net/SkullSky/article/details/83036547">在Sublime Markdown Preview 插件中开启Mathjax</a></li>
<li><a href="https://www.cnblogs.com/nowgood/p/latexstart.html">Markdown 中使用Latex公式</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Jekyll 搭建个人网站</title>
    <url>/blog/2019/12/10/Jekyll-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>Github Pages 允许免费托管由Jekyll生成的静态网页博客，我们可以用来制作自己的个人网站。本文我们介绍一个基于Jekyll的比较好看的个人网站模板，叫做academicpages。 其<a href="https://github.com/academicpages/academicpages.github.io">源代码</a> 和生成的<a href="https://academicpages.github.io/">网页效果</a>比较适用于偏学术风格的个人网站。</p>
<span id="more"></span>
<h2 id="本地测试">本地测试</h2>
<p>(1) 直接下载<a href="https://github.com/academicpages/academicpages.github.io">源代码</a>到本地并解压。terminal 中把当前路径设到解压后的根目录下面。<br>
(2) 本文默认的安装机器是Mac，并且Homebrew 已经提前安装好。此外，我们需要安装ruby, bundler 和 nodejs，安装命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install ruby // ruby其实应该默认已经安装在Mac系统上了，以防万一可以再用brew 安装下</span><br><span class="line">gem install bundler // gem 是ruby的打包系统</span><br><span class="line">brew install node // 安装nodejs</span><br></pre></td></tr></table></figure>
<p>(3) 当前目录下运行 <code>bundle clean</code> 先整理下载下来的project。<br>
(4) 当前目录下运行 <code>bundle install</code> 来安装对应的依赖文件。如果出现错误请删除文件夹中的Gemfile.lock 然后重试。<br>
(5) 当前目录下运行 <code>bundle exec jekyll liveserve</code> 来生成静态html文件并部署到本地服务器上。运行成功的话 localhost:4000 进行访问。退出时按 ctrl + c。所展示页面如图：<br>
<img src="template.png" alt="template"/></p>
<h2 id="修改网站内容">修改网站内容</h2>
<h3 id="Side-bar-板块">Side bar 板块</h3>
<p>网站主页左边的side bar 内容，可以通过修改根目录下面_config.yml来完成。主要修改“Site Settings” 和 “Site Author” 两个部分。<br>
(1) 在“Site Settings” 部分，url 对应的是要部署的主机名称hostname。如果是本地测试，要改为<a href="http://localhost:4000/">http://localhost:4000/</a> 。否则为对应的github.io的名字<a href="https://academicpages.github.io">https://academicpages.github.io</a> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site Settings</span><br><span class="line">locale                   : &quot;en-US&quot;</span><br><span class="line">title                    : &quot;Your Name / Site Title&quot;</span><br><span class="line">title_separator          : &quot;-&quot;</span><br><span class="line">name                     : &amp;name &quot;Your Name&quot;</span><br><span class="line">description              : &amp;description &quot;personal description&quot;</span><br><span class="line">url                      : http://localhost:4000/ # the base hostname &amp; protocol for your site e.g. &quot;https://mmistakes.github.io&quot;</span><br><span class="line">baseurl                  : &quot;&quot; # the subpath of your site, e.g. &quot;/blog&quot;</span><br><span class="line">repository               : &quot;academicpages/academicpages.github.io&quot;</span><br></pre></td></tr></table></figure>
<p>(2) 在“Site Author”部分，头像照片需要存放在images/ 文件夹下面。_config.yml中只需要直接填写照片的文件名profile.png即可:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">author:</span><br><span class="line">  name             : &quot;Your Sidebar Name&quot;</span><br><span class="line">  avatar           : &quot;profile.png&quot;</span><br><span class="line">  bio              : &quot;Your biography for the left-hand sidebar&quot;</span><br><span class="line">  location         : &quot;Location&quot;</span><br><span class="line">  employer         :</span><br><span class="line">  pubmed           : &quot;https://www.ncbi.nlm.nih.gov/pubmed/?term=john+snow&quot;</span><br><span class="line">  googlescholar    : &quot;http://yourfullgooglescholarurl.com&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Navigation-板块">Navigation 板块</h3>
<p>网站主页上方的导航栏的内容，可以通过修改 data/navigation.yml里面内容完成。具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">  - title: &quot;Publications&quot;</span><br><span class="line">    url: /publications/</span><br><span class="line"></span><br><span class="line">  - title: &quot;Talks&quot;</span><br><span class="line">    url: /talks/    </span><br><span class="line"></span><br><span class="line">  - title: &quot;Teaching&quot;</span><br><span class="line">    url: /teaching/    </span><br><span class="line">    </span><br><span class="line">  - title: &quot;Portfolio&quot;</span><br><span class="line">    url: /portfolio/</span><br><span class="line">        </span><br><span class="line">  - title: &quot;Blog Posts&quot;</span><br><span class="line">    url: /year-archive/</span><br><span class="line">    </span><br><span class="line">  - title: &quot;CV&quot;</span><br><span class="line">    url: /cv/</span><br><span class="line">    </span><br><span class="line">  - title: &quot;Guide&quot;</span><br><span class="line">    url: /markdown/</span><br></pre></td></tr></table></figure>
<p>如果一些板块不需要的话，可以用“#” 注释掉或者直接移除。</p>
<h3 id="修改各个板块内容">修改各个板块内容</h3>
<p>大部分的板块内容存放在其对应的文件夹中。比如对于talks来说，其里面的所有内容都存放在 _talks/ 文件夹中。每个具体的talk内容都存放成单独的Markdown 文件。而控制这些板块的文件放在 _pages/ 文件夹中，以或者Markdown 或者html 的格式存在。比如talks.html 控制着 hostname/talk/ 这个页面来显示对应的所有talks的信息，如图所示：<br>
<img src="talk.png" alt="talk" width="700"/><br>
点击每个talk的链接可以进入具体的talk 内容，由_talks/ 文件夹下的Markdown 控制。<br>
每个Markdown 文件的开头都是一些Yaml 格式的metadata。比如下图中 permalink 代表的是对应内容的链接是 hostname/talks/2012-03-01-talk-1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;Talk 1 on Relevant Topic in Your Field&quot;</span><br><span class="line">collection: talks</span><br><span class="line">type: &quot;Talk&quot;</span><br><span class="line">permalink: /talks/2012-03-01-talk-1</span><br><span class="line">venue: &quot;UC San Francisco, Department of Testing&quot;</span><br><span class="line">date: 2012-03-01</span><br><span class="line">location: &quot;San Francisco, California&quot;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">This is a description of your talk, which is a markdown files that can be all markdown-ified like any other post. Yay markdown!</span><br></pre></td></tr></table></figure>
<p>所有的文件比如PDF或者zip类型的文件，都可以存放在 files/ 文件夹下面. 如果引用的话，对于example.pdf这个文件来说，其对应的链接在https://[your GitHub username].github.io/files/example.pdf。</p>
<p>此外，_pages/ <a href="http://xn--about-bi1hy8cq05b7jzxv1b.md">文件夹下的about.md</a> 中的内容是个人网站的首页内容。<a href="http://404.md">404.md</a> 页面内容是当网址不存在的时候会跳转到的页面。<a href="http://cv.md">cv.md</a> 是直接的resume 页面:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout: archive</span><br><span class="line">title: &quot;CV&quot;</span><br><span class="line">permalink: /cv/</span><br><span class="line">author_profile: true</span><br><span class="line">redirect_from:</span><br><span class="line">  - /resume</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&#123;% include base_path %&#125;</span><br><span class="line"></span><br><span class="line">Education</span><br><span class="line">======</span><br><span class="line">* B.S. in GitHub, GitHub University, 2012</span><br><span class="line">* M.S. in Jekyll, GitHub University, 2014</span><br><span class="line">* Ph.D in Version Control Theory, GitHub University, 2018 (expected)</span><br></pre></td></tr></table></figure>
<p>文件的开头同样是一些定义的Yaml格式的metadata。 redirect_from 代表其他指定页面也会跳转到当前页面。在这个例子中，hostname/cv 和 hostname/resume都会指向同一页面。</p>
<h2 id="DIY所有内容放在同一页面">DIY所有内容放在同一页面</h2>
<p>有些时候，我们会发现个人网站的内容不够丰富，不足以让每个版块都有足够的信息展示。此时，我们可以考虑把所有内容放到一个页面下，点击navigation section的时候，跳转只会跳转当前页面上对应的的section 中。实现的页面效果在 <a href="https://zhenggao.io/">https://zhenggao.io/</a> 可以体现。<br>
(1) 修改data/navigation.yml里面内容如下，对应的url 都是在主页面上面有着对应id 的section：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">  # - title: &quot;Home&quot;</span><br><span class="line">  #   url: /cv/</span><br><span class="line">  # - title: &quot;Education&quot;</span><br><span class="line">  #   url: /#education</span><br><span class="line">  - title: &quot;Research&quot;</span><br><span class="line">    url: /#research</span><br><span class="line">  - title: &quot;Experience&quot;</span><br><span class="line">    url: /#experience  </span><br><span class="line">  - title: &quot;Publication&quot;</span><br><span class="line">    url: /#publication</span><br><span class="line">  - title: &quot;Service&quot;</span><br><span class="line">    url: /#service     </span><br><span class="line">  - title: &quot;CV&quot;</span><br><span class="line">    url: /files/cv.pdf   </span><br></pre></td></tr></table></figure>
<p>(2) <a href="http://xn--about-jq1hktj62m4h2a6p5eoqc.md">由于主页面是about.md</a>，所以我们所有的内容都放在这个页面里面。在想要跳转的部分，加上对应的id，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h2 id=&quot;research&quot;&gt; Research&lt;/h2&gt;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这时点击navigation bar 上面的Research部分，我们就会跳转到主页面的这个Rearch 标题部分。</p>
<h2 id="部署到Github-Pages">部署到Github Pages</h2>
<p>(1) 在Github上新建一个仓库，<a href="http://xn--RoyZhengGao-g68qe6dhz8ath1b.github.io">仓库名为RoyZhengGao.github.io</a>（这个仓库的名称必须严格按照 <a href="http://username.github.io">username.github.io</a> 的格式来命名）。<br>
(2) 把所有的网站代码上传到对应仓库中去：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin git@github.com:RoyZhengGao/RoyZhengGao.github.io.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>(3) 打开<a href="http://RoyZhengGao.github.io">http://RoyZhengGao.github.io</a> (对应自己的 <a href="http://username.github.io">http://username.github.io</a> )来测试网站是否部署成功。通常第一次创建Github Pages站点需要5-10分钟的时间。</p>
<h2 id="购买并绑定域名">购买并绑定域名</h2>
<p>(1) 我们这里以在Namecheap 网站购买域名为例。首先注册Namecheap<a href="https://www.namecheap.com/">个人账号</a>来购买喜欢的域名。<br>
(2) 在side bar 中选择 “Domain List”。找到需要链接的域名并点击其旁边的“Manage”按钮，如下图所示：<br>
<img src="domain1.png" alt="domain1"/><br>
(3) 点击“Advanced DNS”按钮进入。点击“Add New Record”来添加以下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- A record for @ pointing to 185.199.108.153</span><br><span class="line">- A record for @ pointing to 185.199.109.153</span><br><span class="line">- A record for @ pointing to 185.199.110.153</span><br><span class="line">- A record for @ pointing to 185.199.111.153</span><br><span class="line">- CNAME record for www pointing to your username.github.io (是你对应要绑定的Github 账号用户名)</span><br></pre></td></tr></table></figure>
<p>如果有其他多余的记录，需要删除。最后的页面如下：<br>
<img src="domain2.png" alt="domain2"/></p>
<p>(4) 点击“Save All Changes” 按钮进行保存。</p>
<p>(5) 在Github中建立的username.github.io的repository中找到CNAME文件（如果不存在，请手动建立一个）。在文件中加上对应绑定的域名，如下图所示：<br>
<img src="domain3.png" alt="domain3" width="500"/><br>
此时点击repository 中的“Settings” 按钮，查看Github Pages是否被重定向到绑定的域名中。下图表示已经成功绑定：<br>
<img src="domain4.png" alt="domain4" /><br>
最后，至少需要三十分钟的部署时间。之后就可以访问绑定的<a href="http://www.zhenggao.io">域名</a>了！</p>
<p>参考文献:</p>
<ul>
<li><a href="https://github.com/academicpages/academicpages.github.io">academicpages 模板安装指南</a></li>
<li><a href="https://academicpages.github.io/">academicpages 模板页面效果</a></li>
<li><a href="https://segmentfault.com/a/1190000011203711">Github Pages 绑定域名</a></li>
<li><a href="https://www.namecheap.com/support/knowledgebase/article.aspx/9645/2208/how-do-i-link-my-domain-to-github-pages">Namecheap 网站上连接域名与Github Pages</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>jekyll</tag>
        <tag>front end</tag>
        <tag>tech tool</tag>
      </tags>
  </entry>
  <entry>
    <title>O1签证</title>
    <url>/blog/2022/04/14/O1%E7%AD%BE%E8%AF%81/</url>
    <content><![CDATA[<p>作为一种工作签证，在抽不到H1b的情况下，O1可以作为保留在美国合法工作身份的替代品。本文详细介绍O1和H1b的不同，以及O1签证的好处与局限性。</p>
<span id="more"></span>
<h2 id="O1签证简介">O1签证简介</h2>
<ul>
<li>O-1特殊技能人才签证属于非移民工作签证的一种，技能范围涉及到科学、艺术、教育、商业或体育行业，木偶演员、花样滑冰运动员、科研人员等都可以申请。尤其在H-1B当年名额用尽或H-1B签证到期的情况下，很多科技人员转而申请O-1签证。O-2签证是对O-1签证持有人（艺术家、运动员）助理的签证。O-3签证是对O-1签证持有人配偶和未成年子女的签证，<strong>O-3签证不可在美工作</strong>，但可以在美上学。</li>
<li>O签证没有明确的有效期限制。O签证的有效期等同于完成项目所需的时间，初次申请不得超过三年。如果需要更多的时间进行同一项目，可以申请延期，每次延期不得超过一年。如果一个新的项目需要O-1持有人继续为原雇主工作，该雇主可以为该雇员申请一个新的O-1，初次有效期仍然可以长达三年，随后仍可以一年为限申请延期。因此，O-1的有效期是由项目/活动所需的时间决定的。</li>
<li>J签证持有者有两年回国服务期限制，不办理豁免不能转成H、L等签证、不能调整身份等，但可以转成O签证（需要使馆签证手续）。</li>
<li>允许双重倾向：申请人可以有移民倾向，申请人的O签证申请不会因为其已递交的移民申请而被拒签。</li>
<li>O1签证的分类 O1签证分为O-1A和O-1B： O1A签证供科学、教育、商业或竞技有杰出能力的人士申请； O1B签证供在艺术、电影、电视行业有杰出能力的人士申请。</li>
</ul>
<h2 id="O1签证优缺点">O1签证优缺点</h2>
<ul>
<li>配偶为O3签证，不能工作。</li>
<li>每次换雇主都要重新办理O1签证。</li>
<li>签证3个月有效，single entry。基本上每次入境都要重新签证。</li>
<li>O1一开始可以申请三年，之后每次续签都要collect一次推荐信，而且续一次只有一年。</li>
<li>绿卡485阶段O1不可以出境，H1B就没有这个问题。</li>
<li>O1的很多申请资料可以在以后申请EB-1b的时候重复用。</li>
<li>O1买房的问题：
<ul>
<li><a href="https://www.jjhgroup.net/blog/mortgage-for-non-us-resident">相关链接1</a></li>
<li><a href="http://msfangzi.com/?p=7223">相关链接2</a></li>
<li>最常用的Conventional loan 主要是针对有美国身份的客户。包括美国公民，绿卡, 工作签证。O1,H1, L1签证目前都可以做到贷款。J1以及H1是根据不同的Case来定的。F1如果有EAD卡有一些贷款机构也是可以贷款的。但需要两年的报税记录。</li>
</ul>
</li>
</ul>
<h2 id="O1签证和H1b签证的区别">O1签证和H1b签证的区别</h2>
<ul>
<li>这两类签证都属于允许移民倾向的“双重倾向”签证，都需要雇主支持，并且持有人的眷属都可以持附属签证随同赴美。</li>
<li>O-1签证每年没有数额限制；没有最低学位要求；没有执业证要求，O-1签证不会因为缺少执业证而被拒；不涉及劳动部门，没有满足行业现行工资问题。</li>
<li>H-1B签证持有人入境时移民官准许的初始逗留时间为3年，之后还可以申请延期3年，但是总的逗留时间不的超过6年。6年之后，H-1B持有人需要离开美国或者获得其他身份，否则将失去在美国的合法身份。当然，极少数情况下H-1B持有人可以申请延期超过6年。一般说来，O-1签证持有人首次入美时移民官准许的逗留时间以能够完成某项活动、工作或者演出为限，一般最长不超过3年。身份到期后可以申请延期，以便继续进行尚未完成的活动、工作或者演出，每次可以申请延期最多1年。因此，从理论上来说，只要移民局认为O-1持有人需要更多时间来完成自己的工作，O-1签证的合法逗留期可以被无限期延长。这一点使得O-1签证比H-1B更有吸引力。</li>
<li>绿卡485阶段O1不可以出境，H1B就没有这个问题</li>
<li>O1是single entry。H1b是multi entry。</li>
<li>O1配偶为O3不能工作，H1b配偶为H4可以工作。</li>
</ul>
<h2 id="境内激活or境外激活">境内激活or境外激活</h2>
<p>目前移民局官方公布的O-1申请处理时间在2周到2个半月之间。O-1申请可以选择加急服务，移民局会在收到材料后的15个自然日内给出审理结果。<br>
美国境内激活：O-1获批之后，你的身份会从你现有的签证身份自动转为O-1。<br>
美国境外激活：O-1获批之后不会自动生效，你需要去境外的美国领事馆面签才能拿到O-1签证。<br>
但是无论如何，出境之后都要重新申请visa stamp。</p>
<h2 id="问题">问题</h2>
<ul>
<li>Q: O1签证的起始时间可以在F1 STEM OPT过期前么？比如6月份F1到期，但是提前在4月份能换成O1么？
<ul>
<li>A：开始时间最早为申请时间的后180天。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>O1</tag>
        <tag>green card</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB使用指南</title>
    <url>/blog/2020/03/06/MongoDB%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>MongoDB 是一个目前比较流行的NoSQL数据库，用来存储非关系型数据的。这篇博客主要介绍如何安装以及用java driver调用和连接MongoDB数据库。同时也介绍了如果用MongoDB的shell直接在命令行中进行数据处理。</p>
<span id="more"></span>
<h2 id="MongoDB和SQL的区别与联系">MongoDB和SQL的区别与联系</h2>
<p>如下图所示：<br>
<img src="relationship.png" alt="relationship"/><br>
一个真实的example对比如下：<br>
<img src="example.png" alt="example"/></p>
<h2 id="安装MongoDB">安装MongoDB</h2>
<h3 id="安装过程">安装过程</h3>
<ol>
<li>因为MongoDB宣布不再开源，Homebrew 已经把他移除除了自己的仓库，因此安装MongoDB需要用到tap方法，在github中寻找源代码来安装：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew tap mongodb/brew</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>安装MongoDB:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install mongodb-community</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>开启/关闭MongoDB的port:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew services start mongodb-community</span><br><span class="line">brew services stop mongodb-community</span><br></pre></td></tr></table></figure>
<h3 id="命令行一些简单操作">命令行一些简单操作</h3>
<ol>
<li>使用MongoDB shell的话，需要在开启service之后，执行<code>mongo</code>来开启shell。</li>
<li>显示当前的collection: <code>db</code></li>
<li>显示所有的collection: <code>show dbs</code></li>
<li>switch 不同的collection: <code>use collection_name</code></li>
<li>查询数据：<code>db.collection_name.find()</code>。 <code>db.collection_name.find().pretty()</code>显示出格式化结果。</li>
<li>MongoDB的数据库默认是存在<code>/data/db</code>路径下的。</li>
</ol>
<h2 id="Java调用MongoDB">Java调用MongoDB</h2>
<ol>
<li>需要三个jar包，包括：mongodb-driver, bson和mongodb-driver-core</li>
<li>连接数据库，你需要指定数据库名称，如果指定的数据库不存在，mongo会自动创建数据库。</li>
<li>使用Java的时候，要保证MongoDB的service 是开启的，即需要提前执行 <code>brew services start mongodb</code>,否则会找不到端口从而连接数据库。</li>
<li>基本代码请看 博主本人的<a href="https://github.com/RoyZhengGao/code-repo/blob/master/java/MongoDB.java">git repository</a><br>
参考文献：</li>
</ol>
<ul>
<li><a href="https://github.com/mongodb/homebrew-brew">社区版安装MongoDB</a></li>
<li><a href="https://www.yiibai.com/mongodb">MongoDB教程1</a></li>
<li><a href="https://www.runoob.com/mongodb/mongodb-tutorial.html">MongoDB教程2</a></li>
<li><a href="https://medium.com/@gingermostly/how-to-setup-and-install-mongodb-using-homebrew-3d5a2be6ba20">安装MongoDB</a></li>
<li><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/">官方教程安装MongoDB</a></li>
<li><a href="https://www.tutorialspoint.com/mongodb/index.htm">英文MongoDB 的tutorial</a></li>
<li><a href="https://docs.mongodb.com/manual/">MongoDB官方教程</a></li>
<li><a href="https://mongodb-documentation.readthedocs.io/en/latest/ecosystem/tutorial/getting-started-with-java-driver.html#getting-started-with-java-driver">中文Java连接MongoDB的教程</a></li>
<li><a href="https://www.cnblogs.com/wenbronk/p/6385935.html">Java连接MongoDB的很好的代码</a></li>
<li><a href="http://mongodb.github.io/mongo-java-driver/3.0/driver/getting-started/quick-tour/">英文MongoDB的Java教程</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中有用的package和tricks</title>
    <url>/blog/2020/01/25/Python%E4%B8%AD%E6%9C%89%E7%94%A8%E7%9A%84package%E5%92%8Ctricks/</url>
    <content><![CDATA[<p>本文介绍一下Python 3 中的一些自己平时用到觉得不错的package。以及一些可能会有用的function以及tricks。更多内容可见本人<a href="https://github.com/RoyZhengGao/code-repo">github code repository</a>。</p>
<span id="more"></span>
<h2 id="Python的管理工具和打包发布">Python的管理工具和打包发布</h2>
<h3 id="Python-包管理工具">Python 包管理工具</h3>
<ol>
<li>distutils：distutils 是 python 标准库的一部分，2000年发布。使用它能够进行 python 模块的 安装 和 发布。<a href="http://setup.py">setup.py</a> 就是利用 distutils 的功能写成。</li>
<li>setuptools 和 distribute：setuptools 是一个为了增强 distutils 而开发的集合，2004年发布。它包含了 easy_install 这个工具。ez_setup.py 是 setuptools 的安装工具。ez 就是 easy 的缩写。简单的说，setuptools 是一个项目的名称，是基础组件。而 easy_install 是这个项目中提供的工具，它依赖基础组件工作。使用 setuptools 可以自动 下载、构建、安装和管理 python 模块。比如 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">easy_install SQLObject</span><br></pre></td></tr></table></figure>
distribute 是 setuptools 的一个分支版本。分支的原因可能是有一部分开发者认为 setuptools 开发太慢了。但现在，distribute 又合并回了 setuptools 中。因此，我们可以认为它们是同一个东西。事实上，如果你查看一下 easy_install 的版本，会发现它本质上就是 distribute 。</li>
<li>distutils2 被设计为 distutils的替代品。从2009年开发到2012年。它包含更多的功能，并希望以 packaging 作为名称进入 python 3.3 成为标准库的一部分。但这个计划 后来停滞了 。distlib 是 distutils2 的部分，它为 distutils2/packaging 提供的低级功能增加高级 API，使其便于使用。</li>
<li>pip 是目前 python 包管理的事实标准，2008年发布。它被用作 easy_install 的替代品，但是它仍有大量的功能建立在 setuptools 组件之上。<br>
pip 希望不再使用 Eggs 格式（虽然它支持 Eggs），而更希望采用“源码发行版”（使用 python <a href="http://setup.py">setup.py</a> sdist 创建）。这可以充分利用 Requirements File Format 提供的方便功能。<br>
pip 可以利用 requirments.txt 来实现在依赖的安装。在 <a href="http://setup.py">setup.py</a> 中，也存在一个 install_requires 表来指定依赖的安装。与easy_install相比, pip 明显优势更大。</li>
</ol>
<h3 id="egg-和-whl-的关系">egg 和 whl 的关系</h3>
<ul>
<li>Eggs 格式是 setuptools 引入的一种文件格式，它使用 .egg 扩展名，用于 Python 模块的安装。 setuptools 可以识别这种格式。并解析它，安装它。</li>
<li>wheel 本质上是一个 zip 包格式，它使用 .whl 扩展名，用于 python 模块的安装，它的出现是为了替代 Eggs。wheel 还提供了一个 bdist_wheel 作为 setuptools 的扩展命令，这个命令可以用来生成 wheel 包。</li>
</ul>
<h3 id="brew-和conda">brew 和conda</h3>
<p>conda是一个包，依赖和环境管理工具，适用于多种语言，conda默认随miniconda或anaconda发行，因此要安装conda，只需要安装miniconda或anconda即可。而brew是Homebrew的管理工具。两者都是用来自动下载并安装包的，并不仅限于安装Python 依赖包。这是两者与pip的区别。</p>
<h3 id="安装package">安装package</h3>
<p>全自动： pip install xxx<br>
半自动：一些python package <a href="http://xn--setup-3t2k.py">有setup.py</a> xx install . 可以follow 这些instruction<br>
如果没有write access 到site-package 这种系统路径，需要把package 安装到自己设定的路径下面去，具体参考网页<a href="https://docs.python.org/2.7/install/index.html#alternate-installation">https://docs.python.org/2.7/install/index.html#alternate-installation</a><br>
举例来说，<br>
python <a href="http://setup.py">setup.py</a> install --home=/home/ec2-user/workspaces/hoverboard-workspaces/lib</p>
<p>此时，需要把当前目录装在PYTHONPATH里面去，<br>
vim ~/.bashrc<br>
PYTHONPATH=~/one/location:$PYTHONPATH<br>
PYTHONPATH=~/second/location:$PYTHONPATH<br>
export PYTHONPATH<br>
source ~/.bashrc<br>
如果有其他依赖的话，还需要安装其他依赖package.<br>
如果在断网的情况下pip install package, 为了避免平台问题（比如amazon hoverboard）,需要先把package 所有依赖的源代码下载下来，然后再安装。具体见：<br>
<a href="https://www.cnblogs.com/jay54520/p/8330994.html">https://www.cnblogs.com/jay54520/p/8330994.html</a><br>
<a href="https://www.jianshu.com/p/f8a3f3a07aff">https://www.jianshu.com/p/f8a3f3a07aff</a><br>
<a href="https://blog.csdn.net/pierre_/article/details/54234151">https://blog.csdn.net/pierre_/article/details/54234151</a><br>
<a href="http://imshuai.com/python-pip-install-package-offline-tensorflow/">http://imshuai.com/python-pip-install-package-offline-tensorflow/</a><br>
<a href="https://woshigaozheng.blogspot.com/2019/06/python-package.html">https://woshigaozheng.blogspot.com/2019/06/python-package.html</a></p>
<p>如果感觉没有问题，比如wheel 文件适合当前平台的话，可以download 对应的whl文件，然后通过<br>
pip install --user -v --no-index “${WHEELS_LOC}certifi-2018.11.29-py2.py3-none-any.whl”<br>
进行安装</p>
<h2 id="Package篇">Package篇</h2>
<h3 id="transformers">transformers</h3>
<p>非常强大的预训练模型：<a href="https://huggingface.co/models?search=chinese">https://huggingface.co/models?search=chinese</a><br>
如果出现如下error <a href="https://github.com/huggingface/transformers/issues/2831">https://github.com/huggingface/transformers/issues/2831</a> ，安装tokenizers:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install tokenizers </span><br></pre></td></tr></table></figure>
<p>否则直接install transformers</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install transformers</span><br></pre></td></tr></table></figure>
<h3 id="flair">flair</h3>
<h3 id="gephi">gephi</h3>
<h3 id="tqdm">tqdm</h3>
<h3 id="GluonNLP">GluonNLP</h3>
<p>Based on MXNet: <a href="https://gluon-nlp.mxnet.io/">https://gluon-nlp.mxnet.io/</a><br>
示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tqdm import tqdm</span><br><span class="line">from time import sleep</span><br><span class="line">for i in tqdm(range(1, 500)):</span><br><span class="line">    sleep(0.01)</span><br></pre></td></tr></table></figure>
<h3 id="logging">logging</h3>
<h3 id="pdb">pdb</h3>
<h3 id="argparse">argparse</h3>
<h2 id="Tricks篇">Tricks篇</h2>
<h3 id="打印输出">打印输出</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;current line count %d&quot;%(line_count))</span><br><span class="line">print(f&quot;current line count &#123;line_count&#125;&quot;)</span><br><span class="line">print(&quot;current line count &#123;&#125;&quot;.format(line_count))</span><br></pre></td></tr></table></figure>
<h3 id="exception-raise-assert-和warning">exception, raise, assert, 和warning</h3>
<h3 id="init-py的作用"><strong>init</strong>.py的作用</h3>
<h3 id="init-new-call-函数解析"><strong>init</strong>, <strong>new</strong>, <strong>call</strong> 函数解析</h3>
<h3 id="all-变量用法"><strong>all</strong> 变量用法</h3>
<h3 id="类方法和静态方法区别">类方法和静态方法区别</h3>
<h3 id="类变量与实例变量">类变量与实例变量</h3>
<h3 id="代码换行">代码换行</h3>
<h3 id="args-kwargs装饰器">*args **kwargs装饰器</h3>
<h3 id="列表、元组或字典前面的星号">列表、元组或字典前面的星号</h3>
<p>列表、元组前面加星号作用是将列表解开成两个独立的参数，传入函数，字典前面加两个星号，是将字典解开成独立的元素作为形参。详情可见 <a href="https://www.pythonf.cn/read/90543">https://www.pythonf.cn/read/90543</a> 讲解。</p>
<h3 id="装饰器-用法-property">装饰器@用法: property</h3>
<h3 id="lambda函数">lambda函数</h3>
<h3 id="all-any函数">all, any函数</h3>
<h3 id="map函数">map函数</h3>
<h3 id="yield函数">yield函数</h3>
<p>yield是用于生成器。什么是生成器，你可以通俗的认为，在一个函数中，使用了yield来代替return的位置的函数，就是生成器。它不同于函数的使用方法是：函数使用return来进行返回值，每调用一次，返回一个新加工好的数据返回给你；yield不同，它会在调用生成器的时候，把数据生成object，然后当你需要用的时候，要用next()方法来取，同时不可逆。你可以通俗的叫它&quot;轮转容器&quot;，可用现实的一种实物来理解：水车，先yield来装入数据、产出generator object、使用next()来释放；好比水车转动后，车轮上的水槽装入水，随着轮子转动，被转到下面的水槽就能将水送入水道中流入田里。</p>
<h3 id="condition的表达">condition的表达</h3>
<h3 id="最大值最小值的表达">最大值最小值的表达</h3>
<p>float(“inf”) + 1还是float(“inf”)， 但是sys.maxsize + 1就不是sys.maxsize了， 某些需要判断+1以后是不是还是max的时候要注意</p>
<h3 id="python-write-to-file-buffer">python write to file buffer</h3>
<p><a href="https://stackoverflow.com/questions/18984092/python-2-7-write-to-file-instantly">https://stackoverflow.com/questions/18984092/python-2-7-write-to-file-instantly</a><br>
<a href="https://stackoverflow.com/questions/3167494/how-often-does-python-flush-to-a-file">https://stackoverflow.com/questions/3167494/how-often-does-python-flush-to-a-file</a><br>
Use flush() or</p>
<p>For file operations, Python uses the operating system’s default buffering unless you configure it do otherwise. You can specify a buffer size, unbuffered, or line buffered.<br>
For example, the open function takes a buffer size argument.<br>
<a href="http://docs.python.org/library/functions.html#open">http://docs.python.org/library/functions.html#open</a><br>
“The optional buffering argument specifies the file’s desired buffer size: 0 means unbuffered, 1 means line buffered, any other positive value means use a buffer of (approximately) that size. A negative buffering means to use the system default, which is usually line buffered for tty devices and fully buffered for other files. If omitted, the system default is used.”<br>
bufsize = 0<br>
f = open(‘file.txt’, ‘w’, bufsize)</p>
<h3 id="其他函数">其他函数</h3>
<ul>
<li>list: copy (深度copy 需要copy package)</li>
<li>deque： 从两端都可以加入</li>
<li>sorted</li>
<li>map</li>
<li>zip</li>
<li>set</li>
<li>OrderedDict</li>
<li>defaultdict</li>
<li>heapq</li>
<li>bisect</li>
<li>Counter</li>
<li>String: ord, char</li>
<li>itertools: permutations, combinations, groupby</li>
<li>functools</li>
</ul>
<h2 id="待整理部分">待整理部分</h2>
<p>If you can’t see the <a href="http://virtualenvwrapper.sh">virtualenvwrapper.sh</a>. First uninstall virtualenvwrapper. It will show messages about the location of the <a href="http://virtualenvwrapper.sh">virtualenvwrapper.sh</a> file.</p>
<p>Check all python’ location</p>
<p>type -a python</p>
<p>首选要确定哪个版本的python 要使用（不同的python版本可能存在在不同的地方）<br>
可以用module load python/2.7 用module查看有几个版本的python</p>
<p>首先install virtualenv:<br>
pip install virtualenv</p>
<p>新建一个sandbox of virtual environment:<br>
virtualenv --python=/l/python2.7/bin/python env1 (silo 上面 module load的 python 不是系统自带的，也不是anaconda上面的)</p>
<p>有些python 用的是anaconda的，所以需要指定python路径</p>
<p>把当前路径设为指定的virtual envir：</p>
<p>cd env1/<br>
source bin/activate<br>
which python<br>
pip list //看一下安装的包都有什么<br>
pip freeze// python 所有依赖的包</p>
<p>退出虚拟环境：<br>
deactivate</p>
<p>如果你的虚拟环境想用系统已有的包，when you create it, you need to use<br>
virtualenv --system-site-packages venv</p>
<p>Otherwise, if you don’t want to use system package, create it using:</p>
<p>virtualenv venv –no-site-packages (和以上的基本一样)</p>
<p>2.3. 指定PYTHON版本<br>
可以使用-p PYTHON_EXE选项在创建虚拟环境的时候指定python版本<br>
#创建python2.7虚拟环境<br>
➜  Test git:(master) ✗ virtualenv -p /usr/bin/python2.7 ENV2.7<br>
Running virtualenv with interpreter /usr/bin/python2.7<br>
New python executable in ENV2.7/bin/python<br>
Installing setuptools, pip…done.<br>
#创建python3.4虚拟环境<br>
➜  Test git:(master) ✗ virtualenv -p /usr/local/bin/python3.4 ENV3.4<br>
Running virtualenv with interpreter /usr/local/bin/python3.4<br>
Using base prefix ‘/Library/Frameworks/Python.framework/Versions/3.4’<br>
New python executable in ENV3.4/bin/python3.4<br>
Also creating executable in ENV3.4/bin/python<br>
Installing setuptools, pip…done.</p>
<p>作者：Andrew_liu<br>
链接：<a href="http://www.jianshu.com/p/08c657bd34f1">http://www.jianshu.com/p/08c657bd34f1</a><br>
來源：简书<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>使用VIRTUALENVWRAPPER （更简单的方法）</p>
<p><a href="http://codingpy.com/article/virtualenv-must-have-tool-for-python-development/">http://codingpy.com/article/virtualenv-must-have-tool-for-python-development/</a><br>
<a href="http://qicheng0211.blog.51cto.com/3958621/1561685">http://qicheng0211.blog.51cto.com/3958621/1561685</a><br>
<a href="http://www.jianshu.com/p/44ab75fbaef2">http://www.jianshu.com/p/44ab75fbaef2</a><br>
<a href="http://liuzhijun.iteye.com/blog/1872241">http://liuzhijun.iteye.com/blog/1872241</a></p>
<p>man 在Linux中可以有文档查看的功能 i.e.<br>
man ls<br>
man python<br>
参考文献</p>
<ul>
<li><a href="https://blog.zengrong.net/post/python_packaging/">Python 包管理工具解惑</a></li>
<li><a href="http://kuanghy.github.io/2018/04/29/setup-dot-py">setup.py 编写简易指南</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cppeak3.html">使用 setuptools 孵化 Python egg</a></li>
<li><a href="https://packaging.python.org/discussions/wheel-vs-egg/">Wheel vs Egg</a></li>
<li><a href="http://wsfdl.com/python/2015/09/06/Python%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%91%E5%B8%83%E4%B8%8A.html">Python application 的打包和发布</a></li>
<li><a href="https://blog.csdn.net/hong201/article/details/4219035">egg文件制作与安装</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25020501">Python eggs - 简介</a></li>
<li><a href="https://www.cnblogs.com/kungfupanda/p/3343113.html">python的egg包的安装和制作</a></li>
<li><a href="http://nooverfit.com/wp/%E5%85%B3%E4%BA%8Econda%E5%92%8Canaconda%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%84%E4%BA%8B%E5%AE%9E%E5%92%8C%E8%AF%AF%E8%A7%A3-conda%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">pip和conda的关系</a></li>
<li><a href="https://cuiqingcai.com/6080.html">Python中logging模块的基本用法</a></li>
<li><a href="https://juejin.im/post/5bc2bd3a5188255c94465d31">logging总结</a></li>
<li><a href="https://www.cnblogs.com/yyds/p/6901864.html">logging模块处理</a></li>
<li><a href="https://blog.csdn.net/IllegalName/article/details/77446428">Python异常信息的捕获和处理</a></li>
<li><a href="https://blog.csdn.net/u013982161/article/details/53453979">Python标准异常和异常处理详解</a></li>
<li><a href="https://blog.csdn.net/lihao21/article/details/79762681">Python 实例方法、类方法和静态方法</a></li>
<li><a href="https://www.zhihu.com/question/20021164">classmethod 和 staticmethod具体用途</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/35643573">@classmethod 的使用场合</a></li>
<li><a href="https://foofish.net/different_bettween_classmethod_and_staticmethod.html">正确理解@classmethod与@staticmethod</a></li>
<li><a href="http://kuanghy.github.io/2015/12/19/python-variable">类变量与实例变量</a></li>
<li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p01_make_hierarchical_package_of_modules.html"><strong>init</strong>.py讨论</a></li>
<li><a href="https://www.cnblogs.com/Lands-ljk/p/5880483.html"><strong>init</strong>.py 作用详解</a></li>
<li><a href="https://blog.csdn.net/tianbwin2995/article/details/50863940">装饰器，*args **kwargs讲解</a></li>
<li><a href="https://blog.csdn.net/junxieshiguan/article/details/82502437">关于__init__,以及__new__,__call__的基本认识</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/index.html">yield 使用浅析</a></li>
<li><a href="https://www.cnblogs.com/neightchen/p/6669659.html">yield和return区别</a></li>
<li><a href="https://github.com/brennerm/PyTricks">Python tricks</a></li>
</ul>
]]></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>programming language</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim使用技巧</title>
    <url>/blog/2020/03/19/Vim%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>vim作为在terminal端处理文本的最有名的编辑器，我们总结一下它的一些基本使用方法。</p>
<span id="more"></span>
<h2 id="vi-和-vim的区别">vi 和 vim的区别</h2>
<p>它们都是多模式编辑器，不同的是vim 是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性在里面。总的来说，vim比vi更具优势的地方在于：</p>
<ul>
<li>多级撤消：在vi的命令模式里，按 u只能撤消上次命令，而在vim里可以无限制的撤消，几乎等同于windows下的ctrl+z了 。</li>
<li>多操作系统支持：vi只能运行于unix中，而vim不仅可以运行于unix,还有windows ,mac等操作系统上。</li>
<li>语法加亮：作为一名程序员，我觉得这个效果用处最大了- vim可以对代码进行多颜色的语法加亮。</li>
<li>可视化操作：因为vim不仅可以在终端运行，也可以运行于x window、 mac os、 windows， 所以说他“可视化”。</li>
<li>对vi的完全兼容：某些情况下，vim可以完全被当成vi来使用。</li>
</ul>
<h2 id="vim使用">vim使用</h2>
<p>基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。简单的说，我们可以将这三个模式想成底下的图标来表示：<br>
<img src="workflow.png" alt="workflow" width="500"/></p>
<h3 id="命令模式">命令模式</h3>
<p>用户刚刚启动 vi/vim，便进入了命令模式。<br>
此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。<br>
以下是常用的几个命令：</p>
<ul>
<li><code>i</code> 切换到输入模式，以输入字符。</li>
<li><code>:</code> 切换到底线命令模式，以在最底一行输入命令。<br>
若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</li>
</ul>
<p><strong>在当前行里面有效的移动光标:</strong></p>
<ul>
<li><code>fx</code>：移动光标到当前行的下一个 x 处。很明显，x 可以是任意一个字母，而且你可以使用 ; 来重复你的上一个 f 命令。</li>
<li><code>tx</code>：和上面的命令类似，但是是移动到 x 的左边一个位置。（这真的很有用）</li>
<li><code>Fx</code>：和 fx 类似，不过是往回找。</li>
<li><code>w</code>：光标往前移动一个词。</li>
<li><code>b</code>：光标往后移动一个词。</li>
<li><code>0</code>：移动光标到当前行首。</li>
<li><code>^</code>：移动光标到当前行的第一个字母位置。</li>
<li><code>$</code>：移动光标到行尾。</li>
<li><code>)</code>：移动光标到下一个句子。</li>
<li><code>(</code>：移动光标到上一个句子</li>
</ul>
<p><strong>在整个文件里面有效移动光标:</strong></p>
<ul>
<li><code>Ctrl-F</code>：向下移动一屏。</li>
<li><code>Ctrl-B</code>：向上移动一屏。</li>
<li><code>G</code>：到文件尾</li>
<li><code>numG</code>：移动光标到指定的行（num）。（比如 10G 就是到第 10 行）</li>
<li><code>gg</code>：到文件首</li>
<li><code>H</code>：移动光标到屏幕上面</li>
<li><code>M</code>：移动光标到屏幕中间</li>
<li><code>L</code>：移动光标到屏幕下面</li>
<li><code>*</code>：读取光标处的字符串，并且移动光标到它再次出现的地方。</li>
<li><code>#</code>：和上面的类似，但是是往反方向寻找。</li>
<li><code>/text</code>：从当前光标处开始搜索字符串 text，并且到达 text 出现的地方。必须使用回车来开始这个搜索命令。如果想重复上次的搜索的话，按 n。</li>
<li><code>？text</code>：和上面类似，但是是反方向。</li>
<li><code>.</code>：重复前一个动作。</li>
</ul>
<p><strong>剪切和拷贝:</strong></p>
<ul>
<li><code>dd</code>：删除游标所在的那一整行。</li>
<li><code>ndd</code>： n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行。</li>
<li><code>yy</code>：复制游标所在的那一行。</li>
<li><code>nyy</code>：n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行。</li>
<li><code>p, P</code>：p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。</li>
<li><code>u</code>：复原前一个动作。</li>
<li><code>Ctrl+r</code>：重做上一个动作。</li>
</ul>
<h3 id="输入模式">输入模式</h3>
<ul>
<li><code>i, I</code>: 进入输入模式(Insert mode)：i 为从目前光标所在处输入， I 为在目前所在行的第一个非空格符处开始输入。</li>
<li><code>a, A</code>: 进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为从光标所在行的最后一个字符处开始输入。</li>
<li><code>o, O</code>: 进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在处的上一行输入新的一行。</li>
<li><code>r, R</code>: 进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止。</li>
<li><code>Esc</code>: 退出编辑模式，回到一般模式中。</li>
</ul>
<h3 id="底线命令模式">底线命令模式</h3>
<p>在命令模式下按下<code>:</code>就进入了底线命令模式。底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。在底线命令模式中，基本的命令有：</p>
<ul>
<li><code>:w</code>:  将编辑的数据写入硬盘档案中。</li>
<li><code>:w!</code>: 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关。</li>
<li><code>:q</code>: 离开 vi。</li>
<li><code>:q!</code>: 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。惊叹号 (!) 在 vi 当中，常常具有强制的意思～</li>
<li><code>:wq</code>: 储存后离开，若为 <code>:wq!</code> 则为强制储存后离开。</li>
<li><code>:! command</code>: 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如<br>
<code>:! ls /home</code>即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</li>
<li>按ESC键可随时退出底线命令模式。<br>
以下为非常全面的vim命令的键盘图：<br>
<img src="summary.png" alt="summary"/><br>
Reference:</li>
<li><a href="https://blog.csdn.net/allenlinrui/article/details/7269481">vi和vim的区别</a></li>
<li><a href="https://www.runoob.com/linux/linux-vim.html">vim/vi简易教程</a></li>
<li><a href="https://www.runoob.com/w3cnote/all-vim-cheatsheat.html">vim快捷键位图</a></li>
<li><a href="https://linuxtoy.org/archives/efficient-editing-with-vim.html">vim的基本操作</a></li>
<li><a href="https://www.cnblogs.com/hyddd/archive/2010/04/08/1706865.html">vim命令大全</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>tech tool</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux 使用指南</title>
    <url>/blog/2019/12/16/tmux-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>tmux 是一款非常好用的终端管理软件。尤其是在服务器上面运行代码的时候尤为推荐。tmux支持多个窗口，每个窗口又可以分屏操作。这样不需要每开一个窗口都要重新登录下服务器了。同时，即使退出窗口（不是关闭），tmux上跑的代码仍然可以后台运行，这样不需要再用nohup这种命令来离线跑代码了。tmux本身支持很多快捷键操作，本文只介绍一些作者自己常用的命令，其余的可以参考reference里面的链接。</p>
<span id="more"></span>
<h2 id="tmux结构">tmux结构</h2>
<p>tmux采用C/S模型构建，主要包括三层结构：会话、窗口、面板。一个tmux session（会话）可以包含多个window（窗口），一个window又可以包含多个pane（面板），窗口下的面板，都处于同一界面下，这些面板适合运行相关性高的任务，以便同时观察到它们的运行情况。<br>
<img src="screen.png" alt="screen"/></p>
<h2 id="安装tmux">安装tmux</h2>
<p>在Mac中安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 先安装Homebrew，有则跳过</span><br><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line"># 安装tmux</span><br><span class="line">brew install tmux</span><br></pre></td></tr></table></figure>
<p>在Linux中安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install tmux</span><br></pre></td></tr></table></figure>
<h2 id="会话">会话</h2>
<p>1.新建会话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux # 新建一个无名称的会话</span><br><span class="line">tmux new -s demo # 新建一个名称为demo的会话</span><br></pre></td></tr></table></figure>
<p>2.断开当前对话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux detach # 断开当前会话，会话在后台运行</span><br></pre></td></tr></table></figure>
<p>3.进入之前会话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux a # 默认进入第一个会话</span><br><span class="line">tmux a -t demo # 进入到名称为demo的会话</span><br><span class="line">tmux attach-session -t session-name</span><br></pre></td></tr></table></figure>
<p>4.关闭会话:<br>
我们可以使用tmux的kill命令，kill命令有kill-pane、kill-server、kill-session 和 kill-window共四种，其中kill-session的语法为tmux kill-session -t session-name。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux kill-session -t demo # 关闭demo会话</span><br><span class="line">tmux kill-server # 关闭服务器，所有的会话都将关闭</span><br></pre></td></tr></table></figure>
<p>5.查看会话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux list-session # 查看所有会话</span><br><span class="line">tmux ls # 查看所有会话，提倡使用简写形式</span><br></pre></td></tr></table></figure>
<p>如果已经在会话之中，可以用快捷键<code>ctrl+b+s</code>列出所有会话，移动上下键进行选择。</p>
<h2 id="开启鼠标">开启鼠标</h2>
<p>在 <code>~/.tmux.conf</code> 中加入下列设置（tmux 2.1 之前的版本）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set -g mode-mouse on</span><br><span class="line">set -g mouse-resize-pane on</span><br><span class="line">set -g mouse-select-pane on</span><br><span class="line">set -g mouse-select-window on</span><br></pre></td></tr></table></figure>
<p>在 tmux 2.1 中，对鼠标模式进行了重写，因此新版只需要增加一段设置即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set -g mouse on</span><br></pre></td></tr></table></figure>
<p>这样在 macOS 中随意滚动进入选择模式后，按住 option 键就用直接用鼠标选择文字，然后再按鼠标中键就能直接复制内容到系统剪切板中了。<br>
这几行配置加到 <code>~/.tmux.conf</code> 中，然后在tmux里面按 <code>C-b :</code> 执行 <code>source ~/.tmux.conf</code> 即可生效.</p>
<h2 id="常用命令">常用命令</h2>
<p>自己平时会用到的一些tmux命令。更多的命令可见参考文献。</p>
<table>
    <tr>
        <td colspan="2">Ctrl+b</td>
        <td >快捷键</td>
    </tr>
    <tr>
    	<td rowspan="7">系统操作</td>
        <td >?</td>
        <td >列出所有快捷键；按q返回</td>
    </tr>
    <tr>
        <td >d</td>
        <td >脱离当前会话</td>
    </tr>
    <tr>
        <td >D</td>
        <td >选择要断开的会话</td>
    </tr>
    <tr>
        <td >s</td>
        <td >显示会话列表用于选择并切换</td>
    </tr>
    <tr>
        <td >:</td>
        <td >进入命令行模式，此时可直接输入ls等命令</td>
    </tr>
    <tr>
        <td >[</td>
        <td >进入复制模式，按q退出</td>
    </tr>
    <tr>
        <td >]</td>
        <td >粘贴复制模式中复制的文本</td>
    </tr>
    <tr>
        <td rowspan="10">窗口操作</td>
        <td >c</td>
        <td >创建新窗口</td>
    </tr>
    <tr>
        <td >&</td>
        <td >关闭当前窗口</td>
    </tr>
    <tr>
        <td >数字键</td>
        <td >切换至指定窗口</td>
    </tr>
    <tr>
        <td >p</td>
        <td >切换至上一窗口</td>
    </tr>
    <tr>
        <td >n</td>
        <td >切换至下一窗口</td>
    </tr>
    <tr>
        <td >l</td>
        <td >在前后两个窗口间互相切换</td>
    </tr>
    <tr>
        <td >w</td>
        <td >通过窗口列表切换窗口</td>
    </tr>
    <tr>
        <td >,</td>
        <td >重命名当前窗口；这样便于识别</td>
    </tr>
    <tr>
        <td >.</td>
        <td >修改当前窗口编号；相当于窗口重新排序</td>
    </tr>
    <tr>
        <td >f</td>
        <td >快速定位到窗口（输入关键字匹配窗口名称）</td>
    </tr>
    <tr>
        <td rowspan="14">面板操作</td>
        <td >”</td>
        <td >将当前面板平分为上下两块</td>
    </tr>
    <tr>
        <td >%</td>
        <td >将当前面板平分为左右两块</td>
    </tr>
    <tr>
        <td >x</td>
        <td >关闭当前面板（关闭前需输入y or n确认）</td>
    </tr>
    <tr>
        <td >z</td>
        <td >最大化当前面板，再重复一次按键后恢复正常（v1.8版本新增）</td>
    </tr>
    <tr>
        <td >!</td>
        <td >将当前面板移动到新的窗口打开（原窗口中存在两个及以上面板有效）</td>
    </tr>
    <tr>
        <td >;</td>
        <td >切换到最后一次使用的面板</td>
    </tr>
    <tr>
        <td >q</td>
        <td >显示面板编号，在编号消失前输入对应的数字可切换到相应的面板</td>
    </tr>
    <tr>
        <td >{</td>
        <td >向前置换当前面板</td>
    </tr>
    <tr>
        <td >}</td>
        <td >向后置换当前面板</td>
    </tr>
    <tr>
        <td >o</td>
        <td >在当前窗口中选择下一面板</td>
    </tr>
    <tr>
        <td >方向键</td>
        <td >移动光标切换面板</td>
    </tr>
    <tr>
        <td >空格键</td>
        <td >在预置的面板布局中循环切换；依次包括even-horizontal、even-vertical、main-horizontal、main-vertical、tiled</td>
    </tr>
    <tr>
        <td >Alt+方向键</td>
        <td >以5个单元格为单位调整当前面板边缘</td>
    </tr>
    <tr>
        <td >Ctrl+方向键</td>
        <td >以1个单元格为单位调整当前面板边缘（Mac下被系统快捷键覆盖）</td>
    </tr>
</table>
<h2 id="Tricks">Tricks</h2>
<ul>
<li>为了让服务器一直跑进程，可以新建一个tmux页面，然后run <code>yes</code>.</li>
</ul>
<p>参考文献:</p>
<ul>
<li><a href="https://blog.csdn.net/hcx25909/article/details/7602935">tmux快捷键</a></li>
<li><a href="http://louiszhai.github.io/2017/09/30/tmux/#%E6%96%B0%E5%BB%BA%E4%BC%9A%E8%AF%9D">非常详细的tmux使用手册</a></li>
<li><a href="https://www.jianshu.com/p/f7f24b4b2625">非root用户源码安装Tmux</a></li>
<li><a href="https://www.cnblogs.com/bamanzi/p/tmux-mouse-tips.html">tmux启用鼠标</a></li>
<li><a href="http://lightcss.com/select-and-copy-with-mouse-in-tmux/">tmux启用鼠标选择复制功能</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>tech tool</tag>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>大开的脑洞brain storming</title>
    <url>/blog/2019/12/25/%E5%A4%A7%E5%BC%80%E7%9A%84%E8%84%91%E6%B4%9Ebrain-storming/</url>
    <content><![CDATA[<p>本文记录偶尔异想天开的想法、半夜梦到的情景、灵光乍现的瞬间、胡思乱想的一切、以及可能很冷的冷笑话。所以，请叫这篇blog，高氏论语，或者正言正语😃😃😃</p>
<span id="more"></span>
<h2 id="自己的感悟">自己的感悟</h2>
<ul>
<li>博二代的思考：为什么讲究子承父业，都在同一个圈子中（同样适用于其他行业）。</li>
<li>通过一个人的名字，能大概猜测他的年纪。比如”张美丽“大概率不是最近出生的孩子。能不能做一个NLP+CV的系统，输入一些人的基本文字信息，得到其画像？</li>
<li>和欧美法律一样，对于人生的思考，需要有几条明确的基本准则。剩下的太过复杂的东西，很难总结的尽善尽美。我们可以case by case的看。记住发生过什么事情，结果怎么样，然后作为自己以后为人处世的行为准则。</li>
<li>近朱者赤，近墨者黑。你生活的环境造就了你是什么样的人。当你觉得与身边人格格不入而并不觉得自己错的时候，你可能进错了圈子。</li>
<li>当你对一件事情并不了解时，请不要随便发表不负责任的看法。</li>
<li>peer presure 才是激励你不断进步的动力。</li>
<li>做一个“死也要死在江浙沪”的男人。</li>
<li>除了做好本职的data scientist工作外，part time 想做一个不知名的up主和只讲故事不谈道理的历史学家。目前，已经实现了一半，即”不知名“和”没道理“。</li>
<li>如果有机会，还想当个业余的铁匠和木匠，或者硬件工程师（改电路板和造机器人的那种）。好喜欢动手做东西的成就感。希望有一天能做出这个个人名片：<a href="https://zhuanlan.zhihu.com/p/99314698">https://zhuanlan.zhihu.com/p/99314698</a>.</li>
<li>以后我要买一个大房子，一间屋子做琴棋书画室，一间屋子做录音棚，里面要买个大电脑剪视频用。还要把车库的一部分改成木匠铁匠铺。哈哈哈，看来得买个300平的大house了。</li>
<li>告别惰性，保持警惕。人天性懒惰，切不可好吃懒做。人生在于折腾。积极向上，要有意识的打破自己的舒适圈。大多数的人到了一个阶段之后，就很难有决心和毅力再向上爬了。积极的态度和终身学习的思想境界，才是打破阶层的上升通道。</li>
<li>对别人的印象是一个贝叶斯过程。一开始不了解的时候，只能通过每个人的一些身份标签，来构造一个prior knowledge。然而当在相处之中，随着认识的加深，observation越来越多，因此能更大的影响到对于他人的posterior 印象分。所以，如果想成为一个好人，首先要把自己的身份标签弄弄好，然后在平时里也要好好表现。</li>
<li>人生座右铭：this is US, just do IT!</li>
<li>要以always Day 1 的心态，连续工作102年！</li>
<li>像牛一样赚钱，像狗一样活着。</li>
<li>要发明一种AI椅子，连着APP。只要在APP的家庭布局上面画一个圈，现实中椅子就会只待在那个圈里面不会转出去。这样省的椅子到处乱转了。有点像孙悟空给唐僧画的那个圈一样。</li>
<li>面对诸如种族/性别歧视时，最好的回复是：我尊重并理解你歧视我的原因，权利与自由，也希望你能尊重并理解我打你的原因，权利与自由。（当然前提是最好你能打得过它😃）</li>
<li>人的劣根性之一在于：被压迫的人，最后的终极理想，不是反抗，而是成为压迫者中的一员。</li>
<li>A:你想做我的什么？B:我想做你的手机啊！A:你是想让我每天把你捧在手里嘛？B: 不，这样我就能知道你所有的秘密啊！</li>
<li>以后要发明自动美发机。套在头上，自动给你洗剪吹染，你可以从面前的显示屏上看到你自己头发一点点的变化。</li>
<li>SNH48完全可以和德云社合作，组成男女混合搭配演节目。毕竟两者的运行模式有很多相似之处。</li>
<li>娱乐新闻搜索 是个有意思的research topic。比如我想搜snh48宿舍 模型可以关联到一些其他相关名词（snh48的宿舍叫生活中心）然后再根据新闻来源的可信度，发表时间啥的排序，生成一个重大事件编年表。遍年表上对应每个事件的summary，是根据相关新闻报道总结而成。然后每个事件下面对应相关新闻的ranking</li>
<li>以后的人类，要么就是能够进行记忆传承，比如把上一代的知识刻到DNA里面传给下一代，要么就和黑客帝国一样，插张光盘就能文能武了。这样造成的后果就是，厉害的人一代一代的会越来越厉害，贫穷的人会一代一代的被淘汰。直到最后，全世界就剩下了那个最优秀的人，他实在无聊了，就自己亲手造了一批人看他们玩。这个人，后人称之为女娲。</li>
<li>看青春有你2有感：选秀就是一个Gaussian Mixture Model. 所有的经纪公司都对选手的排名有不同的影响，相当于一个gaussian distribution（肯定都是照顾自己的公司选手），然后选手的总排名是所有distribution加权得到的结果。粉丝的投票相当于外部的反馈，可以用EM的方法来estimate每个公司在爱奇艺这里最终的影响程度。</li>
<li>如何提高做一件事情的效率？–发现有另外一件你更不想做的事情压着，得做。</li>
<li>知道为啥中国古代神话中神仙很少谈恋爱的吗？-- 因为idol之间不能恋爱。 知道为什么神仙和凡人不能谈恋爱的吗？ – 因为idol更不能和粉丝谈恋爱。</li>
<li>未来，一定会发明出一种连体泳衣，可以让人在水里，如履平地。</li>
<li>NLP多轮对话的一个application是创造虚拟女主播，还能根据收看观众的回复，自动筛选和回复评论。</li>
<li>Google Scholar这种网站应该新建一个personal library的服务。用户收藏里面的paper之后，到library服务中，可以跟购物网站一样，把paper 可以按照topic，venue之类的进行分类和filter.然后允许自己添加topic的keywords和写summary。这样的话，一定可以把 Mendeley这种软件直接淘汰掉。</li>
<li>看SNH48总选的鬼畜repo，我发现可以做一个鬼畜生成模型。首先每个小偶像之间的关系用knowledge graph来表示，再结合小偶像的发言文稿，根据不同音乐的beat用来生成鬼畜。</li>
<li>对于偶像来说，搞CP是聚变，CP BE是裂变。无论哪种，都能迸发出巨大能量。然而不同的是，聚变比裂变能量大，而CP BE 比搞CP能量大。</li>
<li>人生奋斗的意义，就是跟自己更多的选择机会。</li>
<li>追星，对于粉丝来说只是茶余饭后的消遣，对于偶像来说却是全部的事业。</li>
<li>可以用ASR &amp; NLP的deep learning models 来train宠物语言。</li>
</ul>
<h2 id="别人的段子">别人的段子</h2>
<ul>
<li>不思考，少烦恼。</li>
</ul>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>fun</tag>
      </tags>
  </entry>
  <entry>
    <title>录音修音</title>
    <url>/blog/2022/01/03/%E5%BD%95%E9%9F%B3%E4%BF%AE%E9%9F%B3/</url>
    <content><![CDATA[<p>本文记录自己学习Adobe Audition来录音修音时的一些笔记。</p>
<span id="more"></span>
<p>录音的工具：麦克风，声卡。<br>
录音软件：Adobe Audition (录音)， Melodyne (修音)。其中Melodyne提供插件可以直接在AU里面使用。</p>
<p>Adobe Audition 使用指南</p>
<ol>
<li><a href="https://helpx.adobe.com/cn/audition/get-started.html">开始使用Audition</a></li>
<li><a href="https://helpx.adobe.com/cn/audition/user-guide.html">用户指南</a></li>
<li><a href="https://helpx.adobe.com/cn/audition/tutorials.html">新手教程</a></li>
</ol>
<p>快捷键：</p>
<ol>
<li>M键是 Add Cue Marker 标记用。</li>
</ol>
<p>Tips:</p>
<ol>
<li>整体降噪。Effects -&gt; Noise Reduction / Restoration -&gt; Adaptive Noise Reduction. 然后在音频选区框出来要处理的音频部分。</li>
<li>去除口水音。Effects -&gt; Noise Reduction / Restoration -&gt; Adaptive Click Remover. 也可以用页面上方的消除工具 Spot healing bruch tool 来手动清除。</li>
<li>处理间音的问题。爆音和高频的撕声。选择问题区域或者高频区域，Effects -&gt; Noise Reduction / Restoration -&gt; Hiss Reduction (process)</li>
<li>调整单个句子音量大小，选中音频，使用页面上方的Time Seletion Tool, 调整音频区域出现的时钟图案的方向。逆时针转动是减少音量，顺时针转动增加音量。</li>
<li>修复人声中的杂音和剪辑不需要的音频。使用页面上方的Marques Selection Tool, Lasso Selection Tool 和 Paintbrush Selection Tool选则区域，然后用delete键删除。另外一种方式去掉杂音：点击选中区域，点击右键选择自动修复选区。</li>
<li>插入背景音乐，需要多轨混音。混音器可以在AU窗口栏中找到。</li>
<li>音乐中去掉人声，只保留伴奏。Effects -&gt; Stero Imagery -&gt; Center Channel Extractor 里面的Presets 选择Vocal Remove</li>
</ol>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>录音</tag>
      </tags>
  </entry>
  <entry>
    <title>安装并部署Hexo NexT主题博客</title>
    <url>/blog/2019/12/10/%E5%AE%89%E8%A3%85%E5%B9%B6%E9%83%A8%E7%BD%B2Hexo-Next%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo 本身是基于Nodejs的，非常便于主题的移植和扩展。Next作为近年来相当受欢迎的Hexo主题之一，被广泛的用作博客模板。本文介绍如何安装Hexo的NexT主题并且部署在Github Pages上面。完成之后，我们能够方便的在本地Markdown里面写博客，并且轻松部署到远程Github上面去。</p>
<span id="more"></span>
<h2 id="安装Hexo">安装Hexo</h2>
<h3 id="本地安装Hexo">本地安装Hexo</h3>
<p>作为Mac用户，当我们已经安装好Nodejs之后，安装Hexo 框架非常简单，只需要执行一下命令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h3 id="新建Hexo-project">新建Hexo project</h3>
<p>安装好Hexo之后，在terminal中run以下命令建立一个blog 文件夹，里面就是Hexo的整个project:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo init blog</span><br><span class="line">$ cd blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>新建完成后，指定文件夹blog 的目录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<p>这里面的_config.yml，是存在于Hexo 框架之中的，我们称之为<font color=red><strong>站点配置文件</strong></font>。里面的Site 部分内容，我们可以改一些类似language, title 之类的信息。</p>
<p>安装好之后，我们测试是否Hexo框架安装成功，可以部署一下当前的project。默认的Hexo 框架的主题叫做landscape。 通过run 以下命令可以生成静态的html 网页, 存储在blog/public目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>部署到本地服务器可以run 以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在浏览器地址栏中输入<a href="http://localhost:4000/">http://localhost:4000/</a> （默认端口是4000），如果能够看到看到正常网页，说明初始化的Hexo博客搭建成功了。如果出现端口被占用的错误，需要run：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsof -i :4000</span><br></pre></td></tr></table></figure>
<p>来找到对应的进程ID，然后kill 进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -9 pid</span><br></pre></td></tr></table></figure>
<h3 id="不同电脑间迁移">不同电脑间迁移</h3>
<p>如果需要在另外的电脑上继续编辑博客的话，需要重新进行一些设置。</p>
<ol>
<li>把自己博客的源代码复制到新的电脑中去。此处建议先把自己的博客源代码上传到github中（比如 <a href="https://github.com/RoyZhengGao/blog-source-code">https://github.com/RoyZhengGao/blog-source-code</a> ），然后在新的电脑上用git 命令把源代码clone下来。这样的话，本身的源代码中设置.gitignore文件，能把一些生成的文件过滤掉，而只保存核心的源文件。</li>
<li>在新的电脑中需要重新安装nodejs: <code>brew install node</code></li>
<li>重新安装hexo-cli插件：<code>npm install -g hexo-cli</code></li>
<li>把之前的安装需要的npm包再重新装一遍：<code>npm install hexo --save</code></li>
</ol>
<p>之后，在新的电脑上就可以继续写博客了！</p>
<h2 id="安装使用NexT主题">安装使用NexT主题</h2>
<h3 id="DIY-NexT主题">DIY NexT主题</h3>
<p>我们需要用我们自己选择的NexT主题，因此要把站点配置文件中的themes 改成NexT 主题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>同时，需要从Github上面下载主题对应的源代码，通过run以下命令就可以把对应的NexT源代码下载到博客文件夹blog 中/themes/ 里面:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd blog</span><br><span class="line">$ git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>进入next 文件夹，我们发现还存在一个同样叫做_config.yml 的配置文件，我们称之为<font color=red><strong>主题配置文件</strong></font>。我的博客是选用的Pisces 主题，因此需要选择对应的主题配置文件中的scheme 如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>
<h3 id="Side-bar-添加标签-分类">Side bar 添加标签/分类</h3>
<p>(1) 在side bar 中开启标签/分类选项。在主题配置文件 _config.yml中配置菜单按钮，找到menu属性，做以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  # about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  # schedule: /schedule/ || calendar</span><br><span class="line">  # sitemap: /sitemap.xml || sitemap</span><br><span class="line">  # commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure>
<p>(2) 执行命令<code>hexo s</code>，本地预览我们的博客页面，会发现，点击分类、标签这几个页面的时候，会显示404。我们需要在project的根目录下面新建对应的分类、标签的page文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>执行完后，我们可以在hexo/source目录下看到创建的2个文件夹，分别为tags和categories。<br>
(3) 两个文件夹中分别生成了一个 <a href="http://index.md">index.md</a> 初始文件，默认包含了 title 和 date 字段，我们需要给每一 <a href="http://index.md">index.md</a> 文件添加上 type 字段，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Categories</span><br><span class="line">date: 2019-12-10 16:21:55</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Tags</span><br><span class="line">date: 2019-12-10 16:20:43</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="Side-bar-添加本地搜索">Side bar 添加本地搜索</h3>
<p>(1) 安装hexo-generator-searchdb，在站点的根目录(blog 文件夹)下执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>(2) 编辑站点配置文件(blog/_config.yml)，新增以下内容到任意位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<p>(3) 编辑主题配置文件(blog/themes/next/_config.yml)，找到 local_search 属性，开启本地搜索功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>
<p>如果出现如下画面所示，表明本地搜索已经安装成功：<br>
<img src="local_search.png" alt="search" width="500"/></p>
<h3 id="新建post">新建post</h3>
<p>在Hexo project的文件夹blog 下面，run以下命令新建一个post:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;post&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在博客blog 目录下的/source/_posts/ 文件夹下，<a href="http://xn--post-uh5fupnvy4s5kem26ajlku4r793bzvfcu6azo5g.md">可以看到已经生成了标题为post.md</a> 的博客文件。在Markdown文件中直接写博客内容即可。<br>
<a href="http://xn--post-ft4g.md">在post.md</a> 文件中设置tags和categories属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: post</span><br><span class="line">date: 2019-12-15 11:11:11</span><br><span class="line">tags:</span><br><span class="line">- music           //多个标签可以这样添加</span><br><span class="line">- hexo</span><br><span class="line">categories: life //最好只写一个category，不然分类页页面会出现小问题</span><br></pre></td></tr></table></figure>
<p>为了添加阅读全文小按钮，可以在post中想要隐藏起来的部分开头加上以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>
<p>通过以下配置来在post中引入图片：<br>
(1) 在全局配置文件（hexo/_config.yml)中将post_asset_folder设置为true；<br>
(2) 创建文章（在创建的时候，会在hexo/source/_post目录下，生成一个XXX.md文件和一个XXX的文件夹）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;XXX&quot;</span><br></pre></td></tr></table></figure>
<p>(3) 把XXX这个博文需要展示的图片放在XXX文件夹目录下；<br>
(4) 在XXX.md文件中引入图片的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;search.png&quot; alt=&quot;search&quot; width=&quot;1200&quot;/&gt; </span><br></pre></td></tr></table></figure>
<h3 id="安装Valine-评论系统">安装Valine 评论系统</h3>
<p>通过对比gitment, hypercomments和Disqus，最终确定使用Valine 评论系统。<br>
(1) 注册 LeanCloud:<br>
Valine 是基于 LeanCloud 作为数据存储的，所以需要注册一个账号。注册完成后，进入控制台：</p>
<ul>
<li>创建一个应用，输入应用名称，选择 开发版，点击创建。</li>
<li>创建完成后，打开应用，左边的存储，查看 数据下面有没有 Counter 和 Comment 两个 Classes，如果没有，点击创建 Class。创建完成后，如下：<br>
<img src="comment1.png" alt="comment1" width="300"/></li>
</ul>
<p>(2) 如下图所示，点击“设置”，找到“安全中心”，在服务开关，除了“数据存储”，其它的全关掉，在 “Web 安全域名”，填写博客的域名地址：<br>
<img src="comment2.png" alt="comment2"/><br>
(3) 点击同一栏中的 “应用Keys”，获取到 “AppID” 和 “AppKey”。<br>
(4) 搜索 valine ，配置 appid 和 appkey 为 LeanCloud 分配的值，language默认为中文（zh-cn）并且实际上并不能支持英文（en）。<br>
(5) 修改 valine.min.js 的 cdn 文件地址，到这里 <a href="https://www.jsdelivr.com/package/npm/valine">https://www.jsdelivr.com/package/npm/valine</a> 这个地址选择最新版本的Valine，然后获取cdn地址，修改到 主题配置文件 _config.yml 即可。如下图所示：<br>
<img src="comment3.png" alt="comment3" width="600"/><br>
_conig.yml 文件修改的位置：<br>
<img src="comment4.png" alt="comment4" width="600"/><br>
部署完成后，即可无需登录即可发表评论，如图所示：<br>
<img src="comment5.png" alt="comment5"/><br>
(6) 删除评论只能在LeanCloud 中进行。点击“存储”，进入“结构化数据”中的“Comment” 表格，就可以看到相对应的评论数据。点击相关数据可以进行删除。具体见下图：<br>
<img src="comment6.png" alt="comment6"/></p>
<h3 id="启用emoji">启用emoji</h3>
<p>将 markdown 变成 html 的转换器叫做markdown渲染器 。 Hexo默认是采用hexo-renderer-marked,这个渲染器不支持插件扩展，当然就不行了，还有一个支持插件扩展的是 hexo-renderer-markdown-it，这个支持插件配置，可以使用markwon-it-emoji 插件来支持emoji。需要将原来的 marked 渲染器换成 markdown-it渲染器。所以我们可以使用这个渲染引擎来支持emoji表情。<br>
(1) 首先进入博客目录，卸载hexo默认的marked渲染器，安装markdown-it渲染器，运行的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm un hexo-renderer-marked --save</span><br><span class="line">$ npm i hexo-renderer-markdown-it --save</span><br></pre></td></tr></table></figure>
<p>(2) 然后安装 markdown-it-emoji 插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install markdown-it-emoji --save</span><br></pre></td></tr></table></figure>
<p>(3) 编辑站点配置文件，在末尾添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Markdown-it config</span><br><span class="line">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span><br><span class="line">markdown:</span><br><span class="line">  render:</span><br><span class="line">    html: true</span><br><span class="line">    xhtmlOut: false</span><br><span class="line">    breaks: true</span><br><span class="line">    linkify: true</span><br><span class="line">    typographer: true</span><br><span class="line">    quotes: &#x27;“”‘’&#x27;</span><br><span class="line">  plugins:</span><br><span class="line">    - markdown-it-abbr</span><br><span class="line">    - markdown-it-footnote</span><br><span class="line">    - markdown-it-ins</span><br><span class="line">    - markdown-it-sub</span><br><span class="line">    - markdown-it-sup</span><br><span class="line">    - markdown-it-emoji  ## add emoji</span><br><span class="line">  anchors:</span><br><span class="line">    level: 2</span><br><span class="line">    collisionSuffix: &#x27;v&#x27;</span><br><span class="line">    # If `true`, creates an anchor tag with a permalink besides the heading.</span><br><span class="line">    permalink: false  </span><br><span class="line">    permalinkClass: header-anchor</span><br><span class="line">    # The symbol used to make the permalink</span><br><span class="line">    permalinkSymbol: ¶</span><br></pre></td></tr></table></figure>
<h3 id="添加阅读时长">添加阅读时长</h3>
<p>新版的NexT模板弃用了以前的<code>post_wordcount</code>统计文章的字数，阅读时长等等，新版本该插件废弃，并且内置了<code>symbols_count_time</code>作为替换。具体可见<a href="https://github.com/theme-next/hexo-symbols-count-time">安装配置</a>。<br>
(1)安装插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time</span><br></pre></td></tr></table></figure>
<p>(2)主题配置文件中，已经有对应阅读时长，统计字数的参数设定，可以查看下是否已经存在。如果是中文的博客的话，建议<code>awl=2</code>并且<code>wpm=300</code>。英文的话，为<code>awl=4</code>并且<code>wpm=275</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: false</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure>
<p>(3)在主题配置文件中加上以下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br><span class="line">  exclude_codeblock: false</span><br></pre></td></tr></table></figure>
<h3 id="编辑数学公式">编辑数学公式</h3>
<p>(1) 更换markdown渲染引擎，由marked改为更为轻量级的kramed：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p>你可以在/node_modules里面搜索一下你是否安装了这两个插件（注意：不要安装pandoc插件，如果有，请卸载，此插件兼容性不太好，经常导致报错）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure>
<p>(2) 找到/node_modules/kramed/lib/rules/inline.js把第11行的escape变量的值做相应的修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span><br><span class="line">escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</span><br></pre></td></tr></table></figure>
<p>这一步是在原基础上取消了对,{,}的转义(escape)。同时把第20行的em变量也要做相应的修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br><span class="line">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span><br></pre></td></tr></table></figure>
<p>(3) 打开Mathjax开关，在/theme/next/_config.yml 中把enable改为true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">enable: true</span><br><span class="line">per_page: true</span><br></pre></td></tr></table></figure>
<p>(4) 在文章开头设置mathjax开关，只有需要编辑数学公式的文章页面才加载mathjax渲染，这样不需要渲染数学公式也不会影响加载速度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: xxxx</span><br><span class="line">date: 2018-02-01 16:22:31</span><br><span class="line">tags: xxxxx</span><br><span class="line">mathjax: true</span><br></pre></td></tr></table></figure>
<p>假如你不想每篇文章都手动打上mathjax: true，那么你可以在/scaffolds/post.md中修改，添加上mathjax这一项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>这样你每次写博客时Front-matter都会有这一项(实际上我们修改的就是博客Front-matter的模板)<br>
(5) 显示数学公式序号。我们经常需要对行间公式编序号，这样会方便我们的语言叙述(可能是习惯于LATEX），要在我们博客上显示序号，只需要在/theme/next/layout/_third-party/mathjax.swig中加上下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;</span><br><span class="line">      MathJax.Hub.Config(&#123;</span><br><span class="line">        TeX: &#123; equationNumbers: &#123; autoNumber: &quot;AMS&quot; &#125; &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>然后在markdown的tex公式编辑里面只要使用equation环境的公式就会被编号（两个$符号的简单公式不会有编号）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;equation&#125; # 此标签如果替换成$$的话 不会有编号</span><br><span class="line">a_2=\sum^&#123;3k&#125;</span><br><span class="line">\end&#123;equation&#125; # 此标签如果替换成$$的话 不会有编号</span><br></pre></td></tr></table></figure>
<p>显示结果如图：<br>
<img src="formula.png" alt="formula" width="500"/><br>
对于其他的存在于文字内的数学公式来说，需要用两个$$之内即可。比如$a^2$:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$a^2$</span><br></pre></td></tr></table></figure>
<p>对于多行公式来说，\begin{equation} 不适用，此时需要改回两个$符号（不知道为什么原因）。但是，如果公式如下的话，会导致所有公式内容放在一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;align&#125;</span><br><span class="line">x &amp;= a +b+c+d \\</span><br><span class="line"> &amp;= e +f \\</span><br><span class="line"> &amp;= g</span><br><span class="line">\end&#123;align&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>显示结果如图：<br>
<img src="multiline-formula.png" alt="multiline-formula" width="500"/><br>
可以看到，换行并未起作用，这是因为 Hexo 对 Markdown 文件的处理实际上分为两个步骤：</p>
<ul>
<li>Hexo 中的 Markdown 引擎把 Markdown 变为 html 文件</li>
<li>MathJax 负责解释 html 的数学公式</li>
</ul>
<p>第一步中，由于 backslash 在 Markdown 属于特殊字符，用于字符转义，所以两个 backslash 经过 Markdown 引擎处理，只剩下一个，等到 MathJax 引擎处理时，实际上 MathJax 只看到一个 backslash，MathJax 把它当作 LaTeX 中的空格，因此我们见到了上图所示的渲染结果。<br>
知道了渲染错误的原因，解决办法也很简单，就是用四个 backslash 代替两个 backslash，确保 MathJax 的引擎看到的是两个 backslash。同时align 标签本身提供公式编号，如果不想加编号的话，我们可换成aligned 标签。也就是把上述代码变成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">x &amp;= a +b+c+d \\\\</span><br><span class="line"> &amp;= e +f \\\\</span><br><span class="line"> &amp;= g</span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>显示结果如图：<br>
<img src="indexed-formula.png" alt="indexed-formula" width="200"/></p>
<h2 id="部署到Github-Pages">部署到Github Pages</h2>
<p>(1) 新建一个仓库，仓库名为 <a href="http://RoyZhengGao.github.io">RoyZhengGao.github.io</a>（这个仓库的名称必须严格按照 <a href="http://username.github.io">username.github.io</a> 的格式来命名）。点击刚创建好的那个仓库(进去仓库里面），点击settings，找到Github Pages 选项，选择Source 选项，默认是master branch。这样Github Pages的默认路径就是<a href="http://RoyZhengGao.github.io">http://RoyZhengGao.github.io</a>。<br>
本文默认本地机器已经装好git 并且已经配置连接好对应的Github账号。<br>
(2) 修改站点配置文件。在blog文件夹下，找到_config.yml文件，修改里面的deploy属性(目的是将本地blog项目放到Github上)。注：【如果repository中填写的是https协议的，<code>hexo d </code>上传代码到Github时有下面类似错误，推荐将repository改为ssh的链接】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:RoyZhengGao/RoyZhengGao.github.io.git</span><br><span class="line">  # example: git@github.com:RoyZhengGao/RoyZhengGao.github.io.git</span><br><span class="line">  # example, https://github.com/hexojs/hexojs.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>(3) 安装hexo-deployer-git 插件，目的是将代码快速托管到Github上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(4) 将blog项目托管到Github上:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean // 清除缓存文件 (db.json) 和已生成的静态文件 (public)</span><br><span class="line">hexo generate // 部署之前预先生成静态文件，简写为hexo g</span><br><span class="line">hexo deploy // 上传生成的静态文件，立即部署网站，简写为hexo d</span><br></pre></td></tr></table></figure>
<h3 id="Github-创建多个博客">Github 创建多个博客</h3>
<p>如果仓库名username.github.io已经被别的repository 占用，为了创建新的博客，我们可以在Github上面随便创立一个repository，比如创立一个叫做blog的repository。此时，需要改动上传Github 的路径到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:RoyZhengGao/blog.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>同时，如果博客网站存放在子目录中，例如 <a href="http://yoursite.com/blog%EF%BC%8C%E5%88%99%E8%AF%B7%E5%B0%86%E7%AB%99%E7%82%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84">http://yoursite.com/blog，则请将站点配置文件中的</a> url 设为 <a href="http://yoursite.com/blog">http://yoursite.com/blog</a> 并把root 设为 /blog/。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: http://yoursite.com/blog</span><br><span class="line">root: /blog/</span><br></pre></td></tr></table></figure>
<p>其余部署步骤和普通方式部署博客的步骤一致。最终，博客网址将会是<a href="http://RoyZhengGao.github.io/blog/%E3%80%82">http://RoyZhengGao.github.io/blog/。</a></p>
<h2 id="常见问题">常见问题</h2>
<ul>
<li>Q: 如何更改post中的字体大小？<br>
A: 在NexT.Pisces v7.6.0的版本中，目前没有找到正确的方法来只改变post的字体大小。<a href="https://theme-next.iissnan.com/theme-settings.html#fonts-customization">相关文档1</a>和<a href="https://theme-next.iissnan.com/faqs.html#custom-font">相关文档2</a>虽然有进行说明，但是并不能正确改正。目前的感觉是应该改主题配置文件_config.yml中的font部分以及主题对应的style文件 /themes/next/source/css/_variables/base.styl. 仍需要进一步研究。<br>
查看source code 后发现，其字体比较大的原因是由生成的main.css中以下代码控制的。当把页面缩小到1200px以下之后，font size自动缩回为1em。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@media (min-width: 1200px)</span><br><span class="line">.post-body &#123;</span><br><span class="line">    font-size: 1.125em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
补充：最终发现其原因在于<code>source/css/_common/components/post/post.styl </code>中的如下代码：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+desktop-large() &#123;</span><br><span class="line">  font-size: $font-size-large;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
即当页面大于1200px时，自动把font size 转化为large的size。改动其为<code>font-size: $font-size-base</code>即可。参考issue可见<a href="https://github.com/theme-next/hexo-theme-next/issues/1165">https://github.com/theme-next/hexo-theme-next/issues/1165</a>。</li>
</ul>
<p>参考文献：</p>
<ul>
<li><a href="https://hexo.io/zh-cn/">Hexo官方文档</a></li>
<li><a href="https://www.jianshu.com/p/84a8384be1ae">Hexo使用指南</a></li>
<li><a href="https://winney07.github.io/2018/08/02/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/">在Hexo博客中发布文章</a></li>
<li><a href="https://winney07.github.io/2018/08/01/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%B8%BANexT%E4%B8%BB%E9%A2%98/">将Hexo博客主题更换为NexT主题</a></li>
<li><a href="https://theme-next.iissnan.com/">NexT主题使用文档</a></li>
<li><a href="https://theme-next.iissnan.com/third-party-services.html">第三方插件安装</a></li>
<li><a href="https://github.com/theme-next/hexo-theme-next">NexT主题对应源代码</a></li>
<li><a href="https://www.youtube.com/watch?v=HLJ9jJy7CMg">Hexo YouTube教学视频</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLmZFYB4M42szT_wcKC2GYe5Iviql-2sBr">NexT 主题YouTube教学视频</a></li>
<li><a href="https://yuanmomo.net/2019/06/20/hexo-add-valine/">添加Valine评论系统</a></li>
<li><a href="https://chaxiaoniu.oschina.io/2017/07/10/HexoAddEmoji/">Hexo启用emoji</a></li>
<li><a href="https://linbaijiong.github.io/2018/02/07/Hexo%E4%B8%8BNext%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96-%E4%B8%80-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E6%B8%B2%E6%9F%93/">Hexo启用数学公式</a></li>
<li><a href="https://jdhao.github.io/2017/10/06/hexo-markdown-latex-equation/">解决Mathjax中的多行公式问题</a></li>
<li><a href="https://io-oi.me/tech/hexo-next-optimization/">hexo NexT个性化设置</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>front end</tag>
        <tag>tech tool</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影技巧</title>
    <url>/blog/2019/12/25/%E6%91%84%E5%BD%B1%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>如何用手机拍出好看的照片？本文整理参考了一些网上的博客和视频，来总结一些小的tips。同时也介绍了几款比较好的APP在手机上直接进行后期处理。一些通用的图像处理和视频剪辑软件也会在这里简单介绍。希望能够对自己以后审美有所帮助。</p>
<span id="more"></span>
<h2 id="手机摄影技巧">手机摄影技巧</h2>
<p>自己个人觉得，拍摄的时候需要考虑的因素是：构图，线条，光线，色彩搭配，景深。</p>
<h3 id="摄影技巧">摄影技巧</h3>
<ul>
<li>引导线，找到对应的角度，前中后，景就会有故事。</li>
<li>靠近拍，很多事物靠近拍可以发现其细节的美。</li>
<li>低潮，从低角度拍上去。有时候可能要蹲着或者躺着拍，或者用pano模式竖过来拍。</li>
<li>对称，对直。构图上对称的话就会好看。</li>
<li>九宫格的构图，可以把物品放在右下角，左下角之类的位置。</li>
<li>keep in simple，越简单越好。这样整体的图片会比较干净。</li>
<li>影子。阳光射下来找出的影子，会对图片有意境上面的加成。</li>
<li>剪影。自己或者主物体是暗的或者黑的，是为了体现出背景的颜色。</li>
<li>反射，比如照镜子，或者根据倒影来拍摄。</li>
</ul>
<h3 id="构图">构图</h3>
<ul>
<li>黄金分割法。0.618的神秘分割法。可以简化成三分法，九宫格。比如拍摄人像不知道把人物放到什么位置的时候，黄金分割法是最稳妥的布局。</li>
<li>点构图。人物在画面里的比例很小，强调环境与人物的和谐统一。适用于场景视野开阔，画面干净没有过多杂物的环境。</li>
<li>对角线构图。特别适用于静态风光照片。大面积的草坪，有道路的自然风景等。</li>
<li>中心对称构图。为了追求画面平衡对称。适用于人物特写，突出神态，饱满构图。有倒影的画面，有弧度的线条横穿画面时，使用中心对称构图，让画面聚焦中心点。</li>
<li>三角形构图。把物品摆放成三角状。拍人物的时候，可以利用人的手或者身体达到三角形的感觉。这样使得构图饱满并且平衡。</li>
<li>引导线构图。是有方向，具有延伸和引导的线条。汇聚线是最常见的，比如公路。使得视线汇聚到画面的焦点。</li>
<li>重复线条构图。利用画面中规律排列的物体进行构图，让照片充满工整与秩序感。</li>
<li>开放式构图/封闭式构图。封闭式构图讲究画面完整，主题在画面之中，构图较完整。开放式构图主体不一定在画中心，注意主体与画外的联系，在画面周围留下被切割的不完整形象，引发想象力。比如人物拍摄半张脸。</li>
<li>前景虚化构图。利用花草树木等物品作为前景，用大光圈拍摄虚化前景，制造梦幻，神秘的画面。</li>
</ul>
<h3 id="如何拍摄虚化背景">如何拍摄虚化背景</h3>
<ul>
<li>靠近点拍。</li>
<li>让被摄物体离背景远一些。</li>
<li>长焦距可以得到更好的虚化效果（一般手机得外接镜头）。</li>
<li>使用具有大光圈功能的手机。</li>
<li>双镜头手机可以得到更好的景深效果。</li>
<li>我们可以通过手机app进行后期处理。</li>
</ul>
<h3 id="手机处理APP">手机处理APP</h3>
<ul>
<li>Snapseed（修图）</li>
<li>VUE（视频剪辑）</li>
<li>ProCam（拍照APP，付费软件，可以在淘宝上买到很便宜的下载方法）</li>
<li>DJI Mimo（大疆的软件，主要服务于自己产品，也有一些视频剪辑和图片处理功能）</li>
</ul>
<h2 id="摄影运镜和转场技巧">摄影运镜和转场技巧</h2>
<p>在拍摄视频的时候，如何巧妙的设计角度能够极大地提升视频的趣味性。</p>
<ul>
<li>利用好前景过渡，比如路边的树木，墙面作为遮罩物</li>
<li>利用特别的拍摄角度，比如将视角降低，贴地面拍摄</li>
<li>多维度方向运动，比如后退+抬升角度拍摄，贴地+环绕拍摄，贴地向前锁定特写，环绕POV拍摄，360度转动拍摄</li>
<li>创意玩法，比如滑动变焦（拍摄一段向前移动的画面，后期再进行逐渐缩小的操作，适合于画面有明显纵深关系的场景）</li>
<li>一镜到底</li>
<li>相机转场，向左/右/上/下边晃动，</li>
<li>延时摄影</li>
<li>画面和音乐的节奏配合</li>
<li>斜向跟踪并锁定人物</li>
<li>4秒镜头拍一个事物</li>
</ul>
<h2 id="后期处理软件">后期处理软件</h2>
<p>后期处理的软件有很多，最推荐还是Adobe系列，因为拥有一系列的软件可供参考。</p>
<h3 id="Photoshop-PS">Photoshop(PS)</h3>
<p>图片处理软件，专业修图用。简单款的可以用Photoshop Elements这个软件。</p>
<h3 id="Adobe-illustrator-Ai">Adobe illustrator(Ai)</h3>
<p>专业矢量图绘制软件。可以用于专业印刷。</p>
<h3 id="Premiere-Pr">Premiere(Pr)</h3>
<p>视频剪辑软件，做up主必备。简单款可以用Premiere Elements这个软件。</p>
<h3 id="Adobe-effects-Ae">Adobe effects(Ae)</h3>
<p>动画设计软件。师Premiere的进阶。Premiere提供方便上手的视频剪辑功能，而Ae可以做动画特效。</p>
<h3 id="特效">特效</h3>
<ul>
<li>时空倒退</li>
</ul>
<h2 id="新手相机介绍">新手相机介绍</h2>
<ul>
<li>作为新手vlogger,最推荐的一开始还是用自己的手机。毕竟现在手机拍照和摄影功能都很强大。其中首推华为和iphone。</li>
<li>普通卡片机也可以作为入门机型。</li>
<li>微单和单反相机，成像效果好。</li>
<li>运动相机，比如GoPro和DJI。</li>
</ul>
<h2 id="经典教程">经典教程</h2>
<ul>
<li>美国纽约学院摄影教材</li>
<li>纽约摄影学院教程</li>
<li>完美摄影161法则</li>
</ul>
<p>参考文献:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=E-MaxW1Js9s">9个手机拍摄技巧-瞬间让你的照片提升另一个境界</a></li>
<li><a href="https://www.youtube.com/watch?v=pCU5YkF_whs">手机拍照之9条万能好用构图法则</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34902641">ProCam使用教程</a></li>
<li><a href="https://www.bilibili.com/video/BV197411w76H">Snapseed视频教程</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/45143350">Snapseed知乎教程</a></li>
<li><a href="https://www.bilibili.com/video/av64374273/">VUE视频教程</a></li>
<li><a href="https://www.xiaohongshu.com/discovery/item/5c0e7228000000000900b21b">VUE的tips</a></li>
<li><a href="https://www.jianshu.com/p/a66c1b519177">VUE迅速入门教程</a></li>
<li><a href="https://www.youtube.com/watch?v=p44ZVKLD1cE">DJI Mimo使用教程1</a></li>
<li><a href="https://camerajabber.com/how-to-edit-dji-osmo-pocket-video-on-your-mobile/">DJI Mimo使用教程2</a></li>
<li><a href="https://store.dji.com/guides/beginners-guide-to-osmo-mobile-3/">大疆云台Osmo Mobile 3使用教程</a></li>
<li><a href="https://dl.djicdn.com/downloads/Osmo_Mobile_3/Osmo_Mobile_3_User_Manual_v1.0_en.pdf">大疆云台Osmo Mobile 3 user manual</a></li>
<li><a href="https://www.bilibili.com/video/BV187411Z7bx">PS教程1</a></li>
<li><a href="https://www.bilibili.com/video/BV1A4411M729">PS教程2</a></li>
<li><a href="https://www.bilibili.com/video/BV1ox411f7tA">Ai教程1</a></li>
<li><a href="https://www.bilibili.com/video/BV1JC4y1s7NR">Ai教程2</a></li>
<li><a href="https://www.bilibili.com/video/BV1ut411S7j7">Pr教程1</a></li>
<li><a href="https://www.bilibili.com/video/BV1bb411F7Sh">Pr教程2</a></li>
<li><a href="https://www.bilibili.com/video/BV1At411i7yZ">Ae教程</a></li>
</ul>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>photography</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell Script 学习总结 </title>
    <url>/blog/2019/12/16/Shell-Script-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Shell脚本是计算机运行中必不可少的一种脚本语言。应用shell 能够和计算机内核进行交互，同时也能自动化运行所需要运行的程序，还可以快速的进行一些文件的查询功能。因此熟练掌握shell是作为程序员不可缺少的一部分技能。本文整理了一些普通日常中常用的shell 命令。同时也区分了一些容易混淆的shell相关的概念。</p>
<span id="more"></span>
<h2 id="Linux各种系统和Unix">Linux各种系统和Unix</h2>
<p>UNIX是一个功能强大、性能全面的多用户、多任务操作系统，可以应用从巨型计算机到普通PC机等多种不同的平台上，是应用面最广、影响力最大的操作系统。Linux是一种外观和性能与UNIX相同或更好的操作系统，但，Linux不源于任何版本的UNIX的源代码，并不是UNIX，而是一个类似于UNIX的产品。<br>
Unix是大型机系统，内核是保密的。而Linux是微型机系统，内核是公开的。</p>
<h2 id="Shell介绍">Shell介绍</h2>
<p>Windows、Mac OS、Android 等操作系统都由一家公司开发，所有的核心软件和基础库都由一家公司做决定，容易形成统一的标准，一般不会开发多款功能类似的软件。而 Linux不一样，它是“万国牌”，由多个组织机构开发，不同的组织机构为了发展自己的 Linux 分支可能会开发出功能类似的软件，它们各有优缺点，用户可以自由选择。Shell 就是这样的一款软件，不同的组织机构开发了不同的 Shell，它们各有所长，有的占用资源少，有的支持高级编程功能，有的兼容性好，有的重视用户体验。</p>
<p>Linux有非常多的发行版本，从性质上划分，大体分为由商业公司维护的商业版本与由开源社区维护的免费发行版本。商业版本以Redhat为代表，开源社区版本则以Debian为代表（主要包括CentOS、Ubuntu、Debian）。</p>
<h3 id="几种常见的Shell">几种常见的Shell</h3>
<p>常见的 Shell 有 sh、bash、csh、tcsh、ash 等。</p>
<ul>
<li>sh: 全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。sh 是 UNIX 上的标准 shell，很多 UNIX 版本都配有 sh。sh 是第一个流行的 Shell。</li>
<li>csh: 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。Bill Joy 是一个风云人物，他创立了 BSD 操作系统，开发了 vi 编辑器，还是 Sun 公司的创始人之一。</li>
<li>tcsh: 是 csh 的增强版，加入了命令补全功能，提供了更加强大的语法支持。</li>
<li>ash: 一个简单的轻量级的 Shell，占用资源少，适合运行于低内存环境，但是与下面讲到的 bash shell 完全兼容。</li>
<li>bash: bash 由 GNU 组织开发，保持了对 sh shell 的兼容性，是各种 Linux 发行版默认配置的 shell。</li>
</ul>
<h3 id="查看Shell">查看Shell</h3>
<p>Shell 是一个程序，一般都是放在<code>/bin</code>或者<code>/user/bin</code>目录下，当前 Linux 系统可用的 Shell 都记录在<code>/etc/shells</code>文件中。<code>/etc/shells</code>是一个纯文本文件，你可以在图形界面下打开它，也可以使用 cat 命令查看它。</p>
<p>通过 cat 命令来查看当前 Linux 系统的可用 Shell：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /etc/shells</span><br><span class="line"># List of acceptable shells for chpass(1).</span><br><span class="line"># Ftpd will not allow users to connect who are not using</span><br><span class="line"># one of these shells.</span><br><span class="line"></span><br><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure>
<p>如果你希望查看当前 Linux 的默认 Shell，那么可以输出 SHELL 环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $SHELL</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
<p>输出结果表明默认的 Shell 是 bash。</p>
<h3 id="bashrc和-bash-profile">~/.bashrc和~/.bash_profile</h3>
<ul>
<li><code>/etc/profile</code> 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置。</li>
<li><code>/etc/bashrc</code> 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取。</li>
<li><code>~/.bash_profile</code> 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次! 默认情况下,他设置一些环境变量,执行用户的.bashrc文件。</li>
<li><code>~/.bashrc</code> 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。</li>
</ul>
<p>为了在terminal读取 <code>.bash_profile</code>文件后就会load <code>.bashrc</code>文件中的内容，可以将一下内容加到<code>.bash_profile</code>文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ -f ~/.bashrc ]; then</span><br><span class="line">   source ~/.bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h3 id="brew-rpm-yum和apt-get的关系">brew,rpm,yum和apt-get的关系</h3>
<p>apt-get属于ubuntu、Debian的包管理工具，yum则属于Redhat、Centos包管理工具。rpm是由红帽公司开发的软件包管理方式，使用rpm我们可以方便的进行软件的安装、查询、卸载、升级等工作。但是rpm软件包之间的依赖性问题往往会很繁琐,尤其是软件由多个rpm包组成时。rpm 只能安装已经下载到本地机器上的rpm 包. yum能在线下载并安装rpm包,能更新系统,且还能自动处理包与包之间的依赖问题,这个是rpm 工具所不具备的。    Homebrew简称brew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，可以说Homebrew就是mac下的apt-get、yum神器。</p>
<h2 id="Shell编程基础">Shell编程基础</h2>
<h3 id="解释器">解释器</h3>
<p>脚本的第一行有<code>#!/bin/bash</code>或者是其他的解释器，如<code>#!/bin/csh</code>，执行该脚本时系统会使用该注明的解释器来解释。运行Shell有两种方式:</p>
<ul>
<li>作为可执行程序  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x test.sh</span><br><span class="line">./test.sh</span><br></pre></td></tr></table></figure>
</li>
<li>作为解释器参数<br>
这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。如：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/sh test.sh</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="变量">变量</h3>
<ul>
<li>
<p>定义变量时，变量名不加美元符号（$），如：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">your_name=&quot;zheng&quot;</span><br></pre></td></tr></table></figure>
<p>注意，变量名和等号之间不能有空格。除了显式地直接赋值，还可以用语句给变量赋值，如：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for file in `ls /etc`</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用变量。使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">your_name=&quot;zheng&quot;</span><br><span class="line">echo $your_name</span><br><span class="line">echo $&#123;your_name&#125;</span><br></pre></td></tr></table></figure>
<p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for skill in Ada Coffe Action Java; do</span><br><span class="line">    echo &quot;I am good at $&#123;skill&#125;Script&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重定义变量。已定义的变量，可以被重新定义，如：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">your_name=&quot;zheng&quot;</span><br><span class="line">echo $your_name</span><br><span class="line"></span><br><span class="line">your_name=&quot;alibaba&quot;</span><br><span class="line">echo $your_name</span><br></pre></td></tr></table></figure>
<p>这样写是合法的，但注意，第二次赋值的时候不能写$your_name=“alibaba”，使用变量的时候才加美元符。以单引号’ '包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。</p>
</li>
</ul>
<h3 id="特殊变量">特殊变量</h3>
<ul>
<li>$$: 表示当前Shell进程的ID，即pid：<code>echo $$</code></li>
<li>$0: 当前脚本的文件名</li>
<li>$n: 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。</li>
<li>$#: 传递给脚本或函数的参数个数。</li>
<li>$*: 传递给脚本或函数的所有参数。</li>
<li>$@: 传递给脚本或函数的所有参数。被双引号(&quot; “)包含时，与 $* 稍有不同，$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(” “)包含时，都以”$1&quot; “$2” … “$n” 的形式输出所有参数。但是当它们被双引号(&quot; “)包含时，”$*&quot; 会将所有的参数作为一个整体，以&quot;$1 $2 … $n&quot;的形式输出所有参数；“$@” 会将各个参数分开，以&quot;$1&quot; “$2” … “$n” 的形式输出所有参数。</li>
<li>$?: 上个命令的退出状态，或函数的返回值。</li>
</ul>
<h3 id="将命令的结果赋值给变量">将命令的结果赋值给变量</h3>
<p>Shell 也支持将命令的执行结果赋值给变量，常见的有以下两种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">variable=`command`</span><br><span class="line">variable=$(command)</span><br></pre></td></tr></table></figure>
<p>第一种方式把命令用反引号包围起来，反引号和单引号非常相似，容易产生混淆，所以不推荐使用这种方式；第二种方式把命令用$()包围起来，区分更加明显，所以推荐使用这种方式。</p>
<h3 id="变量替换">变量替换</h3>
<p>变量替换可以根据变量的状态（是否为空、是否定义等）来改变它的值.</p>
<ul>
<li>${var}: 变量本来的值</li>
<li>${var:-word}: 如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。</li>
<li>${var:=word}: 如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。</li>
<li>${var:?message}: 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。<br>
若此替换出现在Shell脚本中，那么脚本将停止运行。</li>
<li>${var:+word}: 如果变量 var 被定义，那么返回 word，但不改变 var 的值。</li>
</ul>
<h3 id="注释">注释</h3>
<p>以“#”开头的行就是注释，会被解释器忽略。sh里没有多行注释，只能每一行加一个#号。</p>
<h3 id="字符串">字符串</h3>
<ul>
<li>单引号
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</li>
<li>单引号字串中不能出现单引号（对单引号使用转义符后也不行）</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str=&#x27;this is a string&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li>双引号
<ul>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">your_name=&#x27;zheng&#x27;</span><br><span class="line">str=&quot;Hello, I know your are \&quot;$your_name\&quot;! \n&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>字符串操作
<ul>
<li>拼接字符串</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">your_name=&quot;qinjx&quot;</span><br><span class="line">greeting=&quot;hello, &quot;$your_name&quot; .&quot;</span><br><span class="line">greeting_1=&quot;hello, $&#123;your_name&#125; .&quot;</span><br><span class="line">echo $greeting $greeting_1</span><br></pre></td></tr></table></figure>
<ul>
<li>获取字符串长度</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string=&quot;abcd&quot;</span><br><span class="line">echo $&#123;#string&#125; #输出：4</span><br></pre></td></tr></table></figure>
<ul>
<li>提取子字符串</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string=&quot;alibaba is a great company&quot;</span><br><span class="line">echo $&#123;string:1:4&#125; #输出：liba</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组">数组</h3>
<p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似与C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。<br>
在Shell中，用括号来表示数组，数组元素用“空格”符号分割开。定义数组的一般形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array_name=(value1 ... valuen)</span><br></pre></td></tr></table></figure>
<p>读取数组元素值的一般格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;array_name[index]&#125;</span><br></pre></td></tr></table></figure>
<p>使用@ 或 * 可以获取数组中的所有元素，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;array_name[*]&#125;</span><br><span class="line">$&#123;array_name[@]&#125;</span><br></pre></td></tr></table></figure>
<p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 取得数组元素的个数</span><br><span class="line">length=$&#123;#array_name[@]&#125;</span><br><span class="line"># 或者</span><br><span class="line">length=$&#123;#array_name[*]&#125;</span><br><span class="line"># 取得数组单个元素的长度</span><br><span class="line">lengthn=$&#123;#array_name[n]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运算符">运算符</h3>
<ul>
<li><strong>算术运算符</strong>：原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。expr 是一款表达式计算工具，使用它能完成表达式的求值操作。需要注意的是，表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。此外，完整的表达式要被 `` 包含。乘号(*)前边必须加反斜杠(\)才能实现乘法运算。e.g. 我们定义两个变量<code>a=10, b=20</code>:<br>
<img src="math.png" alt="math"/></li>
<li><strong>关系运算符</strong>：关系运算符只支持数字，不支持字符串，除非字符串的值是数字。e.g. 我们定义两个变量<code>a=10, b=20</code>:<br>
<img src="relation.png" alt="relation"/></li>
<li><strong>布尔运算符</strong>：返回true/false。e.g. 我们定义两个变量<code>a=10, b=20</code>:<br>
<img src="boolean.png" alt="boolean"/></li>
<li><strong>逻辑运算符</strong>：与布尔运算符基本类似，返回true/false。e.g. 我们定义两个变量<code>a=10, b=20</code>:<br>
<img src="logic.png" alt="logic"/></li>
<li><strong>字符串运算符</strong>：判断字符串属性。假定变量 a 为 “abc”，变量 b 为 “efg”：<br>
<img src="string.png" alt="string"/></li>
<li><strong>文件测试运算符</strong>：用于检测 Unix 文件的各种属性。<br>
<img src="file.png" alt="file"/></li>
</ul>
<h2 id="linux中的各种括号">linux中的各种括号</h2>
<p>()、[]、{}、(())、[[]]<br>
（<br>
各种括号的比较<br>
条件表达式要放在方括号之间，并且要有空格，例如 <code>[$a==$b]</code> 是错误的，必须写成 <code>[ $a == $b ]</code></p>
<h3 id="单小括号">单小括号()</h3>
<ol>
<li>在 bash shell 中，$( ) 与`` (反引号) 都可用做命令替换用。e.g. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version=$(uname -r)</span><br><span class="line">version=`uname -r`</span><br></pre></td></tr></table></figure>
都可以是version得到内核的版本号.</li>
<li>命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。e.g. <code>(cmd1;cmd2;cmd3)</code> 新开一个子shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后可以没有分号。</li>
<li>用于初始化数组。如：<code>array=(a b c d)</code></li>
</ol>
<h3 id="双小括号">双小括号 (( ))</h3>
<ol>
<li>整数扩展。这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是&quot;假&quot;，而一个非零值的表达式所返回的退出状态码将为0，或者是&quot;true&quot;。若是逻辑判断，表达式exp为真则为1,假则为0。</li>
<li>只要括号中的运算符、表达式符合C语言运算规则，都可用在$((exp))中，甚至是三目运算符。此时作用$(())和$[]作用几乎相同。$(())的独特之处在于，作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo $((16#5f)) 结果为95 (16进位转十进制)</li>
<li>单纯用 (( )) 也可重定义变量值，比如 a=5; ((a++)) 可将 $a 重定义为6</li>
<li>双括号中的变量可以不使用$符号前缀。括号内支持多个表达式用逗号分开。</li>
</ol>
<h3 id="单中括号">单中括号 []</h3>
<ol>
<li>bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。</li>
<li>test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较 “ab&quot;和&quot;bc”：[ ab &lt; bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。</li>
<li>字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。</li>
<li>在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。</li>
</ol>
<h3 id="双中括号">双中括号 [[]]</h3>
<ol>
<li>[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。</li>
<li>支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如<code>[[ hello == hell? ]]</code>，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。</li>
<li>使用[[ … ]]条件判断结构，而不是[ … ]，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用<code>if [[ $a !=1 &amp;&amp; $a != 2 ]]</code>, 如果不适用双括号, 则为<code>if [ $a -ne 1] &amp;&amp; [ $a != 2 ]</code>或者<code>if [ $a -ne 1 -a $a != 2 ]</code>。</li>
<li>bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。</li>
</ol>
<h3 id="大括号">大括号 {}</h3>
<ol>
<li>花括号拓展。(通配(globbing))将对花括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。
<ul>
<li>对大括号中的以逗号分割的文件列表进行拓展。e.g.<code>touch &#123;a,b&#125;.txt</code> 结果为a.txt b.txt。</li>
<li>对大括号中以点点（…）分割的顺序文件列表起拓展作用，如：<code>touch &#123;a…d&#125;.txt</code> 结果为a.txt b.txt c.txt d.txt。</li>
</ul>
</li>
<li>代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，花括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。</li>
</ol>
<h2 id="条件测试命令">条件测试命令</h2>
<p>test命令，测试特定的表达式是否成立，当条件成立时，命令执行后的返回值为0，否则为其他数值。<br>
格式1：test 条件表达式<br>
格式2：[ 条件表达式 ] //常用格式，使用方括号时，要注意在条件两边加上空格。</p>
<p>常见测试类型: 测试文件状态，字符串的比较，整数值的比较，逻辑测试。<br>
[]完全等价于test，只是写法不同。e.g.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num1=&quot;ru1noob&quot;</span><br><span class="line">num2=&quot;runoob&quot;</span><br><span class="line">if test $num1 = $num2</span><br><span class="line">then</span><br><span class="line">    echo &#x27;两个字符串相等!&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;两个字符串不相等!&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h2 id="函数">函数</h2>
<ol>
<li>可以带function fun() 定义，也可以直接fun() 定义,不带任何返回参数。e.g. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">demoFun()&#123;</span><br><span class="line">    echo &quot;这是我的第一个 shell 函数!&quot;</span><br><span class="line">&#125;demoFun</span><br></pre></td></tr></table></figure>
</li>
<li>参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function demoFun2()&#123;</span><br><span class="line"> echo &quot;这是我的第二个 shell 函数!&quot;</span><br><span class="line"> expr 1 + 1 # or return `expr 1 + 1`</span><br><span class="line">&#125;</span><br><span class="line">a=`demoFun2` </span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure>
</li>
<li>带输入参数的函数： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">funWithParam()&#123;</span><br><span class="line">    echo &quot;The value of the first parameter is $1 !&quot;</span><br><span class="line">    echo &quot;The value of the second parameter is $2 !&quot;</span><br><span class="line">    echo &quot;The value of the tenth parameter is $10 !&quot;</span><br><span class="line">    echo &quot;The value of the tenth parameter is $&#123;10&#125; !&quot;</span><br><span class="line">    echo &quot;The value of the eleventh parameter is $&#123;11&#125; !&quot;</span><br><span class="line">    echo &quot;The amount of the parameters is $# !&quot;  # 参数个数</span><br><span class="line">    echo &quot;The string of the parameters is $* !&quot;  # 传递给函数的所有参数</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="输入输出重定向">输入输出重定向</h2>
<p>大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回​​到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p>
<p>重定向命令列表如下：<br>
<img src="redirect.png" alt="redirect"/></p>
<h3 id="输出重定向">输出重定向</h3>
<p>重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command1 &gt; file1</span><br></pre></td></tr></table></figure>
<h3 id="输入重定向">输入重定向</h3>
<p>和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command1 &lt; file1</span><br></pre></td></tr></table></figure>
<h3 id="重定向深入讲解">重定向深入讲解</h3>
<p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p>
<ul>
<li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li>
<li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li>
<li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li>
</ul>
<p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p>
<ol>
<li>如果希望 stderr 重定向到 file，可以这样写： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$command 2 &gt; file</span><br></pre></td></tr></table></figure>
</li>
<li>如果希望 stderr 追加到 file 文件末尾，可以这样写： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$command 2 &gt;&gt; file</span><br></pre></td></tr></table></figure>
</li>
<li>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$command &gt; file 2&gt;&amp;1</span><br><span class="line">$command &gt;&gt; file 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
</li>
<li>如果希望对 stdin 和 stdout 都重定向，可以这样写： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$command &lt; file1 &gt;file2</span><br></pre></td></tr></table></figure>
command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。</li>
</ol>
<h2 id="流程控制">流程控制</h2>
<h3 id="后台执行">后台执行</h3>
<p>当我们在终端或控制台工作时，可能不希望由于运行一个作业而占住了屏幕，因为可能还有更重要的事情要做，比如阅读电子邮件。对于密集访问磁盘的进程，我们更希望它能够在每天的非负荷高峰时间段运行(例如凌晨)。为了使这些进程能够在后台运行，也就是说不在终端屏幕上运行，有几种选择方法可供使用。</p>
<ol>
<li><code>&amp;</code>:<br>
当在前台运行某个作业时，终端被该作业占据；可以在命令后面加上&amp; 实现后台运行。例如：sh <a href="http://test.sh">test.sh</a> &amp;<br>
适合在后台运行的命令有f i n d、费时的排序及一些s h e l l脚本。在后台运行作业时要当心：需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。不过，作业在后台运行一样会将结果输出到屏幕上，干扰你的工作。如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command  &gt;  out.file  2&gt;&amp;1  &amp; </span><br></pre></td></tr></table></figure>
这样，所有的标准输出和错误输出都将被重定向到一个叫做out.file 的文件中。</li>
<li>nohup: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup command &amp;</span><br></pre></td></tr></table></figure>
如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup command &gt; myout.file 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台运行命令之后，需要使用<code>exit</code>正常退出当前账户，这样才能保证命令一直在后台运行。</li>
</ol>
<p>输出部分解析：</p>
<ul>
<li><code>command&gt;out.file</code>是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。</li>
<li><code>2&gt;&amp;1</code> 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&amp;， 是让该命令在后台执行。</li>
<li>试想<code>2&gt;1</code>代表什么，2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成<code>2&gt;&amp;1</code>，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出.</li>
</ul>
<h3 id="多命令按顺序执行">多命令按顺序执行</h3>
<ol>
<li>
<p>使用获取命令行输出的方法。即用 ` 号将需要获取输出的操作括起来，并赋值给一个变量，则 Shell 会在等待命令执行完成后把输出内容用于赋值，所以，这就是实现了我们需要的等待效果，并且时间精准性很高。e.g.</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">command 1</span><br><span class="line">output=`command 2`</span><br><span class="line">command 3</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用逻辑运算符。具体见下：<br>
<img src="logic_pipeline.png" alt="logic_pipeline"  width="500"/><br>
此外，<code>|</code>称为管道符，当用此连接符连接多个命令时，前面命令执行的正确输出，会交给后面的命令继续处理。若前面的命令执行失败，则会报错，若后面的命令无法处理前面命令的输出，也会报错。举例说明 e.g.</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls ; date; cd /user; pwd</span><br><span class="line">cp /root/test /tmp/test &amp;&amp; rm -rf/ root/test &amp;&amp; echo yes</span><br><span class="line">ls | date | pwd</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>wait</code>命令。wait是用来阻塞当前进程的执行，直至指定的子进程执行结束后，才继续执行。使用wait可以在bash脚本“多进程”执行模式下，起到一些特殊控制的作用。</p>
<ul>
<li>等待作业号或者进程号制定的进程退出，返回最后一个作业或进程的退出状态状态。如果没有制定参数，则等待所有子进程的退出，其退出状态为0.</li>
<li>如果是shell中等待使用wait，则不会等待调用函数中子任务。在函数中使用wait，则只等待函数中启动的后台子任务。</li>
<li>在shell中使用wait命令，相当于高级语言里的多线程同步。<br>
实例：<br>
　　1. 使用wait等待所有子任务结束。</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sleep 10 &amp; </span><br><span class="line">sleep 5&amp; </span><br><span class="line">wait #等待10秒后，退出</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sleep 10 &amp;</span><br><span class="line">sleep 5&amp;</span><br><span class="line">wait $! #$!表示上个子进程的进程号，wait等待一个子进程，等待5秒后，退出</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2. 在函数中使用wait<br>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun()&#123;</span><br><span class="line">echo &quot;fun is begin.timeNum:$timeNum&quot;</span><br><span class="line">local timeNum=$1</span><br><span class="line">sleep $timeNum &amp;</span><br><span class="line">wait #这个只等待wait前面sleep</span><br><span class="line">echo &quot;fun is end.timeNum:$timeNum&quot;</span><br><span class="line">&#125;</span><br><span class="line">fun 10 &amp;</span><br><span class="line">fun 20 &amp;</span><br><span class="line">wait #如果fun里面没有wait，则整个脚本立刻退出，不会等待fun里面的sleep</span><br><span class="line">echo &quot;all is ending&quot;</span><br></pre></td></tr></table></figure><br>
　　输出结果为：<br>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun is begin.timeNum:10</span><br><span class="line">fun is begin.timeNum:20</span><br><span class="line">fun is end.timeNum:10</span><br><span class="line">fun is end.timeNum:20</span><br><span class="line">all is ending</span><br></pre></td></tr></table></figure><br>
　　从输出结果，可以看到，整个脚本，等待了所有子任务的退出。</p>
<h3 id="if-else">if else</h3>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2 </span><br><span class="line">then </span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>具体例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">elif [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 大于 b&quot;</span><br><span class="line">elif [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;没有符合的条件&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h3 id="for循环">for循环</h3>
<p>一般格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>in列表是可选的，如果不用它，for循环使用命令行的位置参数。例如，顺序输出当前列表中的数字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for loop in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">    echo &quot;The value is: $loop&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="while循环">while循环</h3>
<p>while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真。int从0开始，每次循环处理时，int加1。运行上述脚本，返回数字1到5，然后终止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int=1</span><br><span class="line">while(( $int&lt;=5 ))</span><br><span class="line">do</span><br><span class="line">    echo $int</span><br><span class="line">    let &quot;int++&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="until-循环">until 循环</h3>
<p>until 循环执行一系列命令直至条件为 true 时停止。<br>
until 循环与 while 循环在处理方式上刚好相反。<br>
一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。<br>
until 语法格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>举例说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=0</span><br><span class="line">until [ ! $a -lt 10 ]</span><br><span class="line">do</span><br><span class="line">   echo $a</span><br><span class="line">   a=`expr $a + 1`</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="case语句">case语句</h3>
<p>case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p>case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。<br>
取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。<br>
下面的脚本提示输入1到4，与每一种模式进行匹配：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &#x27;输入 1 到 4 之间的数字:&#x27;</span><br><span class="line">echo &#x27;你输入的数字为:&#x27;</span><br><span class="line">read aNum</span><br><span class="line">case $aNum in</span><br><span class="line">    1)  echo &#x27;你选择了 1&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo &#x27;你选择了 2&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo &#x27;你选择了 3&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo &#x27;你选择了 4&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo &#x27;你没有输入 1 到 4 之间的数字&#x27;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<h3 id="跳出循环">跳出循环</h3>
<p>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。</p>
<ol>
<li>break：break命令允许跳出所有循环（终止执行后面的所有循环）。<br>
下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n &quot;输入 1 到 5 之间的数字:&quot;</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;</span><br><span class="line">        ;;</span><br><span class="line">        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;</span><br><span class="line">            break</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>continue：continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。<br>
对上面的例子进行修改：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n &quot;输入 1 到 5 之间的数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;</span><br><span class="line">        ;;</span><br><span class="line">        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;</span><br><span class="line">            continue</span><br><span class="line">            echo &quot;游戏结束&quot;</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 echo “游戏结束” 永远不会被执行。</p>
<h2 id="文本处理">文本处理</h2>
<p>grep、sed和awk都是文本处理工具，虽然都是文本处理工具单却都有各自的优缺点，一种文本处理命令是不能被另一个完全替换的，否则也不会出现三个文本处理命令了。不过，相比较而言，sed和awk功能更强大而已，且已独立成一种语言来介绍。</p>
<p>grep：grep (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。文本过滤器，如果仅仅是过滤文本，可使用grep，其效率比其他的高很多。（过滤文本）</p>
<p>sed：Stream EDitor，流编辑器。默认只处理模式空间，不处理原数据，如果你处理的数据是针对行进行处理的，可以使用sed。（处理行）</p>
<p>awk：报告生成器，格式化以后显示。如果对处理的数据需要生成报告之类的信息，或者你处理的数据是按列进行处理的，最好使用awk。（处理列）</p>
<p>总结：</p>
<ul>
<li>如果文件是格式化的，即由分隔符分为多个域的，优先使用awk</li>
<li>awk适合按列（域）操作，sed适合按行操作</li>
<li>awk适合对文件的抽取整理，sed适合对文件的编辑。</li>
<li>grep 主要用于搜索某些字符串，sed，awk 用于处理文本</li>
</ul>
<h3 id="grep">grep</h3>
<p>grep是一个最初用于Unix操作系统的命令行工具。在给出文件列表或标准输入后，grep会对匹配一个或多个正则表达式的文本进行搜索，并只输出匹配（或者不匹配）的行或文本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用格式：（Pattern：文本字符和正则表达式的元字符组合而成匹配条件）</span><br><span class="line"></span><br><span class="line">grep [options] PATTERN [FILE...]</span><br><span class="line">    -i：忽略大小写    </span><br><span class="line">    --color：匹配到字符用其他颜色显示出来，默认是红色</span><br><span class="line">    -v：显示没有被模式匹配到的行</span><br><span class="line">    -o：只显示被模式匹配到的字符串，不显示行</span><br><span class="line">    -E：使用扩展正则表达式</span><br><span class="line">    -A n：表示显示该行及其后n行</span><br><span class="line">    -B n：表示显示该行及其前n行</span><br><span class="line">    -C n：表示显示该行及其前后各n行</span><br><span class="line">    </span><br><span class="line">正则表达式：REGular EXPression，REGEXP</span><br><span class="line"></span><br><span class="line">元字符：</span><br><span class="line"></span><br><span class="line">.：匹配任意单个字符</span><br><span class="line">[]：匹配指定范围内的任意单个字符</span><br><span class="line">[^]：匹配指定范围外的任意单个字符</span><br><span class="line">   字符集和：[:digit:]，[:lower:]，[:upper:]，[:punct:]，[:space:]，[:alpha:]，[:alnum:]</span><br><span class="line">    对应上边：数字  ，小写字母，大写字母，标点符号，空白字符，所有字母，所有数字和字母</span><br><span class="line"></span><br><span class="line">匹配次数（贪婪模式，即尽可能长的匹配）：</span><br><span class="line">*：匹配其前面的字符任意次</span><br></pre></td></tr></table></figure>
<p>匹配.b和.*b，看二者有什么区别，命令和显示效果如下：<br>
<img src="grep.png" alt="grep"  width="500"/></p>
<p><strong>grep练习：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 显示/proc/meminfo文件中以不区分大小的s开头的行；</span><br><span class="line">     grep -i &#x27;^s&#x27; /proc/meminfo    或者</span><br><span class="line">     grep &#x27;^[sS]&#x27; /proc/meminfo   #[]表示匹配指定范围内的单个字符，因此也可实现不区分大小写</span><br><span class="line">     </span><br><span class="line">2. 显示/etc/passwd中以nologin结尾的行;</span><br><span class="line">     grep &#x27;nologin$&#x27; /etc/passwd</span><br><span class="line">     扩展一：取出默认shell为/sbin/nologin的用户列表</span><br><span class="line">           grep &#x27;/sbin/nologin&#x27; /etc/passwd | cut -d: -f1    或者</span><br><span class="line">           grep &#x27;/sbin/nologin&#x27; /etc/passwd | awk -F: &#x27;&#123;print $1&#125;&#x27;     或者直接使用awk</span><br><span class="line">           awk -F: &#x27;$7 ~ /nologin/&#123;print $1&#125;&#x27; /etc/passwd</span><br><span class="line">     扩展二：取出默认shell为bash，且其用户ID号最小的用户的用户名</span><br><span class="line">           grep &#x27;bash$&#x27; /etc/passwd | sort -n -t: -k3 | head -1 | cut -d: -f1   或者</span><br><span class="line">           awk -F: &#x27;$7 ~ /bash/&#123;print $3,$1&#125;&#x27; /etc/passwd | sort -n | head -1 | awk &#x27;&#123;print $2&#125;&#x27;</span><br><span class="line">3. 显示/etc/inittab中以#开头，且后面跟一个或多个空白字符，而后又跟了任意非空白字符的行；</span><br><span class="line">      grep &#x27;^#[[:space:]]\&#123;1,\&#125;[^[:space:]]&#x27; /etc/inittab</span><br><span class="line">4. 显示/etc/inittab中包含了:一个数字:(即两个冒号中间一个数字)的行；</span><br><span class="line">      grep &#x27;:[0-9]:&#x27; /etc/inittab</span><br><span class="line">5. 显示/boot/grub/grub.conf文件中以一个或多个空白字符开 头的行；</span><br><span class="line">      grep &#x27;^[[:space:]]\&#123;1,\&#125;&#x27; /boot/grub/grub.conf</span><br><span class="line">6. 显示/etc/inittab文件中以一个数字开头并以一个与开头数字相同的数字结尾的行；</span><br><span class="line">      grep &#x27;\(^[0-9]\).*\1$&#x27; /etc/inittab     #在RHEL5.8以前的版本中可查看到效果</span><br><span class="line">7. 找出某文件中的，1位数，或2位数；</span><br><span class="line">      grep &#x27;\&lt;[[:digit:]][[:digit:]]\?\&gt;&#x27; /etc/inittab  或者</span><br><span class="line">      grep &#x27;\&lt;[0-9]\&#123;1,2\&#125;\&gt;&#x27; /etc/inittab</span><br><span class="line">8. 查找当前系统上名字为student(必须出现在行首)的用户的帐号的相关信息, 文件为/etc/passwd</span><br><span class="line">      grep &#x27;^student:&#x27; /etc/passwd</span><br><span class="line">      扩展：若存在该用户，找出该用户的ID号：</span><br><span class="line">    grep &#x27;^student:&#x27; /etc/passwd | cut -d: -f3  或者# id -u student</span><br><span class="line">            </span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">思考题：用多种方法找出本地的IP地址，这里给出三种方法，如果你还有其他方法可以一起分享下：</span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line">ifconfig eth0|grep -oE &#x27;([0-9]&#123;1,3&#125;\.?)&#123;4&#125;&#x27;|head -n 1</span><br><span class="line">ifconfig eth0|awk -F: &#x27;/inet addr/&#123;split($2,a,&quot; &quot;);print a[1];exit&#125;&#x27;     #这里使用了awk的内置函数，如果不懂可在看完awk的介绍后再来做此题</span><br><span class="line">ifconfig |grep &quot;inet addr&quot;|grep -v &quot;127.0.0.1&quot; |awk -F: &#x27;&#123;print $2&#125;&#x27; |awk &#x27;&#123;print $1&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="sed">sed</h3>
<ul>
<li>sed（意为流编辑器，源自英语“stream editor”的缩写）是Unix常见的命令行程序。</li>
<li>sed 用来把文档或字符串里面的文字经过一系列编辑命令转换为另一种格式输出。</li>
<li>sed 通常用来匹配一个或多个正则表达式的文本进行处理。sed是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</li>
<li>sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等</li>
<li>sed是一个精简的、非交互式的编辑器。它能执行与编辑vi和emacs相同的编辑任务，但sed编辑器不提供交互使用方式，只能在命令行下输入编辑命令。</li>
</ul>
<p><strong>使用格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed &#x27;AddressCommand&#x27; file ...</span><br><span class="line">    -n：静默模式，不再显示模式空间中的内容</span><br><span class="line">    -i：直接修改原文件</span><br><span class="line">    -e SCRIPT -e SCRIPT：添加脚本到将要执行的命令中，可以同时执行多个脚本</span><br><span class="line">    -f /PATH/TO/SED_SCORIPT：添加脚本文件中的内容到将要执行的命令中</span><br><span class="line">         #sed -f /path/to/script file</span><br><span class="line">    -r：表示使用扩展正则表达式</span><br><span class="line"></span><br><span class="line">Address:</span><br><span class="line">    1、StartLine,EndLine：开始行，结束行</span><br><span class="line">       如：1,100:表示从第1行到第100行</span><br><span class="line">        $；最后一行</span><br><span class="line">    2、/RegExp/：扩展正则表达式</span><br><span class="line">       如：/^root/</span><br><span class="line">    3、/pattern1/,/pattern2/：表示第一次被pattern1匹配到的行开始，至第一次被pattern2匹配到的行结束，这中间的所有行</span><br><span class="line">    4、LIneNumber：指定的行</span><br><span class="line">    5、StartLIne，+N：从StartLine开始，向后的N行</span><br><span class="line"></span><br><span class="line">Command:</span><br><span class="line">    d：删除符合条件的行；</span><br><span class="line">    p：显示符合条件的行，在不使用-n选项时被匹配到的行会显示两遍，因为sed处理时会把处理的信息输出</span><br><span class="line">    a \string：在指定的行后面追加新行，内容为“string”,</span><br><span class="line">        显示两行或多行，在每行后加\n进行换行</span><br><span class="line">    i \string：在指定的行前面添加新行，内容为string</span><br><span class="line">    r file：将指定的文件的内容添加至符合条件的文件中</span><br><span class="line">    w file：将地址指定范围内的行另存至指定的文件中</span><br><span class="line">    s/pattern/string/修饰符：查找并替换，默认只替换每行中第一次被模式匹配到的字符串</span><br><span class="line">        加修饰符</span><br><span class="line">         g：全局替换，如：s/pattern/string/g</span><br><span class="line">         i：忽略字符大小写，如：s/pattern/string/i</span><br><span class="line">    s///,s###,s@@@都可以，当所使用的分割符号与内容中显示的相同时，需使用转义字符转义    </span><br><span class="line">        \(\),\1,\2：成组匹配，\1表示匹配第一个‘(’，\2表示匹配第二个‘(’</span><br><span class="line">    &amp;：引用模式匹配到的整个串</span><br></pre></td></tr></table></figure>
<p><strong>sed 练习:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、删除/etc/grub.conf文件中行首的空白符；</span><br><span class="line">      sed  -r &#x27;s/^[[:space:]]+//&#x27; /etc/grub.conf</span><br><span class="line">2、替换/etc/inittab文件中“id:3:initdefault:”一行中的数字为5；</span><br><span class="line">     sed &#x27;s/\(id:\)[0-9]\(:initdefault:\)/\15\2/g&#x27; /etc/inittab</span><br><span class="line">3、删除/etc/inittab文件中的空白行；</span><br><span class="line">     sed &#x27;/^$/d&#x27; /etc/inittab</span><br><span class="line">4、删除/etc/inittab文件中开头的#号；</span><br><span class="line">     sed &#x27;s/^#//g&#x27; /etc/inittab</span><br><span class="line">5、删除某文件中开头的#号及其后面的空白字符，但要求#号后面必须有空白符；</span><br><span class="line">     sed &#x27;s/^#[[:space:]]\&#123;1,\&#125;//g&#x27; /etc/inittab     或者</span><br><span class="line">     sed  -r &#x27;s/^#[[:space:]]+//g&#x27; /etc/inittab</span><br><span class="line">6、删除某文件中以空白字符后面跟#类的行中的开头的空白字符及#</span><br><span class="line">     sed -r &#x27;s/^[[:space:]]+#//g&#x27; /etc/inittab</span><br><span class="line">7、取出一个文件路径的目录名称;</span><br><span class="line">     echo &quot;/etc/rc.d/abc/edu/&quot; | sed -r &#x27;s@^(/.*/)[^/]+/?@\1@g&#x27;        #因sed支持扩展正则表达式，在扩展正则表达式中，+表示匹配其前面的字符至少1次</span><br><span class="line">8、取出一个文件路径的最后一个文件名；</span><br><span class="line">     echo &quot;/etc/rc.d/abc/edu/&quot; | sed -r &#x27;s@^/.*/([^/]+)/?@\1@g&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="awk">awk</h3>
<p>与sed和grep很相似，awk是一种样式扫描与处理工具。但其功能却大大强于sed和grep。<br>
awk提供了极其强大的功能：它几乎可以完成grep和sed所能完成的全部工作，同时，它还可以可以进行样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。它具备了一个完整的语言所应具有的几乎所有精美特性。</p>
<ol>
<li>使用格式： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk [options] &#x27;script&#x27; file1, file2, ...</span><br><span class="line">或者</span><br><span class="line">awk [options] &#x27;PATTERN &#123; action &#125;&#x27; file1, file2, ...</span><br></pre></td></tr></table></figure>
options 有<code>-F</code>，<code>-v</code>等等一系列。以下介绍几个比较常用的awk用法：
<ul>
<li>用法1：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -F  #-F相当于内置变量FS, 指定分割字符</span><br></pre></td></tr></table></figure>
举例：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 每行按空格或TAB分割，输出文本中的1、4项</span><br><span class="line">awk &#x27;&#123;print $1,$4&#125;&#x27; log.txt</span><br></pre></td></tr></table></figure>
</li>
<li>用法2：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -F  #-F相当于内置变量FS, 指定分割字符</span><br></pre></td></tr></table></figure>
举例：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用&quot;,&quot;分割</span><br><span class="line">awk -F, &#x27;&#123;print $1,$2&#125;&#x27;   log.txt</span><br><span class="line"># 使用多个分隔符.先使用空格分割，然后对分割结果再使用&quot;,&quot;分割</span><br><span class="line">awk -F &#x27;[ ,]&#x27;  &#x27;&#123;print $1,$2,$5&#125;&#x27;   log.txt</span><br></pre></td></tr></table></figure>
</li>
<li>用法3：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -v  # 设置变量</span><br></pre></td></tr></table></figure>
举例：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -va=1 &#x27;&#123;print $1,$1+a&#125;&#x27; log.txt</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>awk内置变量之记录变量：
<ul>
<li>FS: field separator，字段分隔符，默认是空白字符；</li>
<li>RS: Record separator，记录分隔符，默认是换行符；</li>
<li>OFS: Output Filed Separator，输出字段分隔符</li>
<li>ORS：Output Row Separator，输出行分隔符</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;OFS=&quot;#&quot;&#125; &#123;print $1,$2&#125;&#x27; test.txt    #指定输出时的分隔符</span><br><span class="line">awk &#x27;BEGIN&#123;OFS=&quot;#&quot;&#125; &#123;print $1,&quot;hello&quot;,$2&#125;&#x27; test.txt #指定输出时的分隔符，并添加显示的内容</span><br></pre></td></tr></table></figure>
</li>
<li>awk内置变量之数据变量：
<ul>
<li>NR: The number of input records，awk命令所处理的记录数；如果有多个文件，这个数目会把处理的多个文件中行统一计数；</li>
<li>NF：Number of Field，当前记录的字段个数，有时可用来表示最后一个字段</li>
<li>FNR: 与NR不同的是，FNR用于记录正处理的行是当前这一文件中被总共处理的行数；</li>
<li>ARGV: 数组，保存命令行本身这个字符串，如awk ‘{print $0}’ a.txt b.txt这个命令中，ARGV[0]保存awk，ARGV[1]保存a.txt；</li>
<li>ARGC: awk命令的参数的个数；</li>
<li>FILENAME: awk命令所处理的文件的名称；</li>
<li>ENVIRON：当前shell环境变量及其值的关联数组；</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;print ENVIRON[&quot;PATH&quot;]&#125;&#x27;</span><br><span class="line">awk &#x27;&#123;print $NF&#125;&#x27; test.txt</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="其他常用命令">其他常用命令</h2>
<ul>
<li><code>echo</code>: echo是Shell的一个内部指令，用于在屏幕上打印出指定的字符串。 e.g. <code>echo &quot;It is a test&quot;</code></li>
<li><code>printf</code>: printf 命令用于格式化输出， 是echo命令的增强版。它是C语言printf()库函数的一个有限的变形，并且在语法上有些不同。e.g. <code>printf &quot;%d %s\n&quot; 1 &quot;abc&quot;</code>，输出为“1 abc&quot;.</li>
<li><code>source</code>：<code>source filename</code>这个命令其实只是简单地读取脚本里面的语句依次在当前shell里面执行，没有建立新的子shell。那么脚本里面所有新建、改变变量的语句都会保存在当前shell里面。相比之下， <code>sh filename</code>会重新建立一个子shell，在子shell中执行脚本里面的语句，该子shell继承父shell的环境变量，但子shell新建的、改变的变量不会被带回父shell。</li>
<li><code>ls</code>和<code>ll</code>: List, 会列举出当前工作目录的内容（文件或文件夹）。-a 列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来。<code>ll</code>并不是linux下一个基本的命令，它实际上是<code>ls -l</code>的一个别名。Ubuntu默认不支持命令ll，必须用 <code>ls -l</code>，这样使用起来不是很方便。</li>
<li><code>dir</code>:列出路径下里的内容。<code>dir -l .</code></li>
<li><code>mkdir</code>: Make Directory, 用于新建一个新目录. e.g. <code>mkdir folder_name</code></li>
<li><code>pwd</code>：Print Working Directory。显示当前工作目录。</li>
<li><code>cd</code>: Change Directory。切换文件路径，cd 将给定的文件夹（或目录）设置成当前工作目录。e.g. <code>cd ~/Desktop</code></li>
<li><code>rmdir</code>: Remove Directory。删除给定的目录。e.g. <code>rmdir folder_name</code></li>
<li><code>rm</code>: Remove.  会删除给定的文件。e.g. <code>rm file_name</code></li>
<li><code>cp</code>:copy, 对文件进行复制。如果是文件夹的话，加上<code>-r</code>。为 <code>cp -r folder/ folder_new/</code></li>
<li><code>scp</code>:和<code>cp</code>类似，专门用来实现本地和服务器的双向传输。<code>scp a.txt gao27@iris.ils.indiana.edu:/a.txt</code></li>
<li><code>mv</code>: Move。对文件或文件夹进行移动，如果文件或文件夹存在于当前工作目录，还可以对文件或文件夹进行重命名。e.g. <code>mv a.txt ../a.txt</code></li>
<li><code>touch</code>:用来修改文件时间戳，或者新建一个不存在的文件。e.g. <code>touch a.txt b.txt</code></li>
<li><code>cat</code>: concatenate and print files。
<ul>
<li>用于在标准输出（监控器或屏幕）上查看文件内容: <code>cat a.txt</code>.</li>
<li>从键盘创建一个文件:<code>cat &gt; filename</code> 只能创建新文件,不能编辑已有文件.</li>
<li>将几个文件合并为一个文件:<code>cat file1 file2 &gt; file</code></li>
</ul>
</li>
<li><code>head/tail</code>: print head/ tail。 默认在标准输出上显示给定文件的最前/后10行内容，可以使用<code>head/tail -n N</code> 指定在标准输出上显示文件的最前/后N行内容。</li>
<li><code>less</code>: print LESS. 按页或按窗口打印文件内容。在查看包含大量文本数据的大文件时是非常有用和高效的。你可以使用Ctrl+F向前翻页，Ctrl+B向后翻页。e.g. <code>less a.txt</code></li>
<li><code>more</code>: 一下子load整个文件，并且支持向前翻页的功能有限。e.g. <code>more a.txt</code></li>
<li><code>grep</code>: 在给定的文件中搜寻指定的字符串。<code>grep -i “”</code> 在搜寻时会忽略字符串的大小写，而<code>grep -r “”</code> 则会在当前工作目录的文件中递归搜寻指定的字符串。e.g. <code>grep -rn &quot;a b c&quot;  folder/</code> 指的是递归查找目录下含有该字符串的所有文件。</li>
<li><code>find</code>:这个命令会在给定位置搜寻与条件匹配的文件。你可以使用<code>find -name</code>的-name选项来进行区分大小写的搜寻，<code>find -iname</code> 来进行不区分大小写的搜寻。e.g. <code>find . -name &quot;*.log&quot;</code>指的是在当前目录及子目录中查找所有的‘ *.log‘文件。</li>
<li><code>tar</code>:创建、查看和提取tar压缩文件。<code>tar -cvf</code> 是创建对应压缩文件，<code>tar -tvf</code> 来查看对应压缩文件，<code>tar -xvf</code> 来提取对应压缩文件。e.g. <code>tar -czvf a.tar.gz file_name</code></li>
<li><code>gzip</code>:创建和提取gzip压缩文件，还可以用<code>gzip -d </code>来提取压缩文件。e.g. <code>gzip a.txt</code></li>
<li><code>uzip</code>:对gzip文档进行解压。在解压之前，可以使用<code>unzip -l</code> 命令查看文件内容。e.g.<code>uzip a.zip</code></li>
<li><code>which</code>: 在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 e.g. <code>which python</code></li>
<li><code>whatis</code>:What is this command. 会用单行来描述给定的命令，就是解释当前命令。e.g. <code>whatis cd</code></li>
<li><code>whereis</code>: 当你不知道某个命令的位置时可以使用whereis命令，下面使用whereis查找ls的位置。e.g. <code>whereis ls</code>.当你想查找某个可执行程序的位置，但这个程序又不在whereis的默认目录下，你可以使用-B选项，并指定目录作为这个选项的参数。下面的命令在/tmp目录下查找lsmk命令: <code>whereis -u -B /tmp -f lsmk</code></li>
<li><code>locate</code>:让使用者可以很快速的搜寻档案系统内是否有指定的档案。<br>
其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。locate的速度比find快，因为它并不是真的查找文件，而是查数据库. locate的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护.e.g.<code>locate /etc/sh</code></li>
<li><code>man</code>: 显示某个命令的man页面.e.g.<code>man ls</code></li>
<li><code>exit</code>: 用于结束当前的终端会话。</li>
<li><code>ping</code>:通过发送数据包ping远程主机(服务器)，常用与检测网络连接和服务器状态。e.g. <code>ping zhenggao.io</code></li>
<li><code>df</code>: Disk space Free。用于查看磁盘分区的使用情况，了解磁盘总量及用量，默认单位为KB。使用-h选项，可以自动切换至合适的单位。e.g. <code>df -h</code></li>
<li><code>du</code>: 用于查看文件、目录在磁盘中占用的空间的大小。<code>du -ah --max-depth=1</code> 可以查看根目录下各个文件占用情况。</li>
<li><code>free</code>：这个命令用于显示系统当前内存的使用情况，包括已用内存、可用内存和交换内存的情况。e.g. <code>free -gt</code></li>
<li><code>chmod</code>:用于改变文件和目录的权限。给指定文件的属主(user u)和属组(group g)和其他(others o)所有权限(包括读、写、执行) <code>chmod ug+rwx file.txt</code>.由于赋值r:4;w:2;x:1，所以更改读（r）,写（w）和执行（x）的语句可以写成<code>chmod 777 file.txt</code></li>
<li><code>chown</code>:chown用于改变文件属主和属组。e.g. <code>chown oracle:db file_name</code>。把属主改成Oracle,属组改成db。</li>
<li><code>top</code>: 能够实时显示系统中各个进程的资源占用状况。e.g. <code>top -u gao27</code></li>
<li><code>ps</code>:Process Status. 列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。<code>ps -u gao27</code></li>
<li><code>kill</code>:用于终止一个进程。一般我们会先用<code>ps -ef</code>查找某个进程得到它的进程号，然后再使用<code>kill -9 pid</code> 进程号终止该进程。</li>
<li><code>xargs</code>: 将标准输入转为命令行参数。xargs的作用在于，大多数命令（比如rm、mkdir、ls）与管道一起使用时，都需要xargs将标准输入转为命令行参数。e.g. <code>echo &quot;one two three&quot; | xargs mkdir</code></li>
<li><code>sort</code>: 将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。e.g. <code>sort a.txt</code></li>
<li><code>uniq</code>: 用于检查及删除文本文件中重复出现的行列。e.g. <code>uniq a.txt</code></li>
<li><code>wc</code>: Word Count。命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。-c 统计字节数。-l统计行数。-m 统计字符数。这个标志不能与 -c 标志一起使用。-w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。e.g. <code>wc -l a.txt</code></li>
<li><code>nl</code>:number lines。可以将输出的文件内容自动的加上行号！其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。e.g. <code>nl a.txt</code></li>
<li><code>cut</code>: cut是一个选取命令，就是将一段数据经过分析，取出我们想要的。一般来说，选取信息通常是针对“行”来进行分析的，并不是整篇信息分析的。其语法格式为：<br>
<code>cut  [-bn] [file]</code> 或 <code>cut [-c] [file]</code> 或  <code>cut [-df] [file]</code></li>
<li><code>ssh</code>: 登录远程服务器。e.g. <code>ssh user@host</code></li>
<li><code>sed</code>: sed 是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。e.g.删除文件第二行： <code>nl a.txt | sed '2d'</code></li>
<li><code>vim</code>: 用Linux内嵌的文本编辑器打开文件。e.g. <code>vim a.txt</code></li>
<li><code>diff</code>: 比较两个file的差别. e.g. <code>diff name_list.txt name_list_new.txt</code></li>
<li><code>export</code>：用于设置或显示环境变量。在 shell 中执行程序时，shell 会提供一组环境变量。export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。e.g.<code>export $PATH=&quot;$PATH:路径1:路径2:...:路径n”</code></li>
<li><code>alias</code>: 在linux系统中如果命令太长又不符合用户的习惯，那么我们可以为它指定一个别名。e.g. <code>alias ls='ls --color=auto'</code></li>
<li><code>ln</code>: links。为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。e.g. <code>ln log2013.log ln2013</code></li>
<li><code>mount</code>：将一个设备（通常是存储设备）挂接到一个已存在的目录上。访问这个目录就是访问该存储设备。e.g. 将 <code>/dev/hda1</code> 挂在 <code>/mnt</code> 之下: <code>mount /dev/hda1 /mnt</code></li>
<li><code>wget</code>: 使用wget从网上下载软件、音乐、视频. e.g. <code>wget -O a.zip http://www.vim.org/scripts/download_script.php?src_id=7701</code></li>
<li><code>file</code>: 该命令用于判断接在file命令后的文件的基本数据，因为在Linux下文件的类型并不是以后缀为分的，所以这个命令对我们来说就很有用。e.g. <code>file file_name</code></li>
<li><code>lsof</code>:列出当前系统打开文件(list open files)，不过通过-i参数也能查看端口的连接情况，-i后跟冒号端口可以查看指定端口信息，直接-i是系统当前所有打开的端口. e.g. <code>lsof -i:22</code></li>
<li><code>read</code>: 从terminal 读入输入。实现交互式shell。e.g.  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read website</span><br><span class="line">echo &quot;你输入的网站名是 $website&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><code>let</code>: 用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。e.g. <code>let a=5+4</code></li>
<li><code>history</code>: 查看命令行中的历史命令。 <code>history -100</code>表明显示最近一百条命令行</li>
<li><code>mpstat</code>: mpstat 是 Multiprocessor Statistics的缩写，是实时监控工具，报告与cpu的一些统计信息这些信息都存在/proc/stat文件中，在多CPU系统里，其不但能查看所有的CPU的平均状况的信息，而且能够有查看特定的cpu信息，mpstat最大的特点是:可以查看多核心的cpu中每个计算核心的统计数据；而且类似工具vmstat只能查看系统的整体cpu情况。</li>
</ul>
<h2 id="待加入的部分">待加入的部分</h2>
<p>log in time for all users:<br>
lastlog</p>
<p>log in time for me:<br>
lastlog | grep gao</p>
<p>检查CPU使用率 从大到小排序<br>
ps auxw --sort=%cpu</p>
<p>list all files:<br>
ls -l</p>
<p>看file system 的大小和使用情况<br>
df -h</p>
<p><a href="http://www.cnblogs.com/peida/archive/2012/10/30/2746968.html">http://www.cnblogs.com/peida/archive/2012/10/30/2746968.html</a><br>
<a href="http://mark-ztw.iteye.com/blog/1544367">http://mark-ztw.iteye.com/blog/1544367</a></p>
<p>查看文件大小，文件夹大小：du -sm *,du -h, du *, du -sm, du -h *,<br>
查看文件多少行：wc -l 2018092121.tsv</p>
<p>[root@linux ~]# tar -cvf /tmp/etc.tar /etc  &lt;==仅打包，不压缩！</p>
<p>[root@linux ~]# tar -czvf /tmp/etc.tar.gz /etc  &lt;==打包后，以 gzip 压缩</p>
<p>[root@linux ~]# tar -cjvf /tmp/etc.tar.bz2 /etc  &lt;==打包后，以 bzip2 压缩</p>
<p>把tar包分成多个小文件：split -b 40M home1.tar.bz2 “home.tar.bz2.part”<br>
把多个小文件合并：cat home.tar.bz2.parta* &gt; home2.tar.bz2</p>
<p>linux 并行执行。用&amp; 和 wait 综合操作。<br>
&amp; 表示并行<br>
wait可以再等前面执行完，串行回来<br>
<a href="https://blog.csdn.net/gua___gua/article/details/48682665">https://blog.csdn.net/gua___gua/article/details/48682665</a></p>
<p>如果remove 一个folder ,然后不出现一个一个文件删除的确认的话，需要用<br>
rm -rf folder/<br>
一个一个文件删除的话 用：<br>
rm -r folder/</p>
<p>Shell cheat sheet:<br>
<a href="https://devhints.io/bash">https://devhints.io/bash</a></p>
<p>对于shell 来说，如果想下一个命令要在上一个命令完成之后才开始的话，需要在每行命令后面加上 &amp;&amp; 符号 <a href="https://blog.csdn.net/ysdaniel/article/details/6127860">https://blog.csdn.net/ysdaniel/article/details/6127860</a></p>
<p><a href="https://blog.csdn.net/tiwoo/article/details/51094913">https://blog.csdn.net/tiwoo/article/details/51094913</a></p>
<p>有zsh 也有bash. 对应的配置文件为zshrc 和 bashrc. 为了查看到底机器用的是哪个shell, 用<br>
echo $SHELL 来查看。</p>
<p>bashrc 和 bash_profile 的区别： <a href="https://justcoding.iteye.com/blog/2120331">https://justcoding.iteye.com/blog/2120331</a></p>
<h2 id="quickly-log-in-remote-sever">quickly log in remote sever</h2>
<p>reference:<br>
<a href="http://blog.csdn.net/leexide/article/details/17252369">http://blog.csdn.net/leexide/article/details/17252369</a><br>
<a href="https://my.oschina.net/aiguozhe/blog/33994">https://my.oschina.net/aiguozhe/blog/33994</a></p>
<p>process:<br>
local server:</p>
<ol>
<li>ssh-keygen -t rsa (连续三次回车,即在本地生成了公钥和私钥,不设置密码)</li>
<li>ssh <a href="mailto:root@172.24.253.2">root@172.24.253.2</a> “mkdir .ssh;chmod 0700 .ssh” (需要输入密码， 注:必须将.ssh的权限设为700) (if remote server doesn’t have ssh file)</li>
<li>scp ~/.ssh/id_rsa.pub <a href="mailto:root@172.24.253.2">root@172.24.253.2</a>:.ssh/id_rsa.pub (需要输入密码)</li>
</ol>
<p>remote server:<br>
1.<br>
cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys<br>
2.<br>
chmod 600 authorized_keys<br>
3.<br>
chmod 700 -R ~/.ssh<br>
注意都要在对应.ssh 文件目录下进行</p>
<h2 id="Use-anaconda-in-the-server">Use anaconda in the server</h2>
<p>every time to use anaconda pip, you need to execute the command first to find the path:</p>
<p>##虚拟环境<br>
play with IU server<br>
which virtualenv</p>
<p>virtualenv venv<br>
module load python/2.7</p>
<p>pip install gensim<br>
156  virtualenv venv<br>
157  pip install gensim virtualenv venv<br>
158  virtualenv venv<br>
159  virtualenv<br>
160  pwd<br>
161  pip install virtualenv<br>
162  free -g<br>
163  history</p>
<p>164  virtualenv</p>
<p>export PATH=/home/gao27/anaconda/bin:$PATH<br>
或者把这行代码写入~/.bashrc 中，然后 source ~/.bashrc</p>
<p>install Anaconda in server<br>
<a href="https://docs.anaconda.com/anaconda/install/linux">https://docs.anaconda.com/anaconda/install/linux</a></p>
<p>install pip directly:<br>
<a href="https://pip.pypa.io/en/stable/installing/#id7">https://pip.pypa.io/en/stable/installing/#id7</a></p>
<h2 id="python-2-7-and-3-5">python 2.7 and 3.5</h2>
<p><a href="http://conda.pydata.org/docs/py2or3.html">http://conda.pydata.org/docs/py2or3.html</a></p>
<p>$ conda create -n py35 python=3.5 anaconda</p>
<h1></h1>
<h1>To activate this environment, use:</h1>
<h1>$ source activate py35 (source activate py3)</h1>
<h1></h1>
<h1>To deactivate this environment, use:</h1>
<h1>$ source deactivate</h1>
<p>##Linux command<br>
sync local files to remote server:</p>
<p>rsync -avz ./health_care <a href="mailto:gao27@burrow.soic.indiana.edu">gao27@burrow.soic.indiana.edu</a>😕/nfs/nfs4/home/gao27/health_care</p>
<p>sync remote server files to local:<br>
rsync -avz <a href="mailto:gao27@burrow.soic.indiana.edu">gao27@burrow.soic.indiana.edu</a>😕/nfs/nfs4/home/gao27/health_care ./</p>
<p>/usr/libexec/java_home -verbose can return all javas in your computer</p>
<p>把一个文件的前十行 存到另外一个文件中</p>
<p>sed -n -e ‘1,10p’ test.csv &gt; sample.csv</p>
<p>ps aux 指令详解<br>
<a href="https://blog.csdn.net/hanner_cheung/article/details/6081440">https://blog.csdn.net/hanner_cheung/article/details/6081440</a></p>
<p>df -h 查看分区剩余容量</p>
<p>d -i 查看index的剩余容量</p>
<p>du -h -d 1 查看当前文件夹大小</p>
<p>vim 的教程：<br>
<a href="https://harttle.land/2015/11/07/vim-cursor.html">https://harttle.land/2015/11/07/vim-cursor.html</a></p>
<p>使用&amp;和wait改造<br>
在每个进程中使用&amp;符号进行让脚本在后台运行，无需等待当前进程结束。<br>
为了确保每个进程都执行完成，最后务必使用wait关键字，用来确保每一个子进程都执行完成。<br>
[root@artisan test]# cat call_parallel.sh<br>
#!/bin/bash<br>
#当前目录下执行如下脚本  相对路径<br>
./1.sh &amp;<br>
./2.sh &amp;<br>
wait<br>
echo “继续执行剩下的逻辑…”<br>
[root@artisan test]#</p>
<p>文件重命名：<a href="https://www.cnblogs.com/longdouhzt/archive/2012/04/30/2477282.html">https://www.cnblogs.com/longdouhzt/archive/2012/04/30/2477282.html</a><br>
推荐书籍：</p>
<ul>
<li>Linux命令行与shell脚本编程大全</li>
<li>Linux+Shell脚本攻略</li>
<li>Bash Notes For Professionals</li>
</ul>
<p>参考文献：</p>
<ul>
<li><a href="https://blog.csdn.net/whatday/article/details/78929247">几种常见的Shell</a></li>
<li><a href="https://blog.csdn.net/u012150179/article/details/16877323">Linux和Unix的区别</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32274264">CentOS、Ubuntu、Debian三个linux比较异同</a></li>
<li><a href="https://devhints.io/bash">Bash Scripting Cheatsheet</a></li>
<li><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全</a></li>
<li><a href="https://blog.51cto.com/lq2419/1238880">Linux文本处理工具</a></li>
<li><a href="http://c.biancheng.net/cpp/view/2740.html">Shell教程</a></li>
<li><a href="https://www.cnblogs.com/peida/archive/2012/12/24/2831353.html">top命令详解</a></li>
<li><a href="https://www.cnblogs.com/peida/archive/2012/12/25/2831814.html">free命令详解</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html">xargs命令详解</a></li>
<li><a href="https://blog.csdn.net/qq_18312025/article/details/78313414">条件测试命令</a></li>
<li><a href="https://blog.csdn.net/qq_41551450/article/details/92803686?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">各种括号详解</a></li>
<li><a href="http://c.biancheng.net/cpp/view/2736.html">运算符详解</a></li>
<li><a href="https://www.runoob.com/linux/linux-comm-awk.html">awk命令详解</a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
</ul>
]]></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>programming language</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>美国PhD毕业生OPT申请tips</title>
    <url>/blog/2020/02/01/%E7%BE%8E%E5%9B%BDPhD%E6%AF%95%E4%B8%9A%E7%94%9FOPT%E7%94%B3%E8%AF%B7tips/</url>
    <content><![CDATA[<p>博主最近在忙毕业申请OPT的事情，发现真的是好多坑，好多细节要注意。这里列一下自己OPT申请的timeline 以及注意的一些细节问题。之后如果有H1B和绿卡申请相关的信息，也会同步更新到此篇博客中。出门打工不易，且行且珍惜吧😆</p>
<span id="more"></span>
<h2 id="毕业申请">毕业申请</h2>
<h2 id="OPT申请">OPT申请</h2>
<p>博主由于是刚准备博士毕业，所以申请的是post-completion OPT。</p>
<h3 id="关于CPT-pre-completion-OPT-post-completion-OPT-和-stem-OPT的区别">关于CPT, pre-completion OPT,  post-completion OPT 和 stem OPT的区别</h3>
<ul>
<li>CPT：暂时地允许持有美国 F-1 签证的国际学生通过就业、带薪或无薪实习或合作教育获得与其专业直接相关的实践经验。它必须是某个既定课程的一部分。CPT 必须在毕业前完成。此外，CPT 可以是兼职（每周至多 20 小时）或全职（每周至少 20 小时）的。但是，如果你在 CPT 计划中全职工作了 12 个月，你将失去 OPT 的资格。</li>
<li>Pre-completion OPT：毕业前OPT。工作时长要求：上学期间每周工作时间不能超过20小时；但是在假期里可以做full time工作，也就是一周工作40小时。申请时间：申请Pre-completion OPT之前必须在一所美国大学内完成至少一学年的学习。Pre-completion OPT最早的申请日期是你第一学年结束前的90天。</li>
<li>Post-completion OPT：毕业后12个月的OPT。工作时长要求：每周必须工作至少20小时。而且Post-completion OPT期间失业天数累积不可超过90天。申请时间：根据移民局的规定，Post-completion OPT的申请材料必须在学业结束前的90天到结束后的60天之内寄到移民局。</li>
<li>stem OPT：Stem专业的学生在第一个post-completion OPT结束之后能够延长24个月的OPT，需要从新申请。和post-completion OPT走几乎一样的流程。每六个月需要提交一次针对于为期六个月的数据验证报告<br>
在起初的十二个月需要提交一次针对于为期十二个月的自我评估；在二十四个月将要结束的时候提交一份总结二十四个月的自我评估。</li>
</ul>
<h3 id="Ph-D申请OPT注意事项">Ph.D申请OPT注意事项</h3>
<ul>
<li>申请的越早越好，以防不能及时拿到EAD工卡（但还是要和你的job start date时间上衡量下，以防超过60天的grace period）。由于Ph.D的program completion date 的选择非常的flexible, 所以建议能越早申请越好。</li>
<li>program completion date 到EAD卡下来且OPT start date 开始之前，不能有任何校内校外的工作。</li>
<li>只要Ph.D所需的学分修完，即可申请OPT。但是最终答辩和论文的提交最晚需要在第一次OPT结束前都搞定。即OPT开始后一年内完成答辩都可以。</li>
<li>千万论文最终稿的提交不能在program completion date 之前完成。否则OPT会失效。</li>
<li>有些学校如果毕业后不能保存学生邮箱的话，需要和学校IT部门清求extend一下时间，以防重要信息接收不到。在博主所在的indiana university bloomington, 在program complete date 之后，email就不能用了。</li>
<li>stem opt extension 是和post-completion OPT相似的流程，还是需要从新申请。在当前OPT结束前90天申请。</li>
<li>地址更换之后的10天内一定要在OIS自己的portal里面更改信息。</li>
<li>OPT开始后要在第一时间把雇主信息填到OIS相关的页面上面。</li>
<li>OPT的开始和结束之前都有60天的grace period时间，是可以允许没有工作的。</li>
</ul>
<h3 id="申请准备时间线">申请准备时间线</h3>
<ul>
<li>最后一个学期一开始就要参加OPT的information session,听一下学校OIS工作人员的讲解特别必要。</li>
<li>和advisor 商量好毕业的时间点，比如program completion date.</li>
<li>在学校的OIS官网上面提交申请，预约OPT intake appointment,同时着手准备材料。</li>
<li>OPT申请可以在program completion date 前90天直到后60天内都可以完成。但是因为一般OPT需要2-4个月处理，所以还是越早越好。将申请材料邮寄至你所在地区的USCIS。</li>
<li>和OIS的intake appointment 结束之后，OIS会提供新的OPT I20。此时后的30天内，需要让USCIS收到自己的OPT申请。记住不是提交时间，而是USCIS确认的收到时间。</li>
<li>确认移民局收到了你的申请材料，查询申请状态。一般，在3-5周内会收到移民局寄来的I-797纸质收据，即可获得“申请收据号（Receipt Number）”，根据该收据号可以再移民局官网查询你的申请进度：<a href="https://egov.uscis.gov/casestatus/landing.do">https://egov.uscis.gov/casestatus/landing.do</a>。</li>
<li>及时向学校和政府上报你的OPT雇主。OPT开始后，必须在90天内上报工作信息，如果90天内未上报或者没有找到工作，OPT将被终止，需要离开美国。<a href="https://www.1point3acres.com/bbs/thread-514984-1-1.html">参考链接1</a>. <a href="https://internationalservices.ncsu.edu/student-employment/optional-practical-training/update-your-employment-information-in-the-sevp-portal/">参考链接2</a></li>
</ul>
<img src="timeline.png" alt="timeline"/> 
<h3 id="递交材料的内容">递交材料的内容</h3>
<ul>
<li>G1145表格，放在申请首页，用来告诉USCIS自己的联系方式。</li>
<li>两张US护照格式的照片，把姓名，生日，SEVIS ID和I94 ID都用铅笔写在照片背后。</li>
<li>I-765表格，严格按照要求填写，具体怎么填OIS会在OPT info session 上面介绍，参考文献中博主也列了一些参考的网页。记住，最后签名的部分，一定要用黑色水笔！Part 2 #27: 如果是post-completion OPT的话，记得选择 (c-3-B)。</li>
<li>支付EAD工卡申请费$410，收款人为U.S. Department of Homeland Security，不可使用现金，需开具个人支票（ 需要同时提交Form G-1450 Authorization for Credit Card Transactions (<a href="http://www.uscis.gov">www.uscis.gov</a>））、或Money Order。</li>
<li>OPT I20 的复印件（OPT intake appointment 之后OIS会直接给）。</li>
<li>I94的最近记录。</li>
<li>以前的EAD卡（如果有的话）。</li>
<li>护照的信息页，签证页和盖章页（信息页必须提供，后两者最好还是提供）。</li>
</ul>
<p>参考文献：</p>
<ul>
<li><a href="https://posts.careerengine.us/p/5509f6b57eb79bd46d000047">CPT， Pre completion OPT和OPT的区别</a></li>
<li><a href="https://opttimeline.com">跟踪OPT的申请是否被接受的网站</a></li>
<li><a href="https://egov.uscis.gov/casestatus/landing.do">track自己case进度的网站</a></li>
<li><a href="https://familycfo101.com/from-i-765/">I-765填写指南1</a></li>
<li><a href="https://posts.careerengine.us/p/5bf866fcf87f1f2ed54130a4">I-765填写指南2</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/65258309">2019OPT申请攻略1</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/94930781">申请OPT攻略2</a></li>
<li><a href="https://dreamgo.com/opt%E7%94%B3%E8%AF%B7/">申请OPT攻略3</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/220119597">STEM OPT汇报义务1</a></li>
<li><a href="https://sevissavvy.com/stem-opt-reporting-cn/">STEM OPT汇报义务2</a></li>
</ul>
<h2 id="H1B申请">H1B申请</h2>
<h2 id="绿卡申请">绿卡申请</h2>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>opt</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建VPN</title>
    <url>/blog/2022/08/06/%E6%90%AD%E5%BB%BAVPN/</url>
    <content><![CDATA[<p>本文记录如何在云服务器中（Linux和Window系统）搭建VPN服务端来进行科学上网。</p>
<span id="more"></span>
<h2 id="CentOS系统">CentOS系统</h2>
<h3 id="Shadowsocks配置服务端">Shadowsocks配置服务端</h3>
<ol>
<li>
<p>首选购买一个云服务器，推荐使用腾讯云的轻量级服务器，并且安装CentOS系统的实例。</p>
</li>
<li>
<p>系统默认应该已经装好wget命令，如果没有，运行以下命令安装</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install wget #CentOS</span><br><span class="line">sudo apt-get install wget #Debian/Ubuntu</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>运行以下一键脚本：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br><span class="line">chmod +x shadowsocks-all.sh</span><br><span class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure>
<p>安装途中如果报错不能下载github中的shadowsocks源代码，可以自行尝试下载</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://github.com/shadowsocks/shadowsocks/archive/master.zip </span><br></pre></td></tr></table></figure>
<p>如果后续报错无法解压<code>shadowsocks-master.zip</code>,可以改变源代码zip文件名</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv master.zip shadowsocks-master.zip</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将以上命令粘贴到 Xshell 窗口，回车执行代码，然后会提示有以下4种安装选项，分别是“1) Shadowsocks-Python”、“2) ShadowsocksR”、“3) Shadowsocks-Go”、“4) Shadowsocks-libev”。如果我们选择第2个就是搭建SSR服务器了，我们这里选第1个，搭建Shadowsocks/SS服务器。如下图所示：<br>
<img src="1.png" alt="1.png"/></p>
</li>
<li>
<p>我这里以安装第1个“Shadowsocks-Python”为例演示，输入数字“1”后回车，然后进入Shadowsocks服务器的参数配置选项，依次为“服务器连接密码”、“服务器端口”、“数据加密方式”（图中红杠和箭头标识的内容仅为演示，请根据你自己的需求输入即可）。其中，我这里建议你选择chacha20相关的加密方式（因为这些新加密方式的抗封锁效果更好）。如下图所示：<br>
<img src="2.png"  width="30%" alt="2.png"/></p>
</li>
<li>
<p>当以上参数选项都输入完毕后，敲击回车键。然后系统会提示“Press any key to start…or Press Ctrl+C to cancel“，即按任意键继续。当我们按任意键之后，系统会进入安装Shadowsocks服务的过程，稍等片刻即可完成。安装Shadowsocks服务成功完成后，如下图所示：<br>
<img src="3.png" alt="3.png"/><br>
如上图所示，其中各项参数释义如下：<br>
Your Server IP :你的服务器 IP 地址；<br>
Your Server Port :你的服务器端口；<br>
Your Password :你的连接密码；<br>
Your Encryption Method:你的加密方式；<br>
Your QR Code:你的SS链接；<br>
Your QR Code has been saved as a PNG file path:你的SS链接二维码图片的存放位置。</p>
</li>
<li>
<p>开启防火墙的端口。具体端口号要和之前开的服务器端口相同。修改位置见下：<br>
<img src="4.png" alt="4.png"/><br>
至此，你已经成功搭建Shadowsocks/SS服务器，现在就可以使用了。</p>
</li>
<li>
<p>其他命令:</p>
<ol>
<li>
<p>卸载方法<br>
若已安装多个版本，则卸载时也需多次运行（每次卸载1种），请使用root用户登录，执行以下命令：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./shadowsocks-all.sh uninstall</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>脚本控制命令<br>
脚本后面的参数含义：启动，停止，重启，查看状态。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shadowsocks-Python 版：</span><br><span class="line">/etc/init.d/shadowsocks-python start | stop | restart | status</span><br><span class="line">	</span><br><span class="line">ShadowsocksR 版：</span><br><span class="line">/etc/init.d/shadowsocks-r start | stop | restart | status</span><br><span class="line">	</span><br><span class="line">Shadowsocks-Go 版：</span><br><span class="line">/etc/init.d/shadowsocks-go start | stop | restart | status</span><br><span class="line">	</span><br><span class="line">Shadowsocks-libev 版：</span><br><span class="line">/etc/init.d/shadowsocks-libev start | stop | restart | status</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>默认配置文件</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shadowsocks-Python 版：</span><br><span class="line">/etc/shadowsocks-python/config.json</span><br><span class="line">	</span><br><span class="line">ShadowsocksR 版：</span><br><span class="line">/etc/shadowsocks-r/config.json</span><br><span class="line">	</span><br><span class="line">Shadowsocks-Go 版：</span><br><span class="line">/etc/shadowsocks-go/config.json</span><br><span class="line">	</span><br><span class="line">Shadowsocks-libev 版：</span><br><span class="line">/etc/shadowsocks-libev/config.json</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="一键安装并开启BBR加速">一键安装并开启BBR加速</h3>
<p>一键安装BBR加速脚本，执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/src &amp;&amp; wget -N --no-check-certificate &quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行以上安装命令后，如下图所示：<br>
<img src="5.png" alt="5.png"/><br>
我这里选择“2”，“安装 BBRplus版内核”加速。在安装过程中，可能会出现如下提示，用右方向键选“<No>”，然后回车(实际安装过程中本人并未遇到这个提示)。如下图所示：<br>
<img src="6.png" alt="6.png"/><br>
安装完成后会提示重启服务器，这时候输入字母“y”，回车后，重启服务器。当服务器启动后，我们再次执行安装命令<code>./tcp.sh</code>，选择“7”启用“使用BBRplus版加速”。至此，BBR Plus 加速模块安装并启用完成。<br>
理论上安装完加速脚本之后运行速度应该有所提高。实际上楼主在shadowrocket上面测试延迟，安装加速脚本前后并未有明显变化。</p>
<h2 id="Windows系统">Windows系统</h2>
<h3 id="Shadowsocks配置服务端-v2">Shadowsocks配置服务端</h3>
<ol>
<li>
<p>首选购买一个云服务器，推荐使用腾讯云的轻量级服务器，并且安装Windows12系统的实例。</p>
</li>
<li>
<p>下载安装nodejs。下载地址：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a> ,下载LTS长期支持版本，然后安装NodeJS，直接下一步。</p>
</li>
<li>
<p>安装shadowsocks。<br>
打开Node.js command prompt，此为nodejs的命令端，直接在Windows里面搜索就可以找到。输入命令<br>
<code>npm install -g shadowsocks</code>安装shadowsocks.</p>
</li>
<li>
<p>因为shadowsocks所在的文件夹是隐藏文件夹，所以要开启显示隐藏文件。点击“这台电脑”-&gt; “查看”，勾选“隐藏的项目”即可。如下图所示：<br>
<img src="9.jpeg" alt="9.jpeg"/></p>
</li>
<li>
<p>进入node.js安装目录<code>C:\Users\Administrator\AppData\Roaming\npm\node_modules\shadowsocks</code>，找到config.json后更改为如下形式保存。如果找不到安装目录的话，可以直接在Node.js command prompt命令段输入<code>ssserver</code>，第一栏就会出现对应的路径。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,#服务器IP</span><br><span class="line">    &quot;server_port&quot;:13416, #要使用的服务器端口号，事先确认下端口号是否使用过</span><br><span class="line">    &quot;local_address&quot;:&quot;127.0.0.1&quot;, #本地监听地址 默认不改</span><br><span class="line">    &quot;local_port&quot;:1080, #代理端口号，一般都默认1080</span><br><span class="line">    &quot;password&quot;:&quot;barfoo!&quot;, #更改为你的密码</span><br><span class="line">    &quot;timeout&quot;:600,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot; #建议aes-256-cfb就好</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果将server设成公网IP地址的话会报错，改为<code>0.0.0.0</code>即可解决问题。</p>
</li>
<li>
<p>启动shadowsocks。通过Node.js command prompt输入<code>ssserver</code>启动。显示如下图的话即为安装成功<br>
<img src="10.png" alt="10.png"/></p>
</li>
<li>
<p>以防被屏蔽，在服务器的防火墙栏添加ssserver对应的端口。</p>
</li>
</ol>
<h2 id="ios手机客户端配置">ios手机客户端配置</h2>
<ol>
<li>需要下载Shadowrocket app到苹果手机。</li>
<li>按照服务端的信息输入IP地址，端口，密码，加密方式。具体如下：<br>
<img src="7.jpeg"  width="30%" height="30%" alt="7.jpeg"/></li>
<li>global routing 选择proxy，这样上网产生的所有流量都会走服务器流量。</li>
<li>选择对应的服务器，可以点击Connectivity Test 来测试服务器的延迟。如果开始使用VPN的话，需要点击第一栏的按钮，连接VPN：<br>
<img src="8.jpeg"  width="30%" height="30%" alt="8.jpeg"/></li>
</ol>
<h2 id="参考文献">参考文献</h2>
<ul>
<li><a href="https://xyzardq.github.io/2017/04/14/Windows%E4%B8%8B%E6%90%AD%E5%BB%BAShadowoscks%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/">Windows下搭建Shadowsocks服务器端</a></li>
<li><a href="https://xfj0.cn/archives/94.html">在Windows server上安装Shadowsocks服务端</a></li>
<li><a href="https://iyideng.net/black-technology/cgfw/best-onekey-build-v2ray-server-script.html#2%E3%80%81multi-v2ray_%E5%A4%9A%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E8%84%9A%E6%9C%AC">multi-v2ray 多用户管理脚本</a></li>
<li><a href="https://iyideng.net/black-technology/cgfw/shadowsocks-ss-server-building-and-using-tutorial.html">使用Shadowsocks配置服务端</a></li>
<li><a href="https://www.skyfinder.cc/2018/11/13/windowsinstallnodejsshadowsocks/">在Windows上安装nodejs版shadowsocks服务端</a></li>
<li><a href="https://blog.heyfe.org/blog/2014-12-06-shadowsocks.html">Shadowsocks 搭建</a></li>
<li><a href="https://blog.whsir.com/post-559.html">ss windows server配置</a></li>
<li><a href="https://xfj0.cn/archives/94.html">在windows server上安装Shadowsocks服务端</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cloud service</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯云使用教程</title>
    <url>/blog/2022/07/30/%E8%85%BE%E8%AE%AF%E4%BA%91%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>本文是作者购买了腾讯云账号后，总结的如何使用腾讯云账户的教程。</p>
<span id="more"></span>
<h1>简单使用指南tips</h1>
<ol>
<li>登录账号后找到购买的<a href="https://console.cloud.tencent.com/lighthouse/instance">轻量应用服务器页面</a>，点击对应的实例即可登录</li>
<li>购买之后，公网IP和对应的实例基本信息可以在<a href="https://console.cloud.tencent.com/message">站内信</a>中查看</li>
<li>Mac OS 系统通过远程桌面上传文件到 Windows 轻量应用服务器(<a href="https://cloud.tencent.com/document/product/1207/53218">https://cloud.tencent.com/document/product/1207/53218</a>)</li>
<li>Mac使用Microsoft Remote Desktop Beta实现远程登录Windows服务器(<a href="https://cloud.tencent.com/document/product/1207/44579">https://cloud.tencent.com/document/product/1207/44579</a>) 需要在腾讯云实例的防火墙添加规则：允许访问端口号3389。此为默认的Windows远程登录的端口号。如果不是，可以在服务器主页点击WebRDP登录，弹出的窗口会显示对应的端口号。</li>
<li>搭建 CentOS 可视化界面(<a href="https://cloud.tencent.com/document/product/213/59484">https://cloud.tencent.com/document/product/213/59484</a>)</li>
<li>如何将本地文件拷贝到轻量应用服务器（<a href="https://cloud.tencent.com/document/product/1207/53135%EF%BC%89">https://cloud.tencent.com/document/product/1207/53135）</a></li>
</ol>
<h1>构建WordPress网站</h1>
<h2 id="参考文献">参考文献</h2>
<ul>
<li><a href="https://cloud.tencent.com/document/product/1207/44579">使用远程桌面连接登录Windows实例</a></li>
<li><a href="https://cloud.tencent.com/document/product/1207">轻量应用服务器文档中心</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cloud service</tag>
      </tags>
  </entry>
  <entry>
    <title>股市基础知识整理</title>
    <url>/blog/2021/02/06/%E8%82%A1%E5%B8%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>本文简要整理一些股市的基础概念，以便自己日后查找。对于理财，除了买定期和国债外，还可以考虑一下股市。不过股市有风险，入市需谨慎~</p>
<span id="more"></span>
<h2 id="基础概念">基础概念</h2>
<h3 id="一级市场和二级市场">一级市场和二级市场</h3>
<p>对于一级市场，是公司本身将证券卖给投资者，这个买卖价款是会给到公司的。而对于二级市场，是投资者之间互相买卖，理论上，无论怎么买卖，公司都收不到一分钱。<br>
一二级市场的联系：首先一级市场是二级市场的基础，如果不在一级市场卖出去，公司的证券就不会流到二级市场。而二级市场又是一级市场存在的条件，因为二级市场为公司证券提供了流动性。</p>
<h3 id="空头和多头">空头和多头</h3>
<ul>
<li>做多：是一种金融市场如股票、外汇或期货等术语：就是看好股票、外汇或期货等未来的上涨前景而进行买入持有等待上涨获利。 做多就是做多头，多头对市场判断是上涨，就会立即进行股票买入，所以做多就是买入股票、外汇或期货等。</li>
<li>做空：做空，是一个投资术语，是金融资产的一种操作模式。与做多相对，做空是先借入标的资产，然后卖出获得现金，过一段时间之后，再支出现金买入标的资产归还。做空的常见作用有投机、融资和对冲。其中用做空投机是指预期未来行情下跌，则卖高买低，将手中借入的股票按目前价格卖出，待行情跌后买进再归还，获取差价利润。其交易行为特点为先卖后买。实际上有点像商业中的赊货交易模式。这种模式在价格下跌的波段中能够获利，就是先在高位借货进来卖出，等跌了之后再买进归还。在外汇交易和股票交易市场中，常见有做多做空字眼。</li>
</ul>
<h3 id="期权Options">期权Options</h3>
<p>简单来说，期权就是一个特定时间内的一种交易选择权，由A和B两个交易方就某个资产以未来某日的某个交易价格形成的契约。Options作为投资或投机的方法，首先你要了解它的风险性。Options从交易方法来看，可以有4种方法：</p>
<ul>
<li>买入看涨期权（Long Calls）：看涨股票时，一般可以买入看涨期权</li>
<li>买入看跌期权（Long Puts）：看跌股票时，一般可以买入看跌期权</li>
<li>卖出看涨期权（Short Calls）：看跌股票时，可以卖出看涨期权。（裸卖Call，潜在最大损失无限大。）</li>
<li>卖出看跌期权（Short Puts）：看涨股票时，可以卖出看跌期权。（高风险，潜在最大损失有上限）</li>
</ul>
<h3 id="ETF-mutual-fund-index-fund">ETF, mutual fund, index fund</h3>
<ul>
<li>共同基金（mutual fund）：共同基金一般为主动管理型。基金经理和投资团队会每天进行仓位的调整和买卖。因此，投资仓位方面共同基金更加灵活。</li>
<li>ETF (Exchange－Traded Funds)：多数ETF是被动型基金，追踪某一指数(比如S&amp;P500)或某一市场。因此ETF的异质性风险（idiosyncratic risk）较低。每个季度基金经理会调整并公布仓位，调整后一个季度内一般不进行主动调仓。</li>
<li>指数基金（index fund）：指数基金就是以特定指数(如S&amp;P500)为标的指数，并以该指数的成份股为投资对象，以追踪标的指数表现的基金产品。</li>
</ul>
<p>ETF和mutual fund 都是选很多的股票，通常几百几千支都有，组成一个portfolio。ETF 通常是track一个指数，mutual fund可以跟指数或者基金经理自己选择股票。<br>
mutual fund分为封闭式基金和开放式基金，封闭式基金就是在认购之后，投资人在规定时间内不能进行申购和赎回，需要等到下一轮开放。题主关心的应该是开放式基金，和ETF 更相似。开放式基金是不在交易所交易的，而是在每一天闭市之后进行交易，交易的价格是根据基金里包含的所有股票的当天的闭市价格来计算的。</p>
<h3 id="杠杆">杠杆</h3>
<p>杠杆，也称为风险水平，是经纪人为交易者提供的临时贷款。杠杆可让交易者以较少的本金进行高额交易。杠杆以倍数的形式表示，显示持仓金额是已投入金额的多少倍。<br>
让我们来举一个例子说明杠杆如何影响潜在收益或亏损。如果您本金有1,000美元，不加杠杆，则您投资的资产价格每上涨1%，您就可以获利10美元，反之，您将亏损10美元，这均相当于本金1,000美元的1%。相反，如果您同样投入1,000美元，但使用10倍杠杆，则您的持仓价值将等于10,000美元。10,000美元的1%相当于100美元，所以市场若上涨1%，您就可以获利100美元，反之，您将亏掉100美元。</p>
<h2 id="基本券商">基本券商</h2>
<ul>
<li>新型券商，适用于新手，可以部分买卖股票，0佣金：Robinhood，webull（微牛证券），MooMoo（富途证券），TradeUP（老虎证券）</li>
<li>智能顾投(robo-advisor)：Betterment，Wealthfront。即根据调查问卷评估所得到的你的个人情况，加上你对于投资激进vs保守的倾向，通过程序自动生成你的portfolio。</li>
<li>老牌券商：Fidelity, Charles Schwab, Vanguard，TD Ameritrade，ETRADE，Merrill Edge<br>
<img src="broker.png" alt="broker" width="500"/></li>
</ul>
<p>参考文献：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/59059660">美股期权</a></li>
<li><a href="https://xueqiu.com/5974914861/24635776">美股期权交易详解</a></li>
<li><a href="https://www.youtube.com/watch?v=vGcOGYkttI4">Index Funds vs Mutual Funds vs ETF</a></li>
<li><a href="https://www.etoro.com/zh/customer-service/help/52811819/%E4%BB%80%E4%B9%88%E6%98%AF%E6%9D%A0%E6%9D%86/#:~:text=%E6%9D%A0%E6%9D%86%EF%BC%8C%E4%B9%9F%E7%A7%B0%E4%B8%BA%E9%A3%8E%E9%99%A9,%E6%8A%95%E5%85%A5%E9%87%91%E9%A2%9D%E7%9A%84%E5%A4%9A%E5%B0%91%E5%80%8D%E3%80%82&amp;text=%E5%A6%82%E6%9E%9C%E6%82%A8%E6%9C%AC%E9%87%91%E6%9C%89,%E9%87%911%2C000%E7%BE%8E%E5%85%83%E7%9A%841%25%E3%80%82">什么是杠杆</a></li>
<li><a href="https://www.facebook.com/PappaCollege/posts/2122872681325313/">杠杆投资</a></li>
<li><a href="https://www.stockbrokers.com/compare/robinhood-vs-webull">券商比较</a></li>
<li><a href="https://www.dealmoon.com/guide/950327">券商比较2</a></li>
<li><a href="https://www.guruin.com/articles/4955">Robo Advisors推荐</a></li>
</ul>
]]></content>
      <categories>
        <category>finance</category>
      </categories>
      <tags>
        <tag>stock</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯云安装WordPress的Tips</title>
    <url>/blog/2022/08/15/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%AE%89%E8%A3%85WordPress%E7%9A%84Tips/</url>
    <content><![CDATA[<p>本文介绍一些在腾讯云轻量服务器上手动安装WordPress时需要注意的一些方面。笔者是在Windows 12系统上进行操作的。</p>
<span id="more"></span>
<h2 id="安装步骤">安装步骤</h2>
<ol>
<li>具体安装步骤可以参考<a href="https://cloud.tencent.com/document/product/213/39540">https://cloud.tencent.com/document/product/213/39540</a></li>
<li>安装过程中楼主发现根据上述步骤安装后，只能在localhost里面打开WordPress，而不能在公网IP里面打开。这样导致没有办法对网站进行外部访问。解决办法为在数据库端把localhost改为公网IP。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; use wordpress;  #打开数据库后对该表wp_options 操作</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from wp_options where option_name=‘siteurl’</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">update wp_options set option_value=&#x27;http://124.223.188.213’ where option_name=&#x27;siteurl&#x27;;   #公网IP</span><br><span class="line"></span><br><span class="line">update wp_options set option_value=&#x27;http://http://124.223.188.213&#x27; where option_name=&#x27;home‘; #公网IP</span><br></pre></td></tr></table></figure>
</li>
<li>改好之后登录发现，虽然能进入主页，但是或许会显示无法登陆，显示账号密码错误。此时可以直接在mysql端进行操作，更新账户密码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; use wordpress; #登录具体的数据库</span><br><span class="line">mysql&gt; show tables; #查看数据库中的表格，要找到以users为结尾的表格，里面包括了WordPress的账号和密码</span><br><span class="line">mysql&gt; select * from wp_users # 查看具体内容</span><br><span class="line">mysql&gt; UPDATE wp_users SET user_pass=MD5(‘(new-password)’) WHERE ID = (id#-of-account-you-are-reseting-password-for);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>最后改好之后，就可以对公网IP进行访问。访问链接 <a href="http://124.223.188.213/wp-admin">http://124.223.188.213/wp-admin</a> 可以登录WordPress对网站进行修改。访问<a href="http://124.223.188.213">http://124.223.188.213</a> 即直接查看网站具体内容。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<ul>
<li><a href="https://blog.csdn.net/weixin_35888497/article/details/119665467?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0-119665467-blog-75408629.pc_relevant_multi_platform_whitelistv4eslandingrelevant2&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">wp网站更换服务器后打不开,WordPress站点更换公网IP后不能正常访问的解决过程</a></li>
<li><a href="https://blog.csdn.net/soar92/article/details/75408629">云服务器中安装wordpress，却不能使用公网IP进行访问</a></li>
<li><a href="https://wordpress.org/support/article/resetting-your-password/">Resetting Your Password</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cloud service</tag>
      </tags>
  </entry>
  <entry>
    <title>韩语歌曲Kpop</title>
    <url>/blog/2019/12/15/%E9%9F%A9%E8%AF%AD%E6%AD%8C%E6%9B%B2Kpop/</url>
    <content><![CDATA[<p>本文记录自己听韩语歌曲(Kpop为主)时比较喜欢的歌曲，男子/女子组合按照出道日期排序，链接为YouTube上歌曲对应的我自己比较喜欢的MV或者打歌舞台。不定期更新中。。。</p>
<span id="more"></span>
<h2 id="男子组合">男子组合</h2>
<h3 id="H-O-T-1996">H.O.T. (1996)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=GMsc7wGghy8">Candy</a></li>
<li><a href="https://www.youtube.com/watch?v=jnnOAfZXSFM">Happiness</a></li>
</ul>
<h3 id="Super-Junior-2005">Super Junior (2005)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=yrLHPdZf-t8">U</a></li>
<li><a href="https://www.youtube.com/watch?v=gOwERHxXcTs">Devil</a></li>
<li><a href="https://www.youtube.com/watch?v=7GqYSbc1tsM">One More Time</a></li>
<li><a href="https://www.youtube.com/watch?v=ZbB4SYJNuTo">Lo Siento</a></li>
</ul>
<h3 id="BIGBANG-2006">BIGBANG (2006)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=AAbokV76tkU">Fantastic Baby</a></li>
<li><a href="https://www.youtube.com/watch?v=2ips2mM7Zqw">Bang Bang Bang</a></li>
<li><a href="https://www.youtube.com/watch?v=e1ptAmZT1Vs">Fxxk It</a></li>
<li><a href="https://www.youtube.com/watch?v=MzCbEdtNbJ0">Haru Haru</a></li>
<li><a href="https://www.youtube.com/watch?v=VvXVuWwAG90">If You</a></li>
<li><a href="https://www.youtube.com/watch?v=9jTo6hTZmiQ">Let’s Not Fall In Love</a></li>
<li><a href="https://www.youtube.com/watch?v=1CTced9CMMk">Loser</a></li>
<li><a href="https://www.youtube.com/watch?v=TKD03uPVD-Q">Bae Bae</a></li>
<li><a href="https://www.youtube.com/watch?v=btDd9rOlc2k">Monster</a></li>
<li><a href="https://www.youtube.com/watch?v=T3O2oDm_L4U">D.I.S.C.O</a> (T.O.P)</li>
<li><a href="https://www.youtube.com/watch?v=NEECiywgjNI">Missing You</a> (GD)</li>
<li><a href="https://www.youtube.com/watch?v=RKhsHGfrFmY">Crooked</a> (GD)</li>
<li><a href="https://www.youtube.com/watch?v=UJfZ69MSlvY">Ringa Linga</a> (太阳)</li>
<li><a href="https://www.youtube.com/watch?v=rhHX-nnhP-Q">Mapsosa</a> (GD &amp; 太阳 &amp; 光熙)</li>
<li><a href="https://www.youtube.com/watch?v=UwuAPyOImoI">Eyes, Nose, Lips</a> (太阳)</li>
<li><a href="https://www.youtube.com/watch?v=9kaCAbIXuyg">Untitled</a> (GD)</li>
</ul>
<h3 id="2PM-2008">2PM (2008)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=KgrB2KBZws4">Hands Up</a></li>
</ul>
<h3 id="SHINee-2008">SHINee (2008)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=roughtzsCDI">Ring Ding Dong</a></li>
</ul>
<h3 id="Beast-2009">Beast (2009)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=ZAzWT8mRoR0">Fiction</a></li>
<li><a href="https://www.youtube.com/watch?v=ExZ8ha0VkxI">Without You</a></li>
</ul>
<h3 id="CNBLUE-2009">CNBLUE (2009)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=5pUfHnWRsRA">I’m A Loner</a></li>
</ul>
<h3 id="INFINITE-2010">INFINITE (2010)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=2nxNwzXIdtA">Back</a></li>
<li><a href="https://www.youtube.com/watch?v=DeuejYoRbps">Be Mine</a></li>
</ul>
<h3 id="BlockB-2011">BlockB (2011)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=WXYQ1oxalEc">Make It Rain</a> (BASTARZ 小分队)</li>
</ul>
<h3 id="EXO-2011">EXO (2011)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=KH6ZwnqZ7Wo">MAMA</a></li>
<li><a href="https://www.youtube.com/watch?v=TI0DGvqKZTI">Overdose</a></li>
<li><a href="https://www.youtube.com/watch?v=I3dezFzsNss">Growl</a></li>
<li><a href="https://www.youtube.com/watch?v=4EiNsoTc9kk">Dancing King</a></li>
<li><a href="https://www.youtube.com/watch?v=bc0XW89yKrk">Ko Ko Bop</a></li>
<li><a href="https://www.youtube.com/watch?v=l0YayoPk1jg">Call Me Baby</a></li>
<li><a href="https://www.youtube.com/watch?v=KSH-FVVtTf0">Monster</a></li>
</ul>
<h3 id="VIXX-2012">VIXX (2012)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=IF8kySIcWNw">Error</a></li>
</ul>
<h3 id="BTS-2013">BTS (2013)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=7C2z4GqqS5E">Fake Love</a></li>
<li><a href="https://www.youtube.com/watch?v=hmE9f-TEutc">Blood Sweat &amp; Tears</a></li>
<li><a href="https://www.youtube.com/watch?v=YPNpy-hg6yM">Go Go</a></li>
</ul>
<h3 id="Winner-2013">Winner (2013)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=bgLah5W7yK0">Fear</a> (闵浩)</li>
<li><a href="https://www.youtube.com/watch?v=gEqlF5N8UMs">Empty</a></li>
</ul>
<h3 id="iKON-2015">iKON (2015)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=ZS6vfv4sszg">My Type</a></li>
<li><a href="https://www.youtube.com/watch?v=RyVS7R9PN6U">Killing Me</a></li>
<li><a href="https://www.youtube.com/watch?v=vecSVX1QYbQ">Love Scenario</a></li>
</ul>
<h2 id="女子组合">女子组合</h2>
<h3 id="少女时代-2007">少女时代 (2007)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=YbbZScPIy7M">冷面</a> (Jessica)</li>
<li><a href="https://www.youtube.com/watch?v=IsU9V-A7QXE">Mr.Mr.</a></li>
<li><a href="https://www.youtube.com/watch?v=q_gfD3nvh-8">Run Devil Run</a></li>
<li><a href="https://www.youtube.com/watch?v=F4-SxcCO5d0">Hoot</a></li>
<li><a href="https://www.youtube.com/watch?v=EXZxc8GSXnI">Dancing Queen</a></li>
<li><a href="https://www.youtube.com/watch?v=6pA_Tou-DPI">The Boy</a></li>
</ul>
<h3 id="Kara-2007">Kara (2007)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=pk6u-XepUFs">Mister</a></li>
</ul>
<h3 id="Wonder-Girls-2007">Wonder Girls (2007)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=QZBn1e9pr2Q">Nobody</a></li>
<li><a href="https://www.youtube.com/watch?v=PYGODWJgR-c">Why So Lonely</a></li>
<li><a href="https://www.youtube.com/watch?v=aeo_nWsu5cs">Get It?</a> (誉恩)</li>
</ul>
<h3 id="宣美-2007">宣美 (2007)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=EuHc_2HrOus">Full Moon</a></li>
<li><a href="https://www.youtube.com/watch?v=ur0hCdne2-s">Gashina</a></li>
</ul>
<h3 id="泫雅-2007">泫雅 (2007)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=s-zRAQmKUkI">Trouble Maker</a> (Trouble Maker)</li>
<li><a href="https://www.youtube.com/watch?v=6pw972Kl3L0">Now</a> (Trouble Maker)</li>
<li><a href="https://www.youtube.com/watch?v=oTXCgR93zC8">Red</a></li>
<li><a href="https://www.youtube.com/watch?v=vcqImqOVE2U">Lip &amp; Hip</a></li>
<li><a href="https://www.youtube.com/watch?v=ib_1ATfr8wM">Roll Deep</a></li>
<li><a href="https://www.youtube.com/watch?v=8gPQenyj1nI">365 FRESH</a> (Triple H)</li>
<li><a href="https://www.youtube.com/watch?v=nPPKwg5eQ4o">Hot Issue</a> (4 Minute)</li>
<li><a href="https://www.youtube.com/watch?v=D_F9HUTYnl0">Hate</a> (4 Minute)</li>
<li><a href="https://www.youtube.com/watch?v=1nCLBTmjJBY">Crazy</a> (4 Minute)</li>
<li><a href="https://www.youtube.com/watch?v=H-IJWqIHioA">What’s Your Name?</a> (4 Minute)</li>
</ul>
<h3 id="IU-2008">IU (2008)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=EiVmQZwJhsA">Friday</a></li>
<li><a href="https://www.youtube.com/watch?v=U_KH7Tw97HU">Leon</a></li>
</ul>
<h3 id="2NE1-2009">2NE1 (2009)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=vLbfv-AAyvQ">Come Back Home</a></li>
<li><a href="https://www.youtube.com/watch?v=49AfuuRbgGo">Fire</a></li>
<li><a href="https://www.youtube.com/watch?v=j7_lSP8Vc3o">I Am The Best</a></li>
<li><a href="https://www.youtube.com/watch?v=8o4Zj98FeX4">Hello Bitches</a> (CL)</li>
</ul>
<h3 id="T-ara-2009">T-ara (2009)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=q_eo5j5sib8">Suger Free</a></li>
<li><a href="https://www.youtube.com/watch?v=Qk52ypnGs68">Number 9</a></li>
<li><a href="https://www.youtube.com/watch?v=brnCe8lL7l4">Day By Day</a></li>
<li><a href="https://www.youtube.com/watch?v=xJHUKzz1vss">Tiamo</a></li>
<li><a href="https://www.youtube.com/watch?v=qgGJ9PFb2hs">Never Ever</a> (智妍)</li>
<li><a href="https://www.youtube.com/watch?v=0xi9Zx4_BOg">Nice Body</a> (孝敏)</li>
<li><a href="https://www.youtube.com/watch?v=CEXfqzzl6Jg">Don’t leave</a></li>
<li><a href="https://www.youtube.com/watch?v=-Ju79e8rM0c">Cry Cry</a></li>
<li><a href="https://www.youtube.com/watch?v=maSoUetHock">So Crazy</a></li>
<li><a href="https://www.youtube.com/watch?v=A3RWBQeT-58">What’s Wrong</a></li>
<li><a href="https://www.youtube.com/watch?v=nJ31sMmytHU">We Were In Love</a></li>
</ul>
<h3 id="F-x-2009">F(x) (2009)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=BYGeGI1Ihlc">Shake That Bass</a> (Amber)</li>
<li><a href="https://www.youtube.com/watch?v=iv-8-EgPEY0">Red Light</a></li>
</ul>
<h3 id="Sistar-2010">Sistar (2010)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=9txzvu6eQuw">Touch My Body</a></li>
<li><a href="https://www.youtube.com/watch?v=x9-TIy7WPQI">Shake It</a></li>
<li><a href="https://www.youtube.com/watch?v=LJVUjmNMF8c">I Like That</a></li>
<li><a href="https://www.youtube.com/watch?v=E0ZHXVp_wUE">Alone</a></li>
<li><a href="https://www.youtube.com/watch?v=KbXV2R_Yd1E">Lonely</a></li>
<li><a href="https://www.youtube.com/watch?v=Y-FhDScM_2w">Some</a> (昭宥)</li>
</ul>
<h3 id="miss-A-2010">miss A (2010)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=8TeeJvcBdLA">Bad Girl Good Girl</a></li>
<li><a href="https://www.youtube.com/watch?v=zO9RzrhYR-I">Only You</a></li>
</ul>
<h3 id="Girls-Day-2010">Girls Day (2010)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=7crt2Ip93VI">I’ll Be Yours</a></li>
<li><a href="https://www.youtube.com/watch?v=zVO5xTAbxm8">Something</a></li>
<li><a href="https://www.youtube.com/watch?v=QB4dQcxgJPY">Darling</a></li>
<li><a href="https://www.youtube.com/watch?v=z4sN05-xIs4">Ring My Bell</a></li>
<li><a href="https://www.youtube.com/watch?v=fqR2HGkjFCA">Expectation</a></li>
</ul>
<h3 id="Apink-2011">Apink (2011)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=K5H-GvnNz2Y">Mr. Chu</a></li>
<li><a href="https://www.youtube.com/watch?v=mCRIqC7SEro">No No No</a></li>
<li><a href="https://www.youtube.com/watch?v=ZrxG8HZECXs">LUV</a></li>
<li><a href="https://www.youtube.com/watch?v=F4oHuML9U2A">I’m So Sick</a></li>
<li><a href="https://www.youtube.com/watch?v=499YUeNoYVE">% %</a></li>
<li><a href="https://www.youtube.com/watch?v=XTDRCwqqtC0">Bye Bye</a></li>
<li><a href="https://www.youtube.com/watch?v=b22Ed7f0D-0">Five</a></li>
</ul>
<h3 id="AOA-2012">AOA (2012)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=haGyhdjA7aQ">Excuse Me</a></li>
<li><a href="https://www.youtube.com/watch?v=qEYOyZVWlzs">Like A Cat</a></li>
<li><a href="https://www.youtube.com/watch?v=sno_genwMz8">Good Luck</a></li>
<li><a href="https://www.youtube.com/watch?v=1pBgMBBsv4k">Heart Attack</a></li>
<li><a href="https://www.youtube.com/watch?v=q6f-LLM1H6U">Miniskirt</a></li>
</ul>
<h3 id="EXID-2012">EXID (2012)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=hfXZ6ydgZyo">Up &amp; Down</a></li>
</ul>
<h3 id="Lovelyz-2014">Lovelyz (2014)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=S_IBk0RCsOo">Destiny</a></li>
</ul>
<h3 id="Mamamoo-2014">Mamamoo (2014)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=KhTeiaCezwM">HIP</a></li>
<li><a href="https://www.youtube.com/watch?v=pHtxTSiPh5I">Egotistic</a></li>
<li><a href="https://www.youtube.com/watch?v=Oao3j2hUVvE">gogobebe</a></li>
</ul>
<h3 id="CLC-2015">CLC (2015)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=u9OxRFab6o4">Hobgoblin</a></li>
<li><a href="https://www.youtube.com/watch?v=hF6Wds75rjg">Black Dress</a></li>
</ul>
<h3 id="Oh-My-Girl-2015">Oh My Girl (2015)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=_W4dL2Av6LE">A-ing</a></li>
</ul>
<h3 id="GFriend-2015">GFriend (2015)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=oixRBiOteWY">Me Gustas Tu</a></li>
<li><a href="https://www.youtube.com/watch?v=GU7icQFVzHo">Glass Bead</a></li>
<li><a href="https://www.youtube.com/watch?v=RSh5akaaHXk">Rough</a></li>
</ul>
<h3 id="Twice-2015">Twice (2015)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=c7rCyll5AeY">Cheer Up</a></li>
<li><a href="https://www.youtube.com/watch?v=ePpPVE-GGJw">TT</a></li>
<li><a href="https://www.youtube.com/watch?v=0rtV5esQT6I">Like OOH-AHH</a></li>
<li><a href="https://www.youtube.com/watch?v=8A2t_tAjMz8">Knock Knock</a></li>
<li><a href="https://www.youtube.com/watch?v=i0p1bmr0EmE">What Is Love</a></li>
</ul>
<h3 id="Blackpink-2016">Blackpink (2016)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=IHNzOHi8sJs">DDU-DU DDU-DU</a></li>
<li><a href="https://www.youtube.com/watch?v=bwmSjveL3Lc">BOOMBAYAH</a></li>
<li><a href="https://www.youtube.com/watch?v=Amq-qlqbjYA">As If It’s Your Last</a></li>
<li><a href="https://www.youtube.com/watch?v=2S24-y0Ij3Y">Kill This Love</a></li>
<li><a href="https://www.youtube.com/watch?v=9pdj4iJD08s">Play with Fire</a></li>
<li><a href="https://www.youtube.com/watch?v=dISNgvVpWlo">Whistle</a></li>
</ul>
<h3 id="宇宙少女-2016">宇宙少女 (2016)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=_uJxJ7tSi1w">Secret</a></li>
</ul>
<h3 id="G-I-DLE-2018">(G)I-DLE (2018)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=I66oFXdf0KU">Uh-Oh</a></li>
<li><a href="https://www.youtube.com/watch?v=OKNXn2qCEws">HANN</a></li>
<li><a href="https://www.youtube.com/watch?v=2cevbhEqQF4">Senorita</a></li>
<li><a href="https://www.youtube.com/watch?v=9mQk7Evt6Vs">LATATA</a></li>
</ul>
<h3 id="Everglow-2019">Everglow (2019)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=NoYKBAajoyo">Dun Dun</a></li>
</ul>
<h2 id="影视主题曲-歌名-剧名">影视主题曲 (歌名/剧名)</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=FeLQ_C9y4iA">愈來愈爱你</a> (假如爱有天意)</li>
<li><a href="https://www.youtube.com/watch?v=nKX2PPOxhns">我的你，你的我</a> (假如爱有天意)</li>
<li><a href="https://www.youtube.com/watch?v=fQjEU6v4kUY">幻听</a> (Kill Me Heal Me)</li>
<li><a href="https://www.youtube.com/watch?v=gQuD-qRixLU">青春</a> (请回答1988)</li>
<li><a href="https://www.youtube.com/watch?v=hzzqzfPGrOQ">命运</a> (浪漫满屋)</li>
<li><a href="https://www.youtube.com/watch?v=KeH_wHxLPSY">Never Say Goodbye</a> (我的女孩)</li>
<li><a href="https://www.youtube.com/watch?v=1173wW9CGkQ">无法原谅</a> (妻子的诱惑)</li>
<li><a href="https://www.youtube.com/watch?v=Gt2IrUBYlVw">秘密乐园</a> (夜行书生)</li>
<li><a href="https://www.youtube.com/watch?v=dEKOq0nbcYg">姻缘</a> (王的男人)</li>
<li><a href="https://www.youtube.com/watch?v=fokTOFjRfYs">时间倒流</a> (拥抱太阳的月亮)</li>
<li><a href="https://www.youtube.com/watch?v=S8RWhc_LmMc">I Believe</a> (我的野蛮女友)</li>
<li><a href="https://www.youtube.com/watch?v=HtkalU3yVEU">My Destiny</a> (来自星星的你)</li>
<li><a href="https://www.youtube.com/watch?v=jQomS_J0Yco">Stay With Me</a> (鬼怪)</li>
<li><a href="https://www.youtube.com/watch?v=daXqW2GWM_c">爱情雨</a> (爱情雨)</li>
<li><a href="https://www.youtube.com/watch?v=Y98o0cp4vHY">Everytime</a> (太阳的后裔)</li>
<li><a href="https://www.youtube.com/watch?v=QWinjNEkMDA">This love</a> (太阳的后裔)</li>
<li><a href="https://www.youtube.com/watch?v=FUCnFuCc--s">那个男人</a> (秘密花园)</li>
<li><a href="https://www.youtube.com/watch?v=SSW8b_h8CVg">戏子</a> (戏子)</li>
<li><a href="https://www.youtube.com/watch?v=vz_5FXeuQZI">If We Were Destined</a>（花游记）</li>
</ul>
<h2 id="其他歌曲-歌名-歌手">其他歌曲 (歌名/歌手)</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=JQGRg8XBnB4">BBoom BBoom</a> (Momoland)</li>
<li><a href="https://www.youtube.com/watch?v=2N9Bc8DA_io">没有去学校</a></li>
<li><a href="https://www.youtube.com/watch?v=wNnV2D7ME7A">Sleepless Night</a> (Nine Muses)</li>
<li><a href="https://www.youtube.com/watch?v=icAdKXH5OGI">Good Night Kiss</a> (全孝盛)</li>
<li><a href="https://www.youtube.com/watch?v=pvJDpWSHhVQ">Way Back Home</a> (Shaun)</li>
<li><a href="https://www.youtube.com/watch?v=kbvbHTgFeZQ">一个男人</a> (金钟国)</li>
<li><a href="https://www.youtube.com/watch?v=3rYL8AHJaTc">Can’t Breakup Girl, Can’t Breakaway Boy</a> (Leessang)</li>
<li><a href="https://www.youtube.com/watch?v=-HxaERgTNwY">Turned off the TV</a> (Leessang)</li>
<li><a href="https://www.youtube.com/watch?v=xMOj725xqhg">Ballerino</a> (Leessang)</li>
<li><a href="https://www.youtube.com/watch?v=sTGR8c-NTn4">Clown</a> (Leessang)</li>
<li><a href="https://www.youtube.com/watch?v=vokJDQ8EnNQ">Lee Ssang Blues</a> (Leessang)</li>
<li><a href="https://www.youtube.com/watch?v=p08JFzkinKM">Let’s Meet Now</a> (Leessang)</li>
<li><a href="https://www.youtube.com/watch?v=EualIydO4zE">You’re the Answer to a Guy like Me</a> (Leessang)</li>
<li><a href="https://www.youtube.com/watch?v=moxWZXFlkjo">Hard To Be Humble</a> (Leessang)</li>
<li><a href="https://www.youtube.com/watch?v=k5vNOVCOG3c">Rosa</a> (HaHa)</li>
<li><a href="https://www.youtube.com/watch?v=ZnltORxgUH0">矮个子小鬼的故事</a> (HaHa)</li>
<li><a href="https://www.youtube.com/watch?v=5gXVG6Of0TI">You’re My Destiny</a> (Haha)</li>
<li><a href="https://www.youtube.com/watch?v=JG_g5MMH9e4">杨花大桥</a> (Zion.T)</li>
<li><a href="https://www.youtube.com/watch?v=ECMc1SB60E0">Comes And Goes</a> (吴赫)</li>
<li><a href="https://www.youtube.com/watch?v=hr4GaRPX6cM">Wing Wing</a> (吴赫)</li>
<li><a href="https://www.youtube.com/watch?v=Da_dnbtQQL4">身材</a> (朴宰范)</li>
<li><a href="https://www.youtube.com/watch?v=KJSXolyj4DM">The Gloomy Song</a> (亨敦和大俊)</li>
<li><a href="https://www.youtube.com/watch?v=MXcBingZ71Q">火花</a> (高耀太)</li>
<li><a href="https://www.youtube.com/watch?v=gnJ82yLeu58">纯情</a> (高耀太)</li>
<li><a href="https://www.youtube.com/watch?v=OwJPPaEyqhI">New Face</a> (Psy)</li>
<li><a href="https://www.youtube.com/watch?v=9bZkp7q19f0">江南Style</a> (Psy)</li>
<li><a href="https://www.youtube.com/watch?v=UWIGP0JuFAA">Galaxy</a> (脸红的思春期)</li>
<li><a href="https://www.youtube.com/watch?v=0It6vWbGOX0">Hands Up</a>（Cherry Bullet）</li>
<li><a href="https://www.bilibili.com/video/av3219548/">那男人那女人</a>（Vibe）</li>
<li><a href="https://www.youtube.com/watch?v=gwcN-NQknx8">捐</a>（Big Mama）</li>
</ul>
<h2 id="Playlists">Playlists</h2>
<ul>
<li><a href="/blog/2019/12/15/%E9%9F%A9%E8%AF%AD%E6%AD%8C%E6%9B%B2Kpop/xiami_playlist.csv">虾米音乐 playlists</a></li>
</ul>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>kpop</tag>
        <tag>music</tag>
      </tags>
  </entry>
</search>
